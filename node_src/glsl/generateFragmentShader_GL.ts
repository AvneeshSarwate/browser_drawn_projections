/* eslint-disable no-useless-escape */
import { promises as fs } from 'node:fs';
import * as path from 'node:path';
import { parseFunctions, parseStructs, type GlslArgument, type GlslStruct } from './parseGlsl';

type Logger = (message: string) => void;

export interface GenerateFragmentShaderOptions {
  projectRoot: string;
  logger?: Logger;
}

export interface GenerateFragmentShaderResult {
  sourcePath: string;
  typesPath: string;
  updated: boolean;
}

const RAW_SUFFIX = '.fragFunc.glsl';
const TYPES_SUFFIX = '.frag.gl.generated.ts';

const HEADER_COMMENT = '// Auto-generated by glsl fragment generator. DO NOT EDIT.';

interface UniformField {
  name: string;
  bindingName: string;
  glslType: string;
  defaultExpression?: string;
  uiMin?: number;
  uiMax?: number;
  uiStep?: number;
  isArray?: boolean;
  arraySize?: number;
  elementType?: string;
}

interface UniformCommentAnnotation {
  defaultExpression?: string;
  uiMin?: number;
  uiMax?: number;
  uiStep?: number;
}

interface TextureParam {
  textureName: string;
}

interface PassTextureBinding extends TextureParam {
  source: 'input' | 'pass';
  passIndex?: number;
}

interface PassAnalysis {
  index: number;
  name: string;
  args: GlslArgument[];
  resourceBindings: PassTextureBinding[];
}

interface UniformTypeMetadata {
  tsType: string;
  setter: string;
  expression: (valueRef: string) => string;
  helper?: string;
}

const UNIFORM_TYPE_MAP: Record<string, UniformTypeMetadata> = {
  float: {
    tsType: 'number',
    setter: 'setFloat',
    expression: (valueRef) => valueRef,
  },
  int: {
    tsType: 'number',
    setter: 'setInt',
    expression: (valueRef) => valueRef,
  },
  uint: {
    tsType: 'number',
    setter: 'setUInt',
    expression: (valueRef) => valueRef,
  },
  bool: {
    tsType: 'boolean',
    setter: 'setFloat',
    expression: (valueRef) => `(${valueRef} ? 1 : 0)`,
  },
  vec2: {
    tsType: 'BABYLON.Vector2 | readonly [number, number]',
    setter: 'setVector2',
    expression: (valueRef) => `ensureVector2(${valueRef})`,
    helper: 'ensureVector2',
  },
  vec3: {
    tsType: 'BABYLON.Vector3 | readonly [number, number, number]',
    setter: 'setVector3',
    expression: (valueRef) => `ensureVector3(${valueRef})`,
    helper: 'ensureVector3',
  },
  vec4: {
    tsType: 'BABYLON.Vector4 | readonly [number, number, number, number]',
    setter: 'setVector4',
    expression: (valueRef) => `ensureVector4(${valueRef})`,
    helper: 'ensureVector4',
  },
  mat4: {
    tsType: 'BABYLON.Matrix | Float32Array | readonly number[]',
    setter: 'setMatrix',
    expression: (valueRef) => `ensureMatrix(${valueRef})`,
    helper: 'ensureMatrix',
  },
};

const HELPER_SNIPPETS: Record<string, string> = {
  ensureVector2: `function ensureVector2(value: BABYLON.Vector2 | readonly [number, number]): BABYLON.Vector2 {\n  return value instanceof BABYLON.Vector2 ? value : BABYLON.Vector2.FromArray(value as readonly [number, number]);\n}`,
  ensureVector3: `function ensureVector3(value: BABYLON.Vector3 | readonly [number, number, number]): BABYLON.Vector3 {\n  return value instanceof BABYLON.Vector3 ? value : BABYLON.Vector3.FromArray(value as readonly [number, number, number]);\n}`,
  ensureVector4: `function ensureVector4(value: BABYLON.Vector4 | readonly [number, number, number, number]): BABYLON.Vector4 {\n  return value instanceof BABYLON.Vector4 ? value : BABYLON.Vector4.FromArray(value as readonly [number, number, number, number]);\n}`,
  ensureMatrix: `function ensureMatrix(value: BABYLON.Matrix | Float32Array | readonly number[]): BABYLON.Matrix {\n  if (value instanceof BABYLON.Matrix) {\n    return value;\n  }\n  const matrix = BABYLON.Matrix.Identity();\n  matrix.copyFromArray(Array.from(value));\n  return matrix;\n}`,
  packVec2Array: `function packVec2Array(arr: Vec2Like[]): number[] {\n  return arr.flatMap(v => [v.x, v.y]);\n}`,
  packVec3Array: `function packVec3Array(arr: Vec3Like[]): number[] {\n  return arr.flatMap(v => [v.x, v.y, v.z]);\n}`,
  packVec4Array: `function packVec4Array(arr: Vec4Like[]): number[] {\n  return arr.flatMap(v => [v.x, v.y, v.z, v.w]);\n}`,
};

const VEC_LIKE_INTERFACES = `export interface Vec2Like { x: number; y: number }
export interface Vec3Like { x: number; y: number; z: number }
export interface Vec4Like { x: number; y: number; z: number; w: number }`;

interface ArrayUniformMeta {
  tsType: string;
  setter: string;
  pack: string | null;
}

const ARRAY_ELEMENT_TYPE_MAP: Record<string, ArrayUniformMeta> = {
  float: { tsType: 'number[]', setter: 'setFloats', pack: null },
  int: { tsType: 'number[]', setter: 'setFloats', pack: null },
  uint: { tsType: 'number[]', setter: 'setFloats', pack: null },
  vec2: { tsType: 'Vec2Like[]', setter: 'setArray2', pack: 'packVec2Array' },
  vec3: { tsType: 'Vec3Like[]', setter: 'setArray3', pack: 'packVec3Array' },
  vec4: { tsType: 'Vec4Like[]', setter: 'setArray4', pack: 'packVec4Array' },
};

function toPascalCase(value: string): string {
  return value
    .replace(/[-_]/g, ' ')
    .split(' ')
    .filter(Boolean)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
}

function escapeTemplateLiteral(value: string): string {
  return `\`${value
    .replace(/\\/g, '\\\\')
    .replace(/`/g, '\\`')
    .replace(/\$\{/g, '\\${')}\``;
}

function toImportPath(relativePath: string): string {
  const normalized = relativePath.replace(/\\/g, '/');
  if (normalized.startsWith('.')) {
    return normalized;
  }
  return `./${normalized}`;
}

async function writeFileIfChanged(filePath: string, content: string): Promise<boolean> {
  let existing: string | null = null;
  try {
    existing = await fs.readFile(filePath, 'utf8');
  } catch (error: any) {
    if (error?.code !== 'ENOENT') {
      throw error;
    }
  }
  if (existing === content) {
    return false;
  }
  await fs.mkdir(path.dirname(filePath), { recursive: true });
  await fs.writeFile(filePath, content, 'utf8');
  return true;
}

function collectUniformFields(struct: GlslStruct, uniformArgName: string, shaderSource: string): UniformField[] {
  const annotationMap = extractUniformAnnotations(shaderSource, struct.name);
  return struct.members.map((member) => {
    const bindingName = `${uniformArgName}_${member.name}`;
    const annotations = annotationMap[member.name];
    const typeName = member.type;

    if (member.arraySize !== undefined && member.arraySize > 0) {
      if (!ARRAY_ELEMENT_TYPE_MAP[typeName]) {
        throw new Error(`Uniform array field ${member.name} uses unsupported element type ${typeName}.`);
      }
      return {
        name: member.name,
        bindingName,
        glslType: typeName,
        defaultExpression: annotations?.defaultExpression,
        uiMin: annotations?.uiMin,
        uiMax: annotations?.uiMax,
        uiStep: annotations?.uiStep,
        isArray: true,
        arraySize: member.arraySize,
        elementType: typeName,
      };
    }

    if (!UNIFORM_TYPE_MAP[typeName]) {
      throw new Error(`Uniform field ${member.name} uses unsupported type ${typeName}.`);
    }
    return {
      name: member.name,
      bindingName,
      glslType: typeName,
      defaultExpression: annotations?.defaultExpression,
      uiMin: annotations?.uiMin,
      uiMax: annotations?.uiMax,
      uiStep: annotations?.uiStep,
    };
  });
}

function extractUniformAnnotations(source: string, structName: string): Record<string, UniformCommentAnnotation> {
  const annotations: Record<string, UniformCommentAnnotation> = {};
  const structRegex = new RegExp(`struct\\s+${structName}\\s*\\{`, 'g');
  const match = structRegex.exec(source);
  if (!match) {
    return annotations;
  }
  const braceStart = source.indexOf('{', match.index);
  if (braceStart === -1) {
    return annotations;
  }
  let depth = 0;
  let endIndex = braceStart;
  for (let i = braceStart; i < source.length; i++) {
    const char = source[i];
    if (char === '{') {
      depth++;
    } else if (char === '}') {
      depth--;
      if (depth === 0) {
        endIndex = i;
        break;
      }
    }
  }
  const body = source.slice(braceStart + 1, endIndex);
  const lines = body.split(/\r?\n/);
  for (const rawLine of lines) {
    const line = rawLine.trim();
    if (!line) {
      continue;
    }
    const commentIndex = line.indexOf('//');
    if (commentIndex === -1) {
      continue;
    }
    const comment = line.slice(commentIndex + 2).trim();
    if (!comment) {
      continue;
    }
    const declarationPart = line.slice(0, commentIndex).trim().replace(/;$/, '');
    const fieldMatch = declarationPart.match(/^([A-Za-z0-9_]+)\s+([A-Za-z0-9_]+)/);
    if (!fieldMatch) {
      continue;
    }
    const fieldName = fieldMatch[2];
    const annotation = parseUniformComment(comment);
    if (annotation) {
      annotations[fieldName] = annotation;
    }
  }
  return annotations;
}

function parseUniformComment(comment: string): UniformCommentAnnotation | null {
  const trimmed = comment.trim();
  if (!trimmed) {
    return null;
  }
  const annotation: UniformCommentAnnotation = {};
  const defaultExpression = parseDefaultExpression(trimmed);
  if (defaultExpression !== null) {
    annotation.defaultExpression = defaultExpression;
  }
  const minMatch = trimmed.match(/(?:^|\s)min=([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)/);
  const maxMatch = trimmed.match(/(?:^|\s)max=([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)/);
  const stepMatch = trimmed.match(/(?:^|\s)step=([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)/);
  if (minMatch) {
    const value = Number(minMatch[1]);
    if (!Number.isNaN(value)) {
      annotation.uiMin = value;
    }
  }
  if (maxMatch) {
    const value = Number(maxMatch[1]);
    if (!Number.isNaN(value)) {
      annotation.uiMax = value;
    }
  }
  if (stepMatch) {
    const value = Number(stepMatch[1]);
    if (!Number.isNaN(value)) {
      annotation.uiStep = value;
    }
  }
  return Object.keys(annotation).length > 0 ? annotation : null;
}

function parseDefaultExpression(comment: string): string | null {
  const trimmed = comment.trim();
  if (!trimmed || /^(?:min|max|step)=/i.test(trimmed)) {
    return null;
  }

  let candidate = trimmed;
  const firstChar = trimmed[0];

  if (firstChar === '[') {
    const match = trimmed.match(/^\[[^\]]*\]/);
    if (match) {
      candidate = match[0];
    }
  } else if (firstChar === '{') {
    const match = trimmed.match(/^\{[^\}]*\}/);
    if (match) {
      candidate = match[0];
    }
  } else if (firstChar === '(') {
    const match = trimmed.match(/^\([^\)]*\)/);
    if (match) {
      candidate = match[0];
    }
  } else {
    const match = trimmed.match(/^[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?/);
    if (match) {
      candidate = match[0];
    }
  }

  return candidate || null;
}

function validateUvArgument(argument: GlslArgument): void {
  const typeName = argument.type;
  if (typeName !== 'vec2') {
    throw new Error(`First argument must be a vec2 called uv. Received ${argument.name}: ${typeName}`);
  }
}

function glslKind(typeName: string): string {
  const map: Record<string, string> = {
    float: 'f32',
    int: 'i32',
    uint: 'u32',
    bool: 'bool',
    vec2: 'vec2f',
    vec3: 'vec3f',
    vec4: 'vec4f',
    mat4: 'mat4x4f',
  };
  return map[typeName] ?? 'f32';
}

function buildUniformDeclarations(fields: UniformField[]): string[] {
  return fields.map((field) => {
    if (field.isArray && field.arraySize) {
      return `uniform ${field.glslType} ${field.bindingName}[${field.arraySize}];`;
    }
    return `uniform ${field.glslType} ${field.bindingName};`;
  });
}

export async function generateFragmentShaderArtifacts(filePath: string, options: GenerateFragmentShaderOptions): Promise<GenerateFragmentShaderResult> {
  const projectRoot = options.projectRoot;
  const logger = options.logger;

  const absoluteSource = path.resolve(filePath);
  if (!absoluteSource.endsWith(RAW_SUFFIX)) {
    throw new Error(`Expected a ${RAW_SUFFIX} file, got ${filePath}`);
  }

  const basePath = absoluteSource.slice(0, -RAW_SUFFIX.length);
  const typesPath = `${basePath}${TYPES_SUFFIX}`;

  const shaderCode = await fs.readFile(absoluteSource, 'utf8');
  const structs = parseStructs(shaderCode);
  const functions = parseFunctions(shaderCode);
  const structMap = new Map(structs.map((entry) => [entry.name, entry]));

  const passFunctions = functions.filter((fn) => /^pass\d+$/.test(fn.name));
  if (passFunctions.length === 0) {
    throw new Error(`No pass functions found. Expected one or more functions named pass0, pass1, ... in fragment shader.`);
  }

  const indexedPasses = passFunctions
    .map((fn) => ({ fn, index: Number(fn.name.replace('pass', '')) }))
    .sort((a, b) => a.index - b.index);

  const seenIndices = new Set<number>();
  for (const entry of indexedPasses) {
    if (Number.isNaN(entry.index)) {
      throw new Error(`Invalid pass function name ${entry.fn.name}.`);
    }
    if (seenIndices.has(entry.index)) {
      throw new Error(`Duplicate pass index detected for pass${entry.index}.`);
    }
    seenIndices.add(entry.index);
  }
  if (indexedPasses[0].index !== 0) {
    throw new Error(`Pass indexes must start at 0. Received pass${indexedPasses[0].index}.`);
  }
  for (let position = 0; position < indexedPasses.length; position++) {
    if (indexedPasses[position].index !== position) {
      throw new Error(`Missing pass${position}. Pass functions must form a contiguous sequence starting at pass0.`);
    }
  }

  const orderedPassFunctions = indexedPasses.map((entry) => entry.fn);
  const passCount = orderedPassFunctions.length;

  const primaryPass = orderedPassFunctions[0];
  for (const passFn of orderedPassFunctions) {
    if (passFn.returnType !== 'vec4') {
      throw new Error(`Fragment pass ${passFn.name} must return vec4. Received ${passFn.returnType ?? 'void'}.`);
    }
  }

  const uvArg = primaryPass.args[0];
  if (!uvArg) {
    throw new Error('pass0 must declare at least a uv argument.');
  }
  validateUvArgument(uvArg);

  let uniformStruct: GlslStruct | null = null;
  let uniformArgName: string | null = null;
  let resourceStartIndex = 1;
  if (primaryPass.args.length >= 2) {
    const candidateType = primaryPass.args[1].type;
    const candidateStruct = structMap.get(candidateType);
    if (candidateStruct) {
      uniformStruct = candidateStruct;
      uniformArgName = primaryPass.args[1].name;
      resourceStartIndex = 2;
    }
  }

  const uniformFields = uniformStruct && uniformArgName
    ? collectUniformFields(uniformStruct, uniformArgName, shaderCode)
    : [];

  const textureParams: TextureParam[] = [];
  const inputTextureParams: TextureParam[] = [];
  const baseTextureParams: TextureParam[] = [];
  const baseTextureLookup = new Map<string, TextureParam>();
  const textureParamMap = new Map<string, TextureParam>();
  const passAnalyses: PassAnalysis[] = [];
  const passTextureBindings: PassTextureBinding[][] = [];

  const analyzePassResources = (passFn: typeof primaryPass, passIndex: number): PassTextureBinding[] => {
    const passArgs = passFn.args;
    if (passArgs.length < resourceStartIndex) {
      throw new Error(`${passFn.name} must declare at least ${resourceStartIndex} arguments (uv${uniformStruct ? ', uniforms' : ''}).`);
    }
    validateUvArgument(passArgs[0]);
    if (uniformStruct && uniformArgName) {
      const argument = passArgs[1];
      if (!argument || argument.type !== uniformStruct.name) {
        throw new Error(`${passFn.name} uniforms must be ${uniformStruct.name}.`);
      }
    }

    const bindings: PassTextureBinding[] = [];
    for (let argumentIndex = resourceStartIndex; argumentIndex < passArgs.length; argumentIndex += 1) {
      const textureArg = passArgs[argumentIndex];
      if (!textureArg) {
        continue;
      }
      if (textureArg.type !== 'sampler2D') {
        throw new Error(`Texture argument must be sampler2D. Received ${textureArg.name}: ${textureArg.type}`);
      }
      const passDependencyMatch = /^pass(\d+)Texture$/.exec(textureArg.name);
      if (passDependencyMatch) {
        const dependencyIndex = Number(passDependencyMatch[1]);
        if (Number.isNaN(dependencyIndex)) {
          throw new Error(`Invalid pass dependency ${textureArg.name} in ${passFn.name}.`);
        }
        if (dependencyIndex < 0 || dependencyIndex >= passIndex) {
          throw new Error(`Pass ${passFn.name} can only depend on earlier passes. Received dependency on pass${dependencyIndex}.`);
        }
        bindings.push({
          textureName: textureArg.name,
          source: 'pass',
          passIndex: dependencyIndex,
        });
        if (!textureParamMap.has(textureArg.name)) {
          textureParamMap.set(textureArg.name, { textureName: textureArg.name });
        }
        continue;
      }

      const baseTexture = baseTextureLookup.get(textureArg.name);
      if (!baseTexture) {
        if (passIndex === 0) {
          const param: TextureParam = { textureName: textureArg.name };
          baseTextureParams.push(param);
          baseTextureLookup.set(textureArg.name, param);
          textureParamMap.set(textureArg.name, param);
        } else {
          throw new Error(`Pass ${passFn.name} references unknown texture ${textureArg.name}. Base textures must be declared in pass0.`);
        }
      }

      bindings.push({
        textureName: textureArg.name,
        source: 'input',
      });
    }

    return bindings;
  };

  orderedPassFunctions.forEach((passFn, passIndex) => {
    const bindings = analyzePassResources(passFn, passIndex);
    passAnalyses.push({
      index: passIndex,
      name: passFn.name,
      args: passFn.args,
      resourceBindings: bindings,
    });
    passTextureBindings.push(bindings);
  });

  textureParams.push(...Array.from(textureParamMap.values()));
  inputTextureParams.push(...baseTextureParams);

  if (textureParams.length === 0) {
    throw new Error('At least one texture argument is required for a pass.');
  }
  const primaryTexture = textureParams[0];
  if (!primaryTexture) {
    throw new Error('At least one texture argument is required for a pass.');
  }

  const shaderBaseName = path.basename(basePath);
  const shaderPrefix = toPascalCase(shaderBaseName);
  const effectClassName = `${shaderPrefix}Effect`;

  const vertexSourceLines: string[] = [];
  vertexSourceLines.push(HEADER_COMMENT);
  vertexSourceLines.push('#version 300 es');
  vertexSourceLines.push('precision highp float;');
  vertexSourceLines.push('');
  vertexSourceLines.push('in vec3 position;');
  vertexSourceLines.push('in vec2 uv;');
  vertexSourceLines.push('out vec2 vUV;');
  vertexSourceLines.push('');
  vertexSourceLines.push('void main() {');
  vertexSourceLines.push('  gl_Position = vec4(position, 1.0);');
  vertexSourceLines.push('  vUV = uv;');
  vertexSourceLines.push('}');

  const vertexSource = vertexSourceLines.join('\n');

  const fragmentSources = passAnalyses.map((passInfo) => {
    const fragmentLines: string[] = [];
    fragmentLines.push(HEADER_COMMENT);
    fragmentLines.push('#version 300 es');
    fragmentLines.push('precision highp float;');
    fragmentLines.push('');
    fragmentLines.push('in vec2 vUV;');
    fragmentLines.push('out vec4 outColor;');
    fragmentLines.push(...buildUniformDeclarations(uniformFields));
    for (const binding of passInfo.resourceBindings) {
      fragmentLines.push(`uniform sampler2D ${binding.textureName};`);
    }
    fragmentLines.push('');
    fragmentLines.push(shaderCode.trim());
    fragmentLines.push('');
    if (uniformStruct && uniformArgName) {
      fragmentLines.push(`${uniformStruct.name} load_${uniformStruct.name}() {`);
      fragmentLines.push(`  ${uniformStruct.name} result;`);
      for (const field of uniformFields) {
        fragmentLines.push(`  result.${field.name} = ${field.bindingName};`);
      }
      fragmentLines.push('  return result;');
      fragmentLines.push('}');
      fragmentLines.push('');
    }
    fragmentLines.push('void main() {');
    if (uniformStruct && uniformArgName) {
      fragmentLines.push(`  ${uniformStruct.name} uniforms_value = load_${uniformStruct.name}();`);
    }
    fragmentLines.push('  vec2 uv_local = vUV;');
    const args: string[] = ['uv_local'];
    if (uniformStruct && uniformArgName) {
      args.push('uniforms_value');
    }
    for (const binding of passInfo.resourceBindings) {
      args.push(binding.textureName);
    }
    fragmentLines.push(`  vec4 color = ${passInfo.name}(${args.join(', ')});`);
    fragmentLines.push('  outColor = color;');
    fragmentLines.push('}');
    return fragmentLines.join('\n');
  });

  const uniformInterfaceName = `${shaderPrefix}Uniforms`;
  const uniformMetaConstName = `${shaderPrefix}UniformMeta`;

  const shaderFxImportPath = toImportPath(
    path.relative(path.dirname(typesPath), path.join(projectRoot, 'src/rendering/babylonGL/shaderFXBabylon_GL')),
  );
  const shaderFxImports = [
    'CustomShaderEffect',
    'type ShaderSource',
    'type RenderPrecision',
    'type UniformDescriptor',
    'type ShaderUniforms',
    'type Dynamic',
  ];

  const helperNames = new Set<string>();
  const uniformInterfaceLines: string[] = [];
  const uniformSetterLines: string[] = [];
  const hasArrayFields = uniformFields.some((field) => field.isArray);

  if (uniformStruct && uniformFields.length > 0) {
    uniformInterfaceLines.push(`export interface ${uniformInterfaceName} {`);
    for (const field of uniformFields) {
      if (field.isArray && field.elementType) {
        const arrayMeta = ARRAY_ELEMENT_TYPE_MAP[field.elementType];
        if (!arrayMeta) {
          throw new Error(`Unsupported array element type ${field.elementType}.`);
        }
        uniformInterfaceLines.push(`  ${field.name}: ${arrayMeta.tsType};`);
        if (arrayMeta.pack) {
          helperNames.add(arrayMeta.pack);
        }
      } else {
        const meta = UNIFORM_TYPE_MAP[field.glslType];
        uniformInterfaceLines.push(`  ${field.name}: ${meta.tsType};`);
        if (meta.helper) {
          helperNames.add(meta.helper);
        }
      }
    }
    uniformInterfaceLines.push('}');

    uniformSetterLines.push(`export function set${uniformInterfaceName}(material: BABYLON.ShaderMaterial, uniforms: Partial<${uniformInterfaceName}>): void {`);
    uniformSetterLines.push('  if (!uniforms) {');
    uniformSetterLines.push('    return;');
    uniformSetterLines.push('  }');
    for (const field of uniformFields) {
      uniformSetterLines.push(`  if (uniforms.${field.name} !== undefined) {`);
      if (field.isArray && field.elementType) {
        const arrayMeta = ARRAY_ELEMENT_TYPE_MAP[field.elementType];
        if (arrayMeta.pack) {
          uniformSetterLines.push(`    material.${arrayMeta.setter}('${field.bindingName}', ${arrayMeta.pack}(uniforms.${field.name}));`);
        } else {
          uniformSetterLines.push(`    material.${arrayMeta.setter}('${field.bindingName}', uniforms.${field.name});`);
        }
      } else {
        const meta = UNIFORM_TYPE_MAP[field.glslType];
        uniformSetterLines.push(`    material.${meta.setter}('${field.bindingName}', ${meta.expression(`uniforms.${field.name}`)});`);
      }
      uniformSetterLines.push('  }');
    }
    uniformSetterLines.push('}');
  }

  const helperBlocks = Array.from(helperNames).map((name) => HELPER_SNIPPETS[name]);
  const uniformsArrayLiteral = uniformFields.length
    ? `[${uniformFields.map((field) => `'${field.bindingName}'`).join(', ')}]`
    : '[]';
  const textureNamesArrayLiteral = `[${textureParams.map((param) => `'${param.textureName}'`).join(', ')}]`;
  const inputTextureNamesArrayLiteral = `[${inputTextureParams.map((param) => `'${param.textureName}'`).join(', ')}]`;

  const materialHandlesName = `${shaderPrefix}MaterialHandles`;
  const materialOptionsName = `${shaderPrefix}MaterialOptions`;
  const setUniformsFunctionName = uniformStruct && uniformFields.length > 0 ? `set${uniformInterfaceName}` : null;

  const tsLines: string[] = [];
  tsLines.push(HEADER_COMMENT);
  tsLines.push(`import * as BABYLON from 'babylonjs';`);
  tsLines.push(`import { ${shaderFxImports.join(', ')} } from '${shaderFxImportPath}';`);
  tsLines.push(`export const ${shaderPrefix}VertexSource = ${escapeTemplateLiteral(vertexSource)};`);
  tsLines.push(`export const ${shaderPrefix}FragmentSources = [`);
  fragmentSources.forEach((source, index) => {
    tsLines.push(`  ${escapeTemplateLiteral(source)}, // pass${index}`);
  });
  tsLines.push(`] as const;`);
  tsLines.push(`export const ${shaderPrefix}PassCount = ${passCount} as const;`);
  tsLines.push(`export const ${shaderPrefix}PrimaryTextureName = '${primaryTexture.textureName}' as const;`);
  tsLines.push('');

  const passTextureSourceLines: string[] = [];
  passTextureSourceLines.push(`export const ${shaderPrefix}PassTextureSources = [`);
  passTextureBindings.forEach((bindings) => {
    passTextureSourceLines.push('  [');
    bindings.forEach((binding) => {
      if (binding.source === 'input') {
        passTextureSourceLines.push(
          `    { binding: '${binding.textureName}', source: { kind: 'input', key: '${binding.textureName}' } },`,
        );
      } else {
        passTextureSourceLines.push(
          `    { binding: '${binding.textureName}', source: { kind: 'pass', passIndex: ${binding.passIndex} } },`,
        );
      }
    });
    passTextureSourceLines.push('  ],');
  });
  passTextureSourceLines.push(`] as const;`);
  passTextureSourceLines.push('');
  tsLines.push(...passTextureSourceLines);

  const uniformMetaLines: string[] = [];
  if (uniformFields.length > 0) {
    uniformMetaLines.push(`export const ${uniformMetaConstName}: UniformDescriptor[] = [`);
    uniformFields.forEach((field) => {
      uniformMetaLines.push('  {');
      uniformMetaLines.push(`    name: '${field.name}',`);
      if (field.isArray && field.elementType) {
        uniformMetaLines.push(`    kind: '${glslKind(field.elementType)}',`);
        uniformMetaLines.push(`    isArray: true,`);
        uniformMetaLines.push(`    arraySize: ${field.arraySize},`);
      } else {
        uniformMetaLines.push(`    kind: '${glslKind(field.glslType)}',`);
      }
      uniformMetaLines.push(`    bindingName: '${field.bindingName}',`);
      if (field.defaultExpression) {
        uniformMetaLines.push(`    default: ${field.defaultExpression},`);
      }
      const uiEntries: string[] = [];
      if (field.uiMin !== undefined) {
        uiEntries.push(`min: ${field.uiMin}`);
      }
      if (field.uiMax !== undefined) {
        uiEntries.push(`max: ${field.uiMax}`);
      }
      if (field.uiStep !== undefined) {
        uiEntries.push(`step: ${field.uiStep}`);
      }
      if (uiEntries.length > 0) {
        uniformMetaLines.push(`    ui: { ${uiEntries.join(', ')} },`);
      }
      uniformMetaLines.push('  },');
    });
    uniformMetaLines.push('];');
  } else {
    uniformMetaLines.push(`export const ${uniformMetaConstName}: UniformDescriptor[] = [];`);
  }
  uniformMetaLines.push('');
  tsLines.push(...uniformMetaLines);

  if (hasArrayFields) {
    tsLines.push(VEC_LIKE_INTERFACES);
    tsLines.push('');
  }
  if (helperBlocks.length > 0) {
    tsLines.push(...helperBlocks);
    tsLines.push('');
  }
  if (uniformStruct && uniformFields.length > 0) {
    tsLines.push(...uniformInterfaceLines);
    tsLines.push('');
    tsLines.push(...uniformSetterLines);
    tsLines.push('');
  } else {
    tsLines.push(`export type ${uniformInterfaceName} = Record<string, never>;`);
    tsLines.push(`export function set${uniformInterfaceName}(_material: BABYLON.ShaderMaterial, _uniforms: Partial<${uniformInterfaceName}>): void { }`);
    tsLines.push('');
  }

  tsLines.push(`export type ${shaderPrefix}TextureName = ${textureParams.map((param) => `'${param.textureName}'`).join(' | ')};`);
  tsLines.push(`export interface ${shaderPrefix}Inputs {`);
  inputTextureParams.forEach((param) => {
    tsLines.push(`  ${param.textureName}: ShaderSource;`);
  });
  tsLines.push('}');
  tsLines.push('');

  tsLines.push(`export interface ${materialHandlesName} {`);
  tsLines.push('  material: BABYLON.ShaderMaterial;');
  tsLines.push(`  setTexture(name: ${shaderPrefix}TextureName, texture: BABYLON.BaseTexture): void;`);
  tsLines.push(`  setTextureSampler(name: ${shaderPrefix}TextureName, sampler: BABYLON.TextureSampler): void;`);
  tsLines.push(`  setUniforms(uniforms: Partial<${uniformInterfaceName}>): void;`);
  tsLines.push('}');
  tsLines.push('');

  tsLines.push(`export interface ${materialOptionsName} {`);
  tsLines.push('  name?: string;');
  tsLines.push('  passIndex?: number;');
  tsLines.push('}');
  tsLines.push('');

  tsLines.push(`export function create${shaderPrefix}Material(scene: BABYLON.Scene, options: ${materialOptionsName} = {}): ${materialHandlesName} {`);
  tsLines.push('  const passIndex = options.passIndex ?? 0;');
  tsLines.push(`  if (passIndex < 0 || passIndex >= ${passCount}) {`);
  tsLines.push(`    throw new Error('Invalid passIndex ' + passIndex + ' for ${shaderPrefix}. Expected 0 <= passIndex < ${passCount}.');`);
  tsLines.push('  }');
  tsLines.push(`  const baseName = options.name ?? '${shaderPrefix}Material';`);
  tsLines.push('  const shaderName = `${baseName}_pass${passIndex}`;');
  tsLines.push('  const vertexShaderName = `${shaderName}VertexShader`;');
  tsLines.push('  const fragmentShaderName = `${shaderName}FragmentShader`;');
  tsLines.push('');
  tsLines.push(`  BABYLON.ShaderStore.ShadersStore[vertexShaderName] = ${shaderPrefix}VertexSource;`);
  tsLines.push(`  BABYLON.ShaderStore.ShadersStore[fragmentShaderName] = ${shaderPrefix}FragmentSources[passIndex];`);
  tsLines.push('');
  tsLines.push('  const material = new BABYLON.ShaderMaterial(shaderName, scene, {');
  tsLines.push('    vertex: shaderName,');
  tsLines.push('    fragment: shaderName,');
  tsLines.push('  }, {');
  tsLines.push(`    attributes: ['position', 'uv'],`);
  tsLines.push(`    uniforms: ${uniformsArrayLiteral},`);
  tsLines.push(`    samplers: ${textureNamesArrayLiteral},`);
  tsLines.push('    shaderLanguage: BABYLON.ShaderLanguage.GLSL,');
  tsLines.push('  });');
  tsLines.push('');

  tsLines.push('  const defaultSampler = new BABYLON.TextureSampler();');
  tsLines.push('  defaultSampler.setParameters(');
  tsLines.push('    BABYLON.Texture.CLAMP_ADDRESSMODE,');
  tsLines.push('    BABYLON.Texture.CLAMP_ADDRESSMODE,');
  tsLines.push('    BABYLON.Texture.CLAMP_ADDRESSMODE,');
  tsLines.push('    undefined,');
  tsLines.push('    BABYLON.Texture.BILINEAR_SAMPLINGMODE,');
  tsLines.push('  );');
  tsLines.push('  const samplerState: Record<string, BABYLON.TextureSampler> = {};');
  tsLines.push(`  const textureState: Partial<Record<${shaderPrefix}TextureName, BABYLON.BaseTexture | null>> = {};`);
  tsLines.push('  const applySamplerToTexture = (texture: BABYLON.BaseTexture | null, sampler: BABYLON.TextureSampler) => {');
  tsLines.push('    if (!texture) return;');
  tsLines.push('    const wrapU = sampler.wrapU;');
  tsLines.push('    if (wrapU !== null && wrapU !== undefined) {');
  tsLines.push('      texture.wrapU = wrapU;');
  tsLines.push('    }');
  tsLines.push('    const wrapV = sampler.wrapV;');
  tsLines.push('    if (wrapV !== null && wrapV !== undefined) {');
  tsLines.push('      texture.wrapV = wrapV;');
  tsLines.push('    }');
  tsLines.push('    const wrapR = sampler.wrapR;');
  tsLines.push('    if (wrapR !== null && wrapR !== undefined) {');
  tsLines.push('      texture.wrapR = wrapR;');
  tsLines.push('    }');
  tsLines.push('    texture.updateSamplingMode(sampler.samplingMode);');
  tsLines.push('  };');
  tsLines.push('');

  tsLines.push(`  const handles: ${materialHandlesName} = {`);
  tsLines.push('    material,');
  tsLines.push('    setTexture: (name, texture) => {');
  tsLines.push('      material.setTexture(name, texture);');
  tsLines.push('      textureState[name] = texture;');
  tsLines.push('      const sampler = samplerState[name] ?? defaultSampler;');
  tsLines.push('      applySamplerToTexture(texture, sampler);');
  tsLines.push('    },');
  tsLines.push('    setTextureSampler: (name, sampler) => {');
  tsLines.push('      samplerState[name] = sampler;');
  tsLines.push('      const texture = textureState[name] ?? null;');
  tsLines.push('      applySamplerToTexture(texture, sampler);');
  tsLines.push('    },');
  tsLines.push(`    setUniforms: ${(setUniformsFunctionName ?? `(_uniforms) => { }`)},`);
  if (setUniformsFunctionName) {
    tsLines[tsLines.length - 1] = `    setUniforms: (values) => ${setUniformsFunctionName}(material, values),`;
  }
  tsLines.push('  };');
  tsLines.push('');
  tsLines.push('  return handles;');
  tsLines.push('}');
  tsLines.push('');

  tsLines.push(`export class ${effectClassName} extends CustomShaderEffect<${uniformInterfaceName}, ${shaderPrefix}Inputs> {`);
  tsLines.push(`  effectName = '${shaderPrefix}'`);
  tsLines.push('');
  tsLines.push(`  constructor(engine: BABYLON.Engine, inputs: ${shaderPrefix}Inputs, width = 1280, height = 720, sampleMode: 'nearest' | 'linear' = 'linear', precision: RenderPrecision = 'half_float') {`);
  tsLines.push('    super(engine, inputs, {');
  tsLines.push(`      factory: (sceneRef, options) => create${shaderPrefix}Material(sceneRef, options),`);
  tsLines.push(`      textureInputKeys: ${inputTextureNamesArrayLiteral},`);
  tsLines.push(`      textureBindingKeys: ${inputTextureNamesArrayLiteral},`);
  tsLines.push(`      passTextureSources: ${shaderPrefix}PassTextureSources,`);
  tsLines.push(`      passCount: ${passCount},`);
  tsLines.push(`      primaryTextureKey: '${primaryTexture.textureName}',`);
  tsLines.push('      width,');
  tsLines.push('      height,');
  tsLines.push(`      materialName: '${shaderPrefix}Material',`);
  tsLines.push('      sampleMode,');
  tsLines.push('      precision,');
  tsLines.push(`      uniformMeta: ${uniformMetaConstName},`);
  tsLines.push('    });');
  if (uniformFields.length > 0) {
    tsLines.push('    this.setUniforms({');
    for (const field of uniformFields) {
      if (field.defaultExpression) {
        tsLines.push(`      ${field.name}: ${field.defaultExpression},`);
      }
    }
    tsLines.push('    });');
  }
  tsLines.push('  }');
  tsLines.push('');

  tsLines.push(`  override setSrcs(inputs: Partial<${shaderPrefix}Inputs>): void {`);
  tsLines.push('    super.setSrcs(inputs);');
  tsLines.push('  }');
  tsLines.push('');

  if (uniformFields.length > 0) {
    const dynamicFields = uniformFields.map((field) => {
      if (field.isArray && field.elementType) {
        const arrayMeta = ARRAY_ELEMENT_TYPE_MAP[field.elementType];
        return `${field.name}?: Dynamic<${arrayMeta.tsType}>`;
      }
      return `${field.name}?: Dynamic<${UNIFORM_TYPE_MAP[field.glslType].tsType}>`;
    });
    tsLines.push(`  override setUniforms(uniforms: { ${dynamicFields.join('; ')} }): void {`);
    tsLines.push('    const record: ShaderUniforms = {};');
    for (const field of uniformFields) {
      tsLines.push(`    if (uniforms.${field.name} !== undefined) {`);
      tsLines.push(`      record['${field.name}'] = uniforms.${field.name};`);
      tsLines.push('    }');
    }
    tsLines.push('    super.setUniforms(record);');
    tsLines.push('  }');
  }
  tsLines.push('}');

  const typesSource = tsLines.join('\n');
  const updated = await writeFileIfChanged(typesPath, typesSource);
  if (updated && logger) {
    logger(`Generated ${path.relative(projectRoot, typesPath)}`);
  }

  return {
    sourcePath: absoluteSource,
    typesPath,
    updated,
  };
}
