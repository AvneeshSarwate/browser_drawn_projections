import { promises as fs } from 'node:fs';
import * as path from 'node:path';
import { parseFunctions, parseStructs, type GlslArgument, type GlslStruct } from './parseGlsl';

type Logger = (message: string) => void;

export interface GenerateMaterialTypesOptions {
  projectRoot: string;
  logger?: Logger;
}

export interface GenerateMaterialTypesResult {
  sourcePath: string;
  outputPath: string;
  updated: boolean;
}

const RAW_SUFFIX = '.material.glsl';
const OUTPUT_SUFFIX = '.material.gl.generated.ts';
const HEADER_COMMENT = '// Auto-generated by power2d glsl material generator. DO NOT EDIT.';
const SHAPE_TRANSLATE_UNIFORM = 'power2d_shapeTranslate';
const SHAPE_ROTATION_UNIFORM = 'power2d_shapeRotation';
const SHAPE_SCALE_UNIFORM = 'power2d_shapeScale';

interface UniformField {
  name: string;
  bindingName: string;
  glslType: string;
}

interface UniformTypeMetadata {
  tsType: string;
  setter: string;
  expression: (valueRef: string) => string;
  helper?: string;
  defaultValue: string;
}

interface TextureParam {
  textureName: string;
}

interface InstanceField {
  name: string;
  glslType: string;
  tsType: string;
  attributeType: string;
  floatCount: number;
}

interface InstanceLayout {
  fields: InstanceField[];
  totalFloats: number;
}

const UNIFORM_TYPE_MAP: Record<string, UniformTypeMetadata> = {
  float: {
    tsType: 'number',
    setter: 'setFloat',
    expression: (valueRef) => valueRef,
    defaultValue: '0',
  },
  int: {
    tsType: 'number',
    setter: 'setInt',
    expression: (valueRef) => valueRef,
    defaultValue: '0',
  },
  uint: {
    tsType: 'number',
    setter: 'setUInt',
    expression: (valueRef) => valueRef,
    defaultValue: '0',
  },
  bool: {
    tsType: 'boolean',
    setter: 'setFloat',
    expression: (valueRef) => `(${valueRef} ? 1 : 0)`,
    defaultValue: 'false',
  },
  vec2: {
    tsType: 'BABYLON.Vector2 | readonly [number, number]',
    setter: 'setVector2',
    expression: (valueRef) => `ensureVector2(${valueRef})`,
    helper: 'ensureVector2',
    defaultValue: '[0, 0]',
  },
  vec3: {
    tsType: 'BABYLON.Vector3 | readonly [number, number, number]',
    setter: 'setVector3',
    expression: (valueRef) => `ensureVector3(${valueRef})`,
    helper: 'ensureVector3',
    defaultValue: '[0, 0, 0]',
  },
  vec4: {
    tsType: 'BABYLON.Vector4 | readonly [number, number, number, number]',
    setter: 'setVector4',
    expression: (valueRef) => `ensureVector4(${valueRef})`,
    helper: 'ensureVector4',
    defaultValue: '[0, 0, 0, 0]',
  },
  mat4: {
    tsType: 'BABYLON.Matrix | Float32Array | readonly number[]',
    setter: 'setMatrix',
    expression: (valueRef) => `ensureMatrix(${valueRef})`,
    helper: 'ensureMatrix',
    defaultValue: 'new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])',
  },
};

const INSTANCE_TYPE_MAP: Record<string, { tsType: string; attributeType: string; floatCount: number }> = {
  float: { tsType: 'number', attributeType: 'float', floatCount: 1 },
  vec2: { tsType: 'readonly [number, number]', attributeType: 'vec2', floatCount: 2 },
  vec3: { tsType: 'readonly [number, number, number]', attributeType: 'vec3', floatCount: 3 },
  vec4: { tsType: 'readonly [number, number, number, number]', attributeType: 'vec4', floatCount: 4 },
};

const HELPER_SNIPPETS: Record<string, string> = {
  ensureVector2: `function ensureVector2(value: BABYLON.Vector2 | readonly [number, number]): BABYLON.Vector2 {\n  return value instanceof BABYLON.Vector2 ? value : BABYLON.Vector2.FromArray(value as readonly [number, number]);\n}`,
  ensureVector3: `function ensureVector3(value: BABYLON.Vector3 | readonly [number, number, number]): BABYLON.Vector3 {\n  return value instanceof BABYLON.Vector3 ? value : BABYLON.Vector3.FromArray(value as readonly [number, number, number]);\n}`,
  ensureVector4: `function ensureVector4(value: BABYLON.Vector4 | readonly [number, number, number, number]): BABYLON.Vector4 {\n  return value instanceof BABYLON.Vector4 ? value : BABYLON.Vector4.FromArray(value as readonly [number, number, number, number]);\n}`,
  ensureMatrix: `function ensureMatrix(value: BABYLON.Matrix | Float32Array | readonly number[]): BABYLON.Matrix {\n  if (value instanceof BABYLON.Matrix) {\n    return value;\n  }\n  const matrix = BABYLON.Matrix.Identity();\n  matrix.copyFromArray(Array.from(value));\n  return matrix;\n}`,
};

function toPascalCase(value: string): string {
  return value
    .replace(/[-_]/g, ' ')
    .split(' ')
    .filter(Boolean)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
}

function escapeTemplateLiteral(value: string): string {
  return `\`${value
    .replace(/\\/g, '\\\\')
    .replace(/`/g, '\\`')
    .replace(/\$\{/g, '\\${')}\``;
}

async function writeFileIfChanged(filePath: string, content: string): Promise<boolean> {
  let existing: string | null = null;
  try {
    existing = await fs.readFile(filePath, 'utf8');
  } catch (error: any) {
    if (error?.code !== 'ENOENT') {
      throw error;
    }
  }
  if (existing === content) {
    return false;
  }
  await fs.mkdir(path.dirname(filePath), { recursive: true });
  await fs.writeFile(filePath, content, 'utf8');
  return true;
}

function validateType(argument: GlslArgument, expected: string, label: string): void {
  const typeName = argument.type;
  if (typeName !== expected) {
    throw new Error(`${label} must be ${expected}. Received ${argument.name}: ${typeName}`);
  }
}

function collectUniformFields(struct: GlslStruct, uniformArgName: string): UniformField[] {
  return struct.members.map((member) => {
    const typeName = member.type;
    if (!UNIFORM_TYPE_MAP[typeName]) {
      throw new Error(`Uniform field ${member.name} uses unsupported type ${typeName}.`);
    }
    return {
      name: member.name,
      bindingName: `${uniformArgName}_${member.name}`,
      glslType: typeName,
    };
  });
}

function collectInstanceLayout(struct: GlslStruct): InstanceLayout {
  const fields: InstanceField[] = [];
  let offset = 0;
  for (const member of struct.members) {
    const typeName = member.type;
    const meta = INSTANCE_TYPE_MAP[typeName];
    if (!meta) {
      throw new Error(`Instance field ${member.name} uses unsupported type ${typeName}.`);
    }
    fields.push({
      name: member.name,
      glslType: typeName,
      tsType: meta.tsType,
      attributeType: meta.attributeType,
      floatCount: meta.floatCount,
    });
    offset += meta.floatCount;
  }
  return { fields, totalFloats: offset };
}

function parseTextureParams(args: GlslArgument[], startIndex: number, functionName: string): TextureParam[] {
  const params: TextureParam[] = [];
  const seenTextures = new Set<string>();

  for (let index = startIndex; index < args.length; index += 1) {
    const textureArg = args[index];
    if (!textureArg) {
      continue;
    }
    const textureType = textureArg.type;
    if (textureType !== 'sampler2D') {
      throw new Error(`Texture argument must be sampler2D. Received ${textureArg.name}: ${textureType}`);
    }
    if (seenTextures.has(textureArg.name)) {
      throw new Error(`Duplicate texture parameter ${textureArg.name} detected.`);
    }
    seenTextures.add(textureArg.name);

    params.push({
      textureName: textureArg.name,
    });
  }

  return params;
}

function generateUniformStructConstruction(struct: GlslStruct, fields: UniformField[]): string {
  if (fields.length === 0) {
    return `  return ${struct.name}();`;
  }
  const args = fields.map((field) => `    ${field.bindingName}`).join(',\n');
  return `  return ${struct.name}(\n${args}\n  );`;
}

function generateInstanceStructConstruction(struct: GlslStruct, sourcePrefix: string): string {
  if (struct.members.length === 0) {
    return `  return ${struct.name}();`;
  }
  const args = struct.members.map((member) => `    ${sourcePrefix}${member.name}`).join(',\n');
  return `  return ${struct.name}(\n${args}\n  );`;
}

function glslTypeName(type: string): string {
  return type;
}

function buildUniformDeclarations(fields: UniformField[]): string[] {
  return fields.map((field) => `uniform ${glslTypeName(field.glslType)} ${field.bindingName};`);
}

function buildInstanceAttributeDeclarations(layout: InstanceLayout | null): string[] {
  if (!layout) return [];
  return layout.fields.map((field) => `in ${glslTypeName(field.glslType)} inst_${field.name};`);
}

function buildInstanceVaryingDeclarations(layout: InstanceLayout | null, qualifier: 'in' | 'out'): string[] {
  if (!layout) return [];
  return layout.fields.map((field) => `${qualifier} ${glslTypeName(field.glslType)} vInst_${field.name};`);
}

export async function generateMaterialTypes_GL(filePath: string, options: GenerateMaterialTypesOptions): Promise<GenerateMaterialTypesResult> {
  const projectRoot = options.projectRoot;
  const logger = options.logger;

  const absoluteSource = path.resolve(filePath);
  if (!absoluteSource.endsWith(RAW_SUFFIX)) {
    throw new Error(`Expected a ${RAW_SUFFIX} file, got ${filePath}`);
  }

  const basePath = absoluteSource.slice(0, -RAW_SUFFIX.length);
  const outputPath = `${basePath}${OUTPUT_SUFFIX}`;

  const sourceText = await fs.readFile(absoluteSource, 'utf8');
  const structs = parseStructs(sourceText);
  const functions = parseFunctions(sourceText);
  const structMap = new Map(structs.map((entry) => [entry.name, entry]));

  const vertFn = functions.find((fn) => fn.name === 'vertShader');
  const fragFn = functions.find((fn) => fn.name === 'fragShader');

  if (!vertFn) {
    throw new Error('Missing vertShader function.');
  }
  if (!fragFn) {
    throw new Error('Missing fragShader function.');
  }

  if (vertFn.returnType !== 'vec2') {
    throw new Error(`vertShader must return vec2. Received ${vertFn.returnType}.`);
  }
  if (vertFn.args.length !== 3 && vertFn.args.length !== 4) {
    throw new Error('vertShader must declare 3 arguments (position, uv, uniforms) or 4 arguments (position, uv, uniforms, instance).');
  }

  validateType(vertFn.args[0], 'vec2', 'vertShader position argument');
  validateType(vertFn.args[1], 'vec2', 'vertShader uv argument');

  const uniformStruct = structMap.get(vertFn.args[2].type);
  if (!uniformStruct) {
    throw new Error(`vertShader uniforms must use a struct type. Received ${vertFn.args[2].type}.`);
  }

  let instanceStruct: GlslStruct | null = null;
  if (vertFn.args.length === 4) {
    instanceStruct = structMap.get(vertFn.args[3].type) ?? null;
    if (!instanceStruct) {
      throw new Error(`vertShader instance must use a struct type. Received ${vertFn.args[3].type}.`);
    }
  }

  if (fragFn.returnType !== 'vec4') {
    throw new Error(`fragShader must return vec4. Received ${fragFn.returnType}.`);
  }
  if (fragFn.args.length < 2) {
    throw new Error('fragShader must declare at least 2 arguments (uv, uniforms).');
  }
  validateType(fragFn.args[0], 'vec2', 'fragShader uv argument');
  if (fragFn.args[1].type !== uniformStruct.name) {
    throw new Error(`fragShader uniforms must use struct ${uniformStruct.name}.`);
  }
  if (instanceStruct) {
    if (fragFn.args.length < 3) {
      throw new Error('fragShader must declare instance argument when vertShader does.');
    }
    if (fragFn.args[2].type !== instanceStruct.name) {
      throw new Error(`fragShader instance must use struct ${instanceStruct.name}.`);
    }
  }

  const resourceStartIndex = instanceStruct ? 3 : 2;
  const textureParams = parseTextureParams(fragFn.args, resourceStartIndex, 'fragShader');

  const uniformFields = collectUniformFields(uniformStruct, 'uniforms');
  const instanceLayout = instanceStruct ? collectInstanceLayout(instanceStruct) : null;

  const shaderPrefix = toPascalCase(path.basename(basePath));
  const vertexSourceLines: string[] = [];
  vertexSourceLines.push(`${HEADER_COMMENT}`);
  vertexSourceLines.push('#version 300 es');
  vertexSourceLines.push('precision highp float;');
  vertexSourceLines.push('');
  vertexSourceLines.push('in vec3 position;');
  vertexSourceLines.push('in vec2 uv;');
  vertexSourceLines.push(...buildInstanceAttributeDeclarations(instanceLayout));
  vertexSourceLines.push('out vec2 vUV;');
  vertexSourceLines.push(...buildInstanceVaryingDeclarations(instanceLayout, 'out'));
  vertexSourceLines.push(...buildUniformDeclarations(uniformFields));
  vertexSourceLines.push(`uniform vec2 ${SHAPE_TRANSLATE_UNIFORM};`);
  vertexSourceLines.push(`uniform float ${SHAPE_ROTATION_UNIFORM};`);
  vertexSourceLines.push(`uniform vec2 ${SHAPE_SCALE_UNIFORM};`);
  vertexSourceLines.push('uniform float power2d_canvasWidth;');
  vertexSourceLines.push('uniform float power2d_canvasHeight;');
  vertexSourceLines.push('');
  vertexSourceLines.push(sourceText.trim());
  vertexSourceLines.push('');
  vertexSourceLines.push(`// Uniform helpers`);
  vertexSourceLines.push(`
${uniformStruct.name} load_${uniformStruct.name}() {`);
  vertexSourceLines.push(generateUniformStructConstruction(uniformStruct, uniformFields));
  vertexSourceLines.push('}');
  if (instanceStruct) {
    vertexSourceLines.push(`
${instanceStruct.name} load_${instanceStruct.name}_vertex() {`);
    vertexSourceLines.push(generateInstanceStructConstruction(instanceStruct, 'inst_'));
    vertexSourceLines.push('}');
  }
  vertexSourceLines.push(`
vec2 power2d_applyShapeTransform(vec2 pixel) {`);
  vertexSourceLines.push(`  vec2 scaled = pixel * ${SHAPE_SCALE_UNIFORM};`);
  vertexSourceLines.push(`  float s = sin(${SHAPE_ROTATION_UNIFORM});`);
  vertexSourceLines.push(`  float c = cos(${SHAPE_ROTATION_UNIFORM});`);
  vertexSourceLines.push('  vec2 rotated = vec2(');
  vertexSourceLines.push('    scaled.x * c - scaled.y * s,');
  vertexSourceLines.push('    scaled.x * s + scaled.y * c');
  vertexSourceLines.push('  );');
  vertexSourceLines.push(`  return rotated + ${SHAPE_TRANSLATE_UNIFORM};`);
  vertexSourceLines.push('}');
  vertexSourceLines.push('');
  vertexSourceLines.push('vec4 power2d_pixelToNDC(vec2 pixel) {');
  vertexSourceLines.push('  float ndcX = (pixel.x / power2d_canvasWidth) * 2.0 - 1.0;');
  vertexSourceLines.push('  float ndcY = -((pixel.y / power2d_canvasHeight) * 2.0 - 1.0);');
  vertexSourceLines.push('  return vec4(ndcX, ndcY, 0.0, 1.0);');
  vertexSourceLines.push('}');
  vertexSourceLines.push('');
  vertexSourceLines.push('void main() {');
  vertexSourceLines.push(`  ${uniformStruct.name} uniformsValue = load_${uniformStruct.name}();`);
  if (instanceStruct) {
    vertexSourceLines.push(`  ${instanceStruct.name} instValue = load_${instanceStruct.name}_vertex();`);
  }
  vertexSourceLines.push('  vec2 pixelPos = vec2(position.x, position.y);');
  vertexSourceLines.push('  vec2 uvLocal = uv;');
  const vertArgs = ['pixelPos', 'uvLocal', 'uniformsValue'];
  if (instanceStruct) {
    vertArgs.push('instValue');
  }
  vertexSourceLines.push(`  vec2 adjustedPixelPos = vertShader(${vertArgs.join(', ')});`);
  vertexSourceLines.push('  vec2 transformedPixelPos = power2d_applyShapeTransform(adjustedPixelPos);');
  vertexSourceLines.push('  gl_Position = power2d_pixelToNDC(transformedPixelPos);');
  vertexSourceLines.push('  vUV = uvLocal;');
  if (instanceStruct) {
    for (const field of instanceLayout!.fields) {
      vertexSourceLines.push(`  vInst_${field.name} = inst_${field.name};`);
    }
  }
  vertexSourceLines.push('}');

  const fragmentSourceLines: string[] = [];
  fragmentSourceLines.push(`${HEADER_COMMENT}`);
  fragmentSourceLines.push('#version 300 es');
  fragmentSourceLines.push('precision highp float;');
  fragmentSourceLines.push('');
  fragmentSourceLines.push('in vec2 vUV;');
  fragmentSourceLines.push(...buildInstanceVaryingDeclarations(instanceLayout, 'in'));
  fragmentSourceLines.push('out vec4 outColor;');
  fragmentSourceLines.push(...buildUniformDeclarations(uniformFields));
  fragmentSourceLines.push(`uniform vec2 ${SHAPE_TRANSLATE_UNIFORM};`);
  fragmentSourceLines.push(`uniform float ${SHAPE_ROTATION_UNIFORM};`);
  fragmentSourceLines.push(`uniform vec2 ${SHAPE_SCALE_UNIFORM};`);
  fragmentSourceLines.push('uniform float power2d_canvasWidth;');
  fragmentSourceLines.push('uniform float power2d_canvasHeight;');
  if (textureParams.length > 0) {
    for (const texture of textureParams) {
      fragmentSourceLines.push(`uniform sampler2D ${texture.textureName};`);
    }
  }
  fragmentSourceLines.push('');
  fragmentSourceLines.push(sourceText.trim());
  fragmentSourceLines.push('');
  fragmentSourceLines.push(`
${uniformStruct.name} load_${uniformStruct.name}() {`);
  fragmentSourceLines.push(generateUniformStructConstruction(uniformStruct, uniformFields));
  fragmentSourceLines.push('}');
  if (instanceStruct) {
    fragmentSourceLines.push(`
${instanceStruct.name} load_${instanceStruct.name}_fragment() {`);
    fragmentSourceLines.push(generateInstanceStructConstruction(instanceStruct, 'vInst_'));
    fragmentSourceLines.push('}');
  }
  fragmentSourceLines.push('');
  fragmentSourceLines.push('void main() {');
  fragmentSourceLines.push('  vec2 uvLocal = vUV;');
  fragmentSourceLines.push(`  ${uniformStruct.name} uniformsValue = load_${uniformStruct.name}();`);
  if (instanceStruct) {
    fragmentSourceLines.push(`  ${instanceStruct.name} instValue = load_${instanceStruct.name}_fragment();`);
  }
  const fragArgs = ['uvLocal', 'uniformsValue'];
  if (instanceStruct) {
    fragArgs.push('instValue');
  }
  for (const texture of textureParams) {
    fragArgs.push(texture.textureName);
  }
  fragmentSourceLines.push(`  vec4 color = fragShader(${fragArgs.join(', ')});`);
  fragmentSourceLines.push('  outColor = color;');
  fragmentSourceLines.push('}');

  const vertexSource = vertexSourceLines.join('\n');
  const fragmentSource = fragmentSourceLines.join('\n');

  const uniformInterfaceName = `${shaderPrefix}Uniforms`;
  const uniformMetaName = `${shaderPrefix}UniformMeta`;
  const uniformDefaultsName = `${shaderPrefix}UniformDefaults`;
  const setUniformsName = `set${shaderPrefix}Uniforms`;
  const textureNameType = `${shaderPrefix}TextureName`;
  const textureNamesConst = `${shaderPrefix}TextureNames`;
  const materialInstanceName = `${shaderPrefix}MaterialInstance`;
  const materialDefName = `${shaderPrefix}MaterialDef`;
  const createMaterialName = `create${shaderPrefix}Material`;

  const tsLines: string[] = [];
  tsLines.push(HEADER_COMMENT);
  tsLines.push("import * as BABYLON from 'babylonjs';");
  tsLines.push('');
  tsLines.push(`export const ${shaderPrefix}VertexSource = ${escapeTemplateLiteral(vertexSource)};`);
  tsLines.push(`export const ${shaderPrefix}FragmentSource = ${escapeTemplateLiteral(fragmentSource)};`);
  tsLines.push('');

  const helperNames = new Set<string>();
  for (const field of uniformFields) {
    const meta = UNIFORM_TYPE_MAP[field.glslType];
    if (meta?.helper) {
      helperNames.add(meta.helper);
    }
  }

  for (const helperName of helperNames) {
    const snippet = HELPER_SNIPPETS[helperName];
    if (snippet) {
      tsLines.push(snippet);
      tsLines.push('');
    }
  }

  tsLines.push(`export interface ${uniformInterfaceName} {`);
  for (const field of uniformFields) {
    const meta = UNIFORM_TYPE_MAP[field.glslType];
    tsLines.push(`  ${field.name}: ${meta.tsType};`);
  }
  tsLines.push('}');
  tsLines.push('');

  tsLines.push(`export const ${uniformDefaultsName}: ${uniformInterfaceName} = {`);
  for (const field of uniformFields) {
    const meta = UNIFORM_TYPE_MAP[field.glslType];
    tsLines.push(`  ${field.name}: ${meta.defaultValue},`);
  }
  tsLines.push('};');
  tsLines.push('');

  tsLines.push(`export const ${uniformMetaName} = [`);
  for (const field of uniformFields) {
    const typeKey = field.glslType;
    const kindMap: Record<string, string> = {
      float: 'f32',
      int: 'i32',
      uint: 'u32',
      bool: 'bool',
      vec2: 'vec2f',
      vec3: 'vec3f',
      vec4: 'vec4f',
      mat4: 'mat4x4f',
    };
    tsLines.push('  {');
    tsLines.push(`    name: '${field.name}',`);
    tsLines.push(`    kind: '${kindMap[typeKey]}',`);
    tsLines.push(`    bindingName: '${field.bindingName}',`);
    tsLines.push('  },');
  }
  tsLines.push(`] as const;`);
  tsLines.push('');

  tsLines.push(`export function ${setUniformsName}(material: BABYLON.ShaderMaterial, uniforms: Partial<${uniformInterfaceName}>): void {`);
  tsLines.push('  if (!uniforms) {');
  tsLines.push('    return;');
  tsLines.push('  }');
  for (const field of uniformFields) {
    const meta = UNIFORM_TYPE_MAP[field.glslType];
    tsLines.push(`  if (uniforms.${field.name} !== undefined) {`);
    tsLines.push(`    material.${meta.setter}('${field.bindingName}', ${meta.expression(`uniforms.${field.name}`)});`);
    tsLines.push('  }');
  }
  tsLines.push('}');
  tsLines.push('');

  if (textureParams.length === 0) {
    tsLines.push(`export type ${textureNameType} = never;`);
    tsLines.push(`export const ${textureNamesConst} = [] as const;`);
  } else {
    const textureNameUnion = textureParams.map((param) => `'${param.textureName}'`).join(' | ');
    tsLines.push(`export type ${textureNameType} = ${textureNameUnion};`);
    tsLines.push(`export const ${textureNamesConst} = [${textureParams.map((param) => `'${param.textureName}'`).join(', ')}] as const;`);
  }
  tsLines.push('');

  if (instanceLayout) {
    const instanceInterfaceName = `${shaderPrefix}Instance`;
    tsLines.push(`export interface ${instanceInterfaceName} {`);
    for (const field of instanceLayout.fields) {
      tsLines.push(`  ${field.name}: ${field.tsType};`);
    }
    tsLines.push('}');
    tsLines.push('');

    tsLines.push('export interface InstanceAttrLayout<I> {');
    tsLines.push('  size: number;');
    tsLines.push('  members: Array<{');
    tsLines.push('    name: keyof I;');
    tsLines.push('    offset: number;');
    tsLines.push('    floatCount: number;');
    tsLines.push('  }>');
    tsLines.push('}');
    tsLines.push('');

    tsLines.push(`export const ${shaderPrefix}InstanceAttrLayout: InstanceAttrLayout<${instanceInterfaceName}> = {`);
    tsLines.push(`  size: ${instanceLayout.totalFloats},`);
    tsLines.push('  members: [');
    let offset = 0;
    for (const field of instanceLayout.fields) {
      tsLines.push(`    { name: '${field.name}', offset: ${offset}, floatCount: ${field.floatCount} },`);
      offset += field.floatCount;
    }
    tsLines.push('  ],');
    tsLines.push('};');
    tsLines.push('');
  }

  tsLines.push(`export interface ${materialDefName} {`);
  tsLines.push(`  readonly uniformType: ${uniformInterfaceName};`);
  tsLines.push(`  readonly textureNames: readonly ${textureNameType}[];`);
  tsLines.push(`  readonly vertexSource: string;`);
  tsLines.push(`  readonly fragmentSource: string;`);
  tsLines.push(`  readonly uniformMeta: typeof ${uniformMetaName};`);
  tsLines.push(`  readonly uniformDefaults: ${uniformInterfaceName};`);
  if (instanceLayout) {
    tsLines.push(`  readonly instanceAttrLayout: InstanceAttrLayout<${shaderPrefix}Instance>;`);
  }
  tsLines.push(`  readonly createMaterial: (scene: BABYLON.Scene, name?: string) => ${materialInstanceName};`);
  tsLines.push('}');
  tsLines.push('');

  tsLines.push(`export interface ${materialInstanceName} {`);
  tsLines.push('  material: BABYLON.ShaderMaterial;');
  tsLines.push(`  setUniforms(uniforms: Partial<${uniformInterfaceName}>): void;`);
  tsLines.push(`  setTexture(name: ${textureNameType}, texture: BABYLON.BaseTexture): void;`);
  if (textureParams.length > 0) {
    tsLines.push(`  setTextureSampler(name: ${textureNameType}, sampler: BABYLON.TextureSampler): void;`);
  }
  tsLines.push('  setCanvasSize(width: number, height: number): void;');
  tsLines.push('  dispose(): void;');
  tsLines.push('}');
  tsLines.push('');

  tsLines.push(`export function ${createMaterialName}(scene: BABYLON.Scene, name: string = '${shaderPrefix}Material'): ${materialInstanceName} {`);
  tsLines.push('  const vertexShaderName = `${name}VertexShader`;');
  tsLines.push('  const fragmentShaderName = `${name}FragmentShader`;');
  tsLines.push('');
  tsLines.push(`  BABYLON.ShaderStore.ShadersStore[vertexShaderName] = ${shaderPrefix}VertexSource;`);
  tsLines.push(`  BABYLON.ShaderStore.ShadersStore[fragmentShaderName] = ${shaderPrefix}FragmentSource;`);
  tsLines.push('');
  const attributeNames = ['position', 'uv'];
  if (instanceLayout) {
    for (const field of instanceLayout.fields) {
      attributeNames.push(`inst_${field.name}`);
    }
  }
  const uniformNames = uniformFields.map((field) => field.bindingName);
  uniformNames.push(SHAPE_TRANSLATE_UNIFORM, SHAPE_ROTATION_UNIFORM, SHAPE_SCALE_UNIFORM, 'power2d_canvasWidth', 'power2d_canvasHeight');
  const samplerNames = textureParams.map((param) => param.textureName);

  tsLines.push(`  const material = new BABYLON.ShaderMaterial(name, scene, {`);
  tsLines.push('    vertex: name,');
  tsLines.push('    fragment: name,');
  tsLines.push('  }, {');
  tsLines.push(`    attributes: ${JSON.stringify(attributeNames)},`);
  tsLines.push(`    uniforms: ${JSON.stringify(uniformNames)},`);
  tsLines.push(`    samplers: ${JSON.stringify(samplerNames)},`);
  tsLines.push('    shaderLanguage: BABYLON.ShaderLanguage.GLSL,');
  tsLines.push('  });');
  tsLines.push('');

  if (textureParams.length > 0) {
    tsLines.push('  const defaultSampler = new BABYLON.TextureSampler();');
    tsLines.push('  defaultSampler.setParameters(');
    tsLines.push('    BABYLON.Texture.CLAMP_ADDRESSMODE,');
    tsLines.push('    BABYLON.Texture.CLAMP_ADDRESSMODE,');
    tsLines.push('    BABYLON.Texture.CLAMP_ADDRESSMODE,');
    tsLines.push('    undefined,');
    tsLines.push('    BABYLON.Texture.BILINEAR_SAMPLINGMODE,');
    tsLines.push('  );');
    tsLines.push('  const samplerState: Record<string, BABYLON.TextureSampler> = {};');
    tsLines.push('  const applySamplerToTexture = (texture: BABYLON.BaseTexture | null, sampler: BABYLON.TextureSampler) => {');
    tsLines.push('    if (!texture) return;');
    tsLines.push('    texture.wrapU = sampler.wrapU;');
    tsLines.push('    texture.wrapV = sampler.wrapV;');
    tsLines.push('    if ((sampler as any).wrapR !== undefined) {');
    tsLines.push('      texture.wrapR = (sampler as any).wrapR;');
    tsLines.push('    }');
    tsLines.push('    texture.updateSamplingMode(sampler.samplingMode);');
    tsLines.push('  };');
  }

  tsLines.push(`  ${setUniformsName}(material, ${uniformDefaultsName});`);
  tsLines.push(`  material.setVector2('${SHAPE_TRANSLATE_UNIFORM}', new BABYLON.Vector2(0, 0));`);
  tsLines.push(`  material.setFloat('${SHAPE_ROTATION_UNIFORM}', 0);`);
  tsLines.push(`  material.setVector2('${SHAPE_SCALE_UNIFORM}', new BABYLON.Vector2(1, 1));`);
  tsLines.push('  material.disableDepthWrite = true;');
  tsLines.push('  material.depthFunction = BABYLON.Constants.ALWAYS;');
  tsLines.push('  material.backFaceCulling = false;');
  tsLines.push('  material.alphaMode = BABYLON.Engine.ALPHA_COMBINE;');
  tsLines.push('');

  tsLines.push(`  const handles: ${materialInstanceName} = {`);
  tsLines.push('    material,');
  tsLines.push(`    setUniforms: (uniforms) => ${setUniformsName}(material, uniforms),`);
  if (textureParams.length > 0) {
    tsLines.push('    setTexture: (name, texture) => {');
    tsLines.push('      material.setTexture(name, texture);');
    tsLines.push('      const sampler = samplerState[name] ?? defaultSampler;');
    tsLines.push('      applySamplerToTexture(texture, sampler);');
    tsLines.push('    },');
    tsLines.push('    setTextureSampler: (name, sampler) => {');
    tsLines.push('      samplerState[name] = sampler;');
    tsLines.push('      const texture = material.getTexture(name);');
    tsLines.push('      applySamplerToTexture(texture, sampler);');
    tsLines.push('    },');
  } else {
    tsLines.push('    setTexture: (name, texture) => material.setTexture(name, texture),');
  }
  tsLines.push('    setCanvasSize: (width, height) => {');
  tsLines.push("      material.setFloat('power2d_canvasWidth', width);");
  tsLines.push("      material.setFloat('power2d_canvasHeight', height);");
  tsLines.push('    },');
  tsLines.push('    dispose: () => {');
  tsLines.push('      material.dispose(true, false);');
  tsLines.push('      delete BABYLON.ShaderStore.ShadersStore[vertexShaderName];');
  tsLines.push('      delete BABYLON.ShaderStore.ShadersStore[fragmentShaderName];');
  tsLines.push('    },');
  tsLines.push('  };');
  tsLines.push('');
  tsLines.push('  return handles;');
  tsLines.push('}');
  tsLines.push('');

  tsLines.push(`export const ${shaderPrefix}Material: ${materialDefName} = {`);
  tsLines.push(`  uniformType: undefined as unknown as ${uniformInterfaceName},`);
  tsLines.push(`  textureNames: ${textureNamesConst},`);
  tsLines.push(`  vertexSource: ${shaderPrefix}VertexSource,`);
  tsLines.push(`  fragmentSource: ${shaderPrefix}FragmentSource,`);
  tsLines.push(`  uniformMeta: ${uniformMetaName},`);
  tsLines.push(`  uniformDefaults: ${uniformDefaultsName},`);
  if (instanceLayout) {
    tsLines.push(`  instanceAttrLayout: ${shaderPrefix}InstanceAttrLayout,`);
  }
  tsLines.push(`  createMaterial: ${createMaterialName},`);
  tsLines.push('};');
  tsLines.push('');
  tsLines.push(`export default ${shaderPrefix}Material;`);

  const typesSource = tsLines.join('\n');
  const updated = await writeFileIfChanged(outputPath, typesSource);

  if (updated && logger) {
    const relative = path.relative(projectRoot, outputPath);
    logger(`Generated ${relative}`);
  }

  return {
    sourcePath: absoluteSource,
    outputPath,
    updated,
  };
}
