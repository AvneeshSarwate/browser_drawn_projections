import { promises as fs } from 'node:fs';
import * as path from 'node:path';
import { parseFunctions, parseStructs, type GlslArgument, type GlslStruct } from './parseGlsl';

type Logger = (message: string) => void;

export interface GenerateStrokeMaterialTypesOptions {
  projectRoot: string;
  logger?: Logger;
}

export interface GenerateStrokeMaterialTypesResult {
  sourcePath: string;
  outputPath: string;
  updated: boolean;
}

const RAW_SUFFIX = '.strokeMaterial.glsl';
const OUTPUT_SUFFIX = '.strokeMaterial.gl.generated.ts';
const HEADER_COMMENT = '// Auto-generated by power2d glsl stroke material generator. DO NOT EDIT.';
const SHAPE_TRANSLATE_UNIFORM = 'power2d_shapeTranslate';
const SHAPE_ROTATION_UNIFORM = 'power2d_shapeRotation';
const SHAPE_SCALE_UNIFORM = 'power2d_shapeScale';

interface UniformField {
  name: string;
  bindingName: string;
  glslType: string;
}

interface UniformTypeMetadata {
  tsType: string;
  setter: string;
  expression: (valueRef: string) => string;
  helper?: string;
  defaultValue: string;
}

interface TextureParam {
  textureName: string;
}

const UNIFORM_TYPE_MAP: Record<string, UniformTypeMetadata> = {
  float: {
    tsType: 'number',
    setter: 'setFloat',
    expression: (valueRef) => valueRef,
    defaultValue: '0',
  },
  int: {
    tsType: 'number',
    setter: 'setInt',
    expression: (valueRef) => valueRef,
    defaultValue: '0',
  },
  uint: {
    tsType: 'number',
    setter: 'setUInt',
    expression: (valueRef) => valueRef,
    defaultValue: '0',
  },
  bool: {
    tsType: 'boolean',
    setter: 'setFloat',
    expression: (valueRef) => `(${valueRef} ? 1 : 0)`,
    defaultValue: 'false',
  },
  vec2: {
    tsType: 'BABYLON.Vector2 | readonly [number, number]',
    setter: 'setVector2',
    expression: (valueRef) => `ensureVector2(${valueRef})`,
    helper: 'ensureVector2',
    defaultValue: '[0, 0]',
  },
  vec3: {
    tsType: 'BABYLON.Vector3 | readonly [number, number, number]',
    setter: 'setVector3',
    expression: (valueRef) => `ensureVector3(${valueRef})`,
    helper: 'ensureVector3',
    defaultValue: '[0, 0, 0]',
  },
  vec4: {
    tsType: 'BABYLON.Vector4 | readonly [number, number, number, number]',
    setter: 'setVector4',
    expression: (valueRef) => `ensureVector4(${valueRef})`,
    helper: 'ensureVector4',
    defaultValue: '[0, 0, 0, 0]',
  },
  mat4: {
    tsType: 'BABYLON.Matrix | Float32Array | readonly number[]',
    setter: 'setMatrix',
    expression: (valueRef) => `ensureMatrix(${valueRef})`,
    helper: 'ensureMatrix',
    defaultValue: 'new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])',
  },
};

const HELPER_SNIPPETS: Record<string, string> = {
  ensureVector2: `function ensureVector2(value: BABYLON.Vector2 | readonly [number, number]): BABYLON.Vector2 {\n  return value instanceof BABYLON.Vector2 ? value : BABYLON.Vector2.FromArray(value as readonly [number, number]);\n}`,
  ensureVector3: `function ensureVector3(value: BABYLON.Vector3 | readonly [number, number, number]): BABYLON.Vector3 {\n  return value instanceof BABYLON.Vector3 ? value : BABYLON.Vector3.FromArray(value as readonly [number, number, number]);\n}`,
  ensureVector4: `function ensureVector4(value: BABYLON.Vector4 | readonly [number, number, number, number]): BABYLON.Vector4 {\n  return value instanceof BABYLON.Vector4 ? value : BABYLON.Vector4.FromArray(value as readonly [number, number, number, number]);\n}`,
  ensureMatrix: `function ensureMatrix(value: BABYLON.Matrix | Float32Array | readonly number[]): BABYLON.Matrix {\n  if (value instanceof BABYLON.Matrix) {\n    return value;\n  }\n  const matrix = BABYLON.Matrix.Identity();\n  matrix.copyFromArray(Array.from(value));\n  return matrix;\n}`,
};

function toPascalCase(value: string): string {
  return value
    .replace(/[-_]/g, ' ')
    .split(' ')
    .filter(Boolean)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
}

function escapeTemplateLiteral(value: string): string {
  return `\`${value
    .replace(/\\/g, '\\\\')
    .replace(/`/g, '\\`')
    .replace(/\$\{/g, '\\${')}\``;
}

async function writeFileIfChanged(filePath: string, content: string): Promise<boolean> {
  let existing: string | null = null;
  try {
    existing = await fs.readFile(filePath, 'utf8');
  } catch (error: any) {
    if (error?.code !== 'ENOENT') {
      throw error;
    }
  }
  if (existing === content) {
    return false;
  }
  await fs.mkdir(path.dirname(filePath), { recursive: true });
  await fs.writeFile(filePath, content, 'utf8');
  return true;
}

function validateType(argument: GlslArgument, expected: string, label: string): void {
  const typeName = argument.type;
  if (typeName !== expected) {
    throw new Error(`${label} must be ${expected}. Received ${argument.name}: ${typeName}`);
  }
}

function collectUniformFields(struct: GlslStruct, uniformArgName: string): UniformField[] {
  return struct.members.map((member) => {
    const typeName = member.type;
    if (!UNIFORM_TYPE_MAP[typeName]) {
      throw new Error(`Uniform field ${member.name} uses unsupported type ${typeName}.`);
    }
    return {
      name: member.name,
      bindingName: `${uniformArgName}_${member.name}`,
      glslType: typeName,
    };
  });
}

function parseTextureParams(args: GlslArgument[], startIndex: number, functionName: string): TextureParam[] {
  const params: TextureParam[] = [];
  const seenTextures = new Set<string>();

  for (let index = startIndex; index < args.length; index += 1) {
    const textureArg = args[index];
    if (!textureArg) {
      continue;
    }
    const textureType = textureArg.type;
    if (textureType !== 'sampler2D') {
      throw new Error(`Texture argument must be sampler2D. Received ${textureArg.name}: ${textureType}`);
    }
    if (seenTextures.has(textureArg.name)) {
      throw new Error(`Duplicate texture parameter ${textureArg.name} detected.`);
    }
    seenTextures.add(textureArg.name);

    params.push({
      textureName: textureArg.name,
    });
  }

  return params;
}

function generateUniformStructConstruction(struct: GlslStruct, fields: UniformField[]): string {
  if (fields.length === 0) {
    return `  return ${struct.name}();`;
  }
  const args = fields.map((field) => `    ${field.bindingName}`).join(',\n');
  return `  return ${struct.name}(\n${args}\n  );`;
}

function buildUniformDeclarations(fields: UniformField[]): string[] {
  return fields.map((field) => `uniform ${field.glslType} ${field.bindingName};`);
}

export async function generateStrokeMaterialTypes_GL(filePath: string, options: GenerateStrokeMaterialTypesOptions): Promise<GenerateStrokeMaterialTypesResult> {
  const projectRoot = options.projectRoot;
  const logger = options.logger;

  const absoluteSource = path.resolve(filePath);
  if (!absoluteSource.endsWith(RAW_SUFFIX)) {
    throw new Error(`Expected a ${RAW_SUFFIX} file, got ${filePath}`);
  }

  const basePath = absoluteSource.slice(0, -RAW_SUFFIX.length);
  const outputPath = `${basePath}${OUTPUT_SUFFIX}`;

  const sourceText = await fs.readFile(absoluteSource, 'utf8');
  const structs = parseStructs(sourceText);
  const functions = parseFunctions(sourceText);
  const structMap = new Map(structs.map((entry) => [entry.name, entry]));

  const vertFn = functions.find((fn) => fn.name === 'strokeVertShader');
  const fragFn = functions.find((fn) => fn.name === 'strokeFragShader');

  if (!vertFn) {
    throw new Error('Missing strokeVertShader function.');
  }
  if (!fragFn) {
    throw new Error('Missing strokeFragShader function.');
  }

  if (vertFn.returnType !== 'vec2') {
    throw new Error(`strokeVertShader must return vec2. Received ${vertFn.returnType}.`);
  }
  if (vertFn.args.length !== 8) {
    throw new Error('strokeVertShader must declare 8 arguments (centerPos, normal, side, arcLength, normalizedArc, miterFactor, thickness, uniforms).');
  }
  validateType(vertFn.args[0], 'vec2', 'strokeVertShader centerPos');
  validateType(vertFn.args[1], 'vec2', 'strokeVertShader normal');
  validateType(vertFn.args[2], 'float', 'strokeVertShader side');
  validateType(vertFn.args[3], 'float', 'strokeVertShader arcLength');
  validateType(vertFn.args[4], 'float', 'strokeVertShader normalizedArc');
  validateType(vertFn.args[5], 'float', 'strokeVertShader miterFactor');
  validateType(vertFn.args[6], 'float', 'strokeVertShader thickness');

  const uniformStruct = structMap.get(vertFn.args[7].type);
  if (!uniformStruct) {
    throw new Error(`strokeVertShader uniforms must use a struct type. Received ${vertFn.args[7].type}.`);
  }

  if (fragFn.returnType !== 'vec4') {
    throw new Error(`strokeFragShader must return vec4. Received ${fragFn.returnType}.`);
  }
  if (fragFn.args.length < 4) {
    throw new Error('strokeFragShader must declare at least 4 arguments (uv, arcLength, normalizedArc, uniforms).');
  }
  validateType(fragFn.args[0], 'vec2', 'strokeFragShader uv');
  validateType(fragFn.args[1], 'float', 'strokeFragShader arcLength');
  validateType(fragFn.args[2], 'float', 'strokeFragShader normalizedArc');
  if (fragFn.args[3].type !== uniformStruct.name) {
    throw new Error(`strokeFragShader uniforms must use struct ${uniformStruct.name}.`);
  }

  const textureParams = parseTextureParams(fragFn.args, 4, 'strokeFragShader');
  const uniformFields = collectUniformFields(uniformStruct, 'uniforms');

  const shaderPrefix = toPascalCase(path.basename(basePath));

  const vertexSourceLines: string[] = [];
  vertexSourceLines.push(`${HEADER_COMMENT}`);
  vertexSourceLines.push('#version 300 es');
  vertexSourceLines.push('precision highp float;');
  vertexSourceLines.push('');
  vertexSourceLines.push('in vec3 position;');
  vertexSourceLines.push('in vec2 uv;');
  vertexSourceLines.push('in vec2 strokeNormal;');
  vertexSourceLines.push('in float strokeSide;');
  vertexSourceLines.push('in float strokeArcLength;');
  vertexSourceLines.push('in float strokeNormalizedArc;');
  vertexSourceLines.push('in float strokeMiterFactor;');
  vertexSourceLines.push('out vec2 vUV;');
  vertexSourceLines.push('out float vArcLength;');
  vertexSourceLines.push('out float vNormalizedArc;');
  vertexSourceLines.push(...buildUniformDeclarations(uniformFields));
  vertexSourceLines.push(`uniform vec2 ${SHAPE_TRANSLATE_UNIFORM};`);
  vertexSourceLines.push(`uniform float ${SHAPE_ROTATION_UNIFORM};`);
  vertexSourceLines.push(`uniform vec2 ${SHAPE_SCALE_UNIFORM};`);
  vertexSourceLines.push('uniform float power2d_canvasWidth;');
  vertexSourceLines.push('uniform float power2d_canvasHeight;');
  vertexSourceLines.push('uniform float power2d_strokeThickness;');
  vertexSourceLines.push('');
  vertexSourceLines.push(sourceText.trim());
  vertexSourceLines.push('');
  vertexSourceLines.push(`
${uniformStruct.name} load_${uniformStruct.name}() {`);
  vertexSourceLines.push(generateUniformStructConstruction(uniformStruct, uniformFields));
  vertexSourceLines.push('}');
  vertexSourceLines.push(`
vec2 power2d_applyShapeTransform(vec2 pixel) {`);
  vertexSourceLines.push(`  vec2 scaled = pixel * ${SHAPE_SCALE_UNIFORM};`);
  vertexSourceLines.push(`  float s = sin(${SHAPE_ROTATION_UNIFORM});`);
  vertexSourceLines.push(`  float c = cos(${SHAPE_ROTATION_UNIFORM});`);
  vertexSourceLines.push('  vec2 rotated = vec2(');
  vertexSourceLines.push('    scaled.x * c - scaled.y * s,');
  vertexSourceLines.push('    scaled.x * s + scaled.y * c');
  vertexSourceLines.push('  );');
  vertexSourceLines.push(`  return rotated + ${SHAPE_TRANSLATE_UNIFORM};`);
  vertexSourceLines.push('}');
  vertexSourceLines.push('');
  vertexSourceLines.push('vec4 power2d_pixelToNDC(vec2 pixel) {');
  vertexSourceLines.push('  float ndcX = (pixel.x / power2d_canvasWidth) * 2.0 - 1.0;');
  vertexSourceLines.push('  float ndcY = -((pixel.y / power2d_canvasHeight) * 2.0 - 1.0);');
  vertexSourceLines.push('  return vec4(ndcX, ndcY, 0.0, 1.0);');
  vertexSourceLines.push('}');
  vertexSourceLines.push('');
  vertexSourceLines.push('void main() {');
  vertexSourceLines.push(`  ${uniformStruct.name} uniformsValue = load_${uniformStruct.name}();`);
  vertexSourceLines.push('  vec2 centerPos = vec2(position.x, position.y);');
  vertexSourceLines.push('  vec2 normal = strokeNormal;');
  vertexSourceLines.push('  float side = strokeSide;');
  vertexSourceLines.push('  float arcLength = strokeArcLength;');
  vertexSourceLines.push('  float normalizedArc = strokeNormalizedArc;');
  vertexSourceLines.push('  float miterFactor = strokeMiterFactor;');
  vertexSourceLines.push('  float thickness = power2d_strokeThickness;');
  vertexSourceLines.push('  vec2 uvLocal = uv;');
  vertexSourceLines.push('  vec2 adjustedPixelPos = strokeVertShader(centerPos, normal, side, arcLength, normalizedArc, miterFactor, thickness, uniformsValue);');
  vertexSourceLines.push('  vec2 transformedPixelPos = power2d_applyShapeTransform(adjustedPixelPos);');
  vertexSourceLines.push('  gl_Position = power2d_pixelToNDC(transformedPixelPos);');
  vertexSourceLines.push('  vUV = uvLocal;');
  vertexSourceLines.push('  vArcLength = arcLength;');
  vertexSourceLines.push('  vNormalizedArc = normalizedArc;');
  vertexSourceLines.push('}');

  const fragmentSourceLines: string[] = [];
  fragmentSourceLines.push(`${HEADER_COMMENT}`);
  fragmentSourceLines.push('#version 300 es');
  fragmentSourceLines.push('precision highp float;');
  fragmentSourceLines.push('');
  fragmentSourceLines.push('in vec2 vUV;');
  fragmentSourceLines.push('in float vArcLength;');
  fragmentSourceLines.push('in float vNormalizedArc;');
  fragmentSourceLines.push('out vec4 outColor;');
  fragmentSourceLines.push(...buildUniformDeclarations(uniformFields));
  fragmentSourceLines.push(`uniform vec2 ${SHAPE_TRANSLATE_UNIFORM};`);
  fragmentSourceLines.push(`uniform float ${SHAPE_ROTATION_UNIFORM};`);
  fragmentSourceLines.push(`uniform vec2 ${SHAPE_SCALE_UNIFORM};`);
  fragmentSourceLines.push('uniform float power2d_canvasWidth;');
  fragmentSourceLines.push('uniform float power2d_canvasHeight;');
  fragmentSourceLines.push('uniform float power2d_strokeThickness;');
  if (textureParams.length > 0) {
    for (const texture of textureParams) {
      fragmentSourceLines.push(`uniform sampler2D ${texture.textureName};`);
    }
  }
  fragmentSourceLines.push('');
  fragmentSourceLines.push(sourceText.trim());
  fragmentSourceLines.push('');
  fragmentSourceLines.push(`
${uniformStruct.name} load_${uniformStruct.name}() {`);
  fragmentSourceLines.push(generateUniformStructConstruction(uniformStruct, uniformFields));
  fragmentSourceLines.push('}');
  fragmentSourceLines.push('');
  fragmentSourceLines.push('void main() {');
  fragmentSourceLines.push(`  ${uniformStruct.name} uniformsValue = load_${uniformStruct.name}();`);
  fragmentSourceLines.push('  vec2 uvLocal = vUV;');
  fragmentSourceLines.push('  float arcLength = vArcLength;');
  fragmentSourceLines.push('  float normalizedArc = vNormalizedArc;');
  const fragArgs = ['uvLocal', 'arcLength', 'normalizedArc', 'uniformsValue'];
  for (const texture of textureParams) {
    fragArgs.push(texture.textureName);
  }
  fragmentSourceLines.push(`  vec4 color = strokeFragShader(${fragArgs.join(', ')});`);
  fragmentSourceLines.push('  outColor = color;');
  fragmentSourceLines.push('}');

  const vertexSource = vertexSourceLines.join('\n');
  const fragmentSource = fragmentSourceLines.join('\n');

  const uniformInterfaceName = `${shaderPrefix}Uniforms`;
  const uniformMetaName = `${shaderPrefix}UniformMeta`;
  const uniformDefaultsName = `${shaderPrefix}UniformDefaults`;
  const setUniformsName = `set${shaderPrefix}Uniforms`;
  const textureNameType = `${shaderPrefix}TextureName`;
  const textureNamesConst = `${shaderPrefix}TextureNames`;
  const materialInstanceName = `${shaderPrefix}StrokeMaterialInstance`;
  const materialDefName = `${shaderPrefix}StrokeMaterialDef`;
  const createMaterialName = `create${shaderPrefix}StrokeMaterial`;
  const materialConstName = `${shaderPrefix}StrokeMaterial`;
  const materialAliasName = `${shaderPrefix}Material`;

  const tsLines: string[] = [];
  tsLines.push(HEADER_COMMENT);
  tsLines.push("import * as BABYLON from 'babylonjs';");
  tsLines.push('');
  tsLines.push(`export const ${shaderPrefix}VertexSource = ${escapeTemplateLiteral(vertexSource)};`);
  tsLines.push(`export const ${shaderPrefix}FragmentSource = ${escapeTemplateLiteral(fragmentSource)};`);
  tsLines.push('');

  const helperNames = new Set<string>();
  for (const field of uniformFields) {
    const meta = UNIFORM_TYPE_MAP[field.glslType];
    if (meta?.helper) {
      helperNames.add(meta.helper);
    }
  }

  for (const helperName of helperNames) {
    const snippet = HELPER_SNIPPETS[helperName];
    if (snippet) {
      tsLines.push(snippet);
      tsLines.push('');
    }
  }

  tsLines.push(`export interface ${uniformInterfaceName} {`);
  for (const field of uniformFields) {
    const meta = UNIFORM_TYPE_MAP[field.glslType];
    tsLines.push(`  ${field.name}: ${meta.tsType};`);
  }
  tsLines.push('}');
  tsLines.push('');

  tsLines.push(`export const ${uniformDefaultsName}: ${uniformInterfaceName} = {`);
  for (const field of uniformFields) {
    const meta = UNIFORM_TYPE_MAP[field.glslType];
    tsLines.push(`  ${field.name}: ${meta.defaultValue},`);
  }
  tsLines.push('};');
  tsLines.push('');

  tsLines.push(`export const ${uniformMetaName} = [`);
  for (const field of uniformFields) {
    const typeKey = field.glslType;
    const kindMap: Record<string, string> = {
      float: 'f32',
      int: 'i32',
      uint: 'u32',
      bool: 'bool',
      vec2: 'vec2f',
      vec3: 'vec3f',
      vec4: 'vec4f',
      mat4: 'mat4x4f',
    };
    tsLines.push('  {');
    tsLines.push(`    name: '${field.name}',`);
    tsLines.push(`    kind: '${kindMap[typeKey]}',`);
    tsLines.push(`    bindingName: '${field.bindingName}',`);
    tsLines.push('  },');
  }
  tsLines.push(`] as const;`);
  tsLines.push('');

  tsLines.push(`export function ${setUniformsName}(material: BABYLON.ShaderMaterial, uniforms: Partial<${uniformInterfaceName}>): void {`);
  tsLines.push('  if (!uniforms) {');
  tsLines.push('    return;');
  tsLines.push('  }');
  for (const field of uniformFields) {
    const meta = UNIFORM_TYPE_MAP[field.glslType];
    tsLines.push(`  if (uniforms.${field.name} !== undefined) {`);
    tsLines.push(`    material.${meta.setter}('${field.bindingName}', ${meta.expression(`uniforms.${field.name}`)});`);
    tsLines.push('  }');
  }
  tsLines.push('}');
  tsLines.push('');

  if (textureParams.length === 0) {
    tsLines.push(`export type ${textureNameType} = never;`);
    tsLines.push(`export const ${textureNamesConst} = [] as const;`);
  } else {
    const textureNameUnion = textureParams.map((param) => `'${param.textureName}'`).join(' | ');
    tsLines.push(`export type ${textureNameType} = ${textureNameUnion};`);
    tsLines.push(`export const ${textureNamesConst} = [${textureParams.map((param) => `'${param.textureName}'`).join(', ')}] as const;`);
  }
  tsLines.push('');

  tsLines.push(`export interface ${materialDefName} {`);
  tsLines.push(`  readonly uniformType: ${uniformInterfaceName};`);
  tsLines.push(`  readonly textureNames: readonly ${textureNameType}[];`);
  tsLines.push(`  readonly vertexSource: string;`);
  tsLines.push(`  readonly fragmentSource: string;`);
  tsLines.push(`  readonly uniformMeta: typeof ${uniformMetaName};`);
  tsLines.push(`  readonly uniformDefaults: ${uniformInterfaceName};`);
  tsLines.push(`  readonly createMaterial: (scene: BABYLON.Scene, name?: string) => ${materialInstanceName};`);
  tsLines.push('}');
  tsLines.push('');

  tsLines.push(`export interface ${materialInstanceName} {`);
  tsLines.push('  material: BABYLON.ShaderMaterial;');
  tsLines.push(`  setUniforms(uniforms: Partial<${uniformInterfaceName}>): void;`);
  tsLines.push(`  setTexture(name: ${textureNameType}, texture: BABYLON.BaseTexture): void;`);
  if (textureParams.length > 0) {
    tsLines.push(`  setTextureSampler(name: ${textureNameType}, sampler: BABYLON.TextureSampler): void;`);
  }
  tsLines.push('  setCanvasSize(width: number, height: number): void;');
  tsLines.push('  dispose(): void;');
  tsLines.push('}');
  tsLines.push('');

  tsLines.push(`export function ${createMaterialName}(scene: BABYLON.Scene, name: string = '${shaderPrefix}StrokeMaterial'): ${materialInstanceName} {`);
  tsLines.push('  const vertexShaderName = `${name}VertexShader`;');
  tsLines.push('  const fragmentShaderName = `${name}FragmentShader`;');
  tsLines.push('');
  tsLines.push(`  BABYLON.ShaderStore.ShadersStore[vertexShaderName] = ${shaderPrefix}VertexSource;`);
  tsLines.push(`  BABYLON.ShaderStore.ShadersStore[fragmentShaderName] = ${shaderPrefix}FragmentSource;`);
  tsLines.push('');

  const uniformNames = uniformFields.map((field) => field.bindingName);
  uniformNames.push(SHAPE_TRANSLATE_UNIFORM, SHAPE_ROTATION_UNIFORM, SHAPE_SCALE_UNIFORM, 'power2d_canvasWidth', 'power2d_canvasHeight', 'power2d_strokeThickness');
  const samplerNames = textureParams.map((param) => param.textureName);

  tsLines.push(`  const material = new BABYLON.ShaderMaterial(name, scene, {`);
  tsLines.push('    vertex: name,');
  tsLines.push('    fragment: name,');
  tsLines.push('  }, {');
  tsLines.push(`    attributes: ${JSON.stringify(['position', 'uv', 'strokeNormal', 'strokeSide', 'strokeArcLength', 'strokeNormalizedArc', 'strokeMiterFactor'])},`);
  tsLines.push(`    uniforms: ${JSON.stringify(uniformNames)},`);
  tsLines.push(`    samplers: ${JSON.stringify(samplerNames)},`);
  tsLines.push('    shaderLanguage: BABYLON.ShaderLanguage.GLSL,');
  tsLines.push('  });');
  tsLines.push('');

  if (textureParams.length > 0) {
    tsLines.push('  const defaultSampler = new BABYLON.TextureSampler();');
    tsLines.push('  defaultSampler.setParameters(');
    tsLines.push('    BABYLON.Texture.CLAMP_ADDRESSMODE,');
    tsLines.push('    BABYLON.Texture.CLAMP_ADDRESSMODE,');
    tsLines.push('    BABYLON.Texture.CLAMP_ADDRESSMODE,');
    tsLines.push('    undefined,');
    tsLines.push('    BABYLON.Texture.BILINEAR_SAMPLINGMODE,');
    tsLines.push('  );');
    tsLines.push('  const samplerState: Record<string, BABYLON.TextureSampler> = {};');
    tsLines.push(`  const textureState: Partial<Record<${textureNameType}, BABYLON.BaseTexture | null>> = {};`);
    tsLines.push('  const applySamplerToTexture = (texture: BABYLON.BaseTexture | null, sampler: BABYLON.TextureSampler) => {');
    tsLines.push('    if (!texture) return;');
    tsLines.push('    const wrapU = sampler.wrapU;');
    tsLines.push('    if (wrapU !== null && wrapU !== undefined) {');
    tsLines.push('      texture.wrapU = wrapU;');
    tsLines.push('    }');
    tsLines.push('    const wrapV = sampler.wrapV;');
    tsLines.push('    if (wrapV !== null && wrapV !== undefined) {');
    tsLines.push('      texture.wrapV = wrapV;');
    tsLines.push('    }');
    tsLines.push('    const wrapR = sampler.wrapR;');
    tsLines.push('    if (wrapR !== null && wrapR !== undefined) {');
    tsLines.push('      texture.wrapR = wrapR;');
    tsLines.push('    }');
    tsLines.push('    texture.updateSamplingMode(sampler.samplingMode);');
    tsLines.push('  };');
  }

  tsLines.push(`  ${setUniformsName}(material, ${uniformDefaultsName});`);
  tsLines.push(`  material.setVector2('${SHAPE_TRANSLATE_UNIFORM}', new BABYLON.Vector2(0, 0));`);
  tsLines.push(`  material.setFloat('${SHAPE_ROTATION_UNIFORM}', 0);`);
  tsLines.push(`  material.setVector2('${SHAPE_SCALE_UNIFORM}', new BABYLON.Vector2(1, 1));`);
  tsLines.push(`  material.setFloat('power2d_strokeThickness', 1);`);
  tsLines.push('  material.disableDepthWrite = true;');
  tsLines.push('  material.depthFunction = BABYLON.Constants.ALWAYS;');
  tsLines.push('  material.backFaceCulling = false;');
  tsLines.push('  material.alphaMode = BABYLON.Engine.ALPHA_COMBINE;');
  tsLines.push('');

  tsLines.push(`  const handles: ${materialInstanceName} = {`);
  tsLines.push('    material,');
  tsLines.push(`    setUniforms: (uniforms) => ${setUniformsName}(material, uniforms),`);
  if (textureParams.length > 0) {
    tsLines.push('    setTexture: (name, texture) => {');
    tsLines.push('      material.setTexture(name, texture);');
    tsLines.push('      textureState[name] = texture;');
    tsLines.push('      const sampler = samplerState[name] ?? defaultSampler;');
    tsLines.push('      applySamplerToTexture(texture, sampler);');
    tsLines.push('    },');
    tsLines.push('    setTextureSampler: (name, sampler) => {');
    tsLines.push('      samplerState[name] = sampler;');
    tsLines.push('      const texture = textureState[name] ?? null;');
    tsLines.push('      applySamplerToTexture(texture, sampler);');
    tsLines.push('    },');
  } else {
    tsLines.push('    setTexture: (name, texture) => material.setTexture(name, texture),');
  }
  tsLines.push('    setCanvasSize: (width, height) => {');
  tsLines.push("      material.setFloat('power2d_canvasWidth', width);");
  tsLines.push("      material.setFloat('power2d_canvasHeight', height);");
  tsLines.push('    },');
  tsLines.push('    dispose: () => {');
  tsLines.push('      material.dispose(true, false);');
  tsLines.push('      delete BABYLON.ShaderStore.ShadersStore[vertexShaderName];');
  tsLines.push('      delete BABYLON.ShaderStore.ShadersStore[fragmentShaderName];');
  tsLines.push('    },');
  tsLines.push('  };');
  tsLines.push('');
  tsLines.push('  return handles;');
  tsLines.push('}');
  tsLines.push('');

  tsLines.push(`export const ${materialConstName}: ${materialDefName} = {`);
  tsLines.push(`  uniformType: undefined as unknown as ${uniformInterfaceName},`);
  tsLines.push(`  textureNames: ${textureNamesConst},`);
  tsLines.push(`  vertexSource: ${shaderPrefix}VertexSource,`);
  tsLines.push(`  fragmentSource: ${shaderPrefix}FragmentSource,`);
  tsLines.push(`  uniformMeta: ${uniformMetaName},`);
  tsLines.push(`  uniformDefaults: ${uniformDefaultsName},`);
  tsLines.push(`  createMaterial: ${createMaterialName},`);
  tsLines.push('};');
  tsLines.push('');
  tsLines.push(`export const ${materialAliasName}: ${materialDefName} = ${materialConstName};`);
  tsLines.push('');
  tsLines.push(`export default ${materialConstName};`);

  const typesSource = tsLines.join('\n');
  const updated = await writeFileIfChanged(outputPath, typesSource);

  if (updated && logger) {
    const relative = path.relative(projectRoot, outputPath);
    logger(`Generated ${relative}`);
  }

  return {
    sourcePath: absoluteSource,
    outputPath,
    updated,
  };
}
