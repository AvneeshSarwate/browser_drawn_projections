import {
  ArgumentInfo,
  StructInfo,
  WgslReflect,
} from 'wgsl_reflect';

export const RAW_SUFFIX = '.fragFunc.wgsl';
export const TYPES_SUFFIX = '.frag.generated.ts';

const HEADER_COMMENT = '// Auto-generated by wgsl fragment generator. DO NOT EDIT.';

interface UniformField {
  name: string;
  bindingName: string;
  wgslType: string;
  defaultExpression?: string;
  uiMin?: number;
  uiMax?: number;
  uiStep?: number;
  isArray?: boolean;
  arraySize?: number;
  elementType?: string;
}

interface UniformCommentAnnotation {
  defaultExpression?: string;
  uiMin?: number;
  uiMax?: number;
  uiStep?: number;
}

interface TextureParam {
  textureName: string;
  samplerName: string;
}

interface PassTextureBinding extends TextureParam {
  source: 'input' | 'pass';
  passIndex?: number;
}

interface PassAnalysis {
  index: number;
  name: string;
  args: ArgumentInfo[];
  resourceBindings: PassTextureBinding[];
}

interface ShaderAnalysis {
  shaderCode: string;
  shaderBaseName: string;
  shaderPrefix: string;
  effectClassName: string;
  uvArgName: string;
  uniformStruct: StructInfo | null;
  uniformFields: UniformField[];
  uniformArgName: string | null;
  uniformArgIsPointer: boolean;
  resourceStartIndex: number;
  baseTextureParams: TextureParam[];
  passAnalyses: PassAnalysis[];
  passTextureBindings: PassTextureBinding[][];
  textureParams: TextureParam[];
  inputTextureParams: TextureParam[];
  passCount: number;
}

interface UniformTypeMetadata {
  tsType: string;
  setter: string;
  expression: (valueRef: string) => string;
  helper?: string;
}

const UNIFORM_TYPE_MAP: Record<string, UniformTypeMetadata> = {
  f32: {
    tsType: 'number',
    setter: 'setFloat',
    expression: (valueRef) => valueRef,
  },
  i32: {
    tsType: 'number',
    setter: 'setInt',
    expression: (valueRef) => valueRef,
  },
  u32: {
    tsType: 'number',
    setter: 'setUInt',
    expression: (valueRef) => valueRef,
  },
  bool: {
    tsType: 'boolean',
    setter: 'setFloat',
    expression: (valueRef) => `(${valueRef} ? 1 : 0)`,
  },
  vec2f: {
    tsType: 'BABYLON.Vector2 | readonly [number, number]',
    setter: 'setVector2',
    expression: (valueRef) => `ensureVector2(${valueRef})`,
    helper: 'ensureVector2',
  },
  vec3f: {
    tsType: 'BABYLON.Vector3 | readonly [number, number, number]',
    setter: 'setVector3',
    expression: (valueRef) => `ensureVector3(${valueRef})`,
    helper: 'ensureVector3',
  },
  vec4f: {
    tsType: 'BABYLON.Vector4 | readonly [number, number, number, number]',
    setter: 'setVector4',
    expression: (valueRef) => `ensureVector4(${valueRef})`,
    helper: 'ensureVector4',
  },
  mat4x4f: {
    tsType: 'BABYLON.Matrix | Float32Array | readonly number[]',
    setter: 'setMatrix',
    expression: (valueRef) => `ensureMatrix(${valueRef})`,
    helper: 'ensureMatrix',
  },
};

const HELPER_SNIPPETS: Record<string, string> = {
  ensureVector2: `function ensureVector2(value: BABYLON.Vector2 | readonly [number, number]): BABYLON.Vector2 {\n  return value instanceof BABYLON.Vector2 ? value : BABYLON.Vector2.FromArray(value as readonly [number, number]);\n}`,
  ensureVector3: `function ensureVector3(value: BABYLON.Vector3 | readonly [number, number, number]): BABYLON.Vector3 {\n  return value instanceof BABYLON.Vector3 ? value : BABYLON.Vector3.FromArray(value as readonly [number, number, number]);\n}`,
  ensureVector4: `function ensureVector4(value: BABYLON.Vector4 | readonly [number, number, number, number]): BABYLON.Vector4 {\n  return value instanceof BABYLON.Vector4 ? value : BABYLON.Vector4.FromArray(value as readonly [number, number, number, number]);\n}`,
  ensureMatrix: `function ensureMatrix(value: BABYLON.Matrix | Float32Array | readonly number[]): BABYLON.Matrix {\n  if (value instanceof BABYLON.Matrix) {\n    return value;\n  }\n  const matrix = BABYLON.Matrix.Identity();\n  matrix.copyFromArray(Array.from(value));\n  return matrix;\n}`,
  packVec2Array: `function packVec2Array(arr: Vec2Like[]): number[] {\n  return arr.flatMap(v => [v.x, v.y]);\n}`,
  packVec2ArrayWGSL: `function packVec2ArrayWGSL(arr: Vec2Like[]): number[] {\n  return arr.flatMap(v => [v.x, v.y, 0, 0]);\n}`,
  packVec3ArrayWGSL: `function packVec3ArrayWGSL(arr: Vec3Like[]): number[] {\n  return arr.flatMap(v => [v.x, v.y, v.z, 0]);\n}`,
  packVec4Array: `function packVec4Array(arr: Vec4Like[]): number[] {\n  return arr.flatMap(v => [v.x, v.y, v.z, v.w]);\n}`,
};

const VEC_LIKE_INTERFACES = `export interface Vec2Like { x: number; y: number }
export interface Vec3Like { x: number; y: number; z: number }
export interface Vec4Like { x: number; y: number; z: number; w: number }`;

interface ArrayUniformMeta {
  tsType: string;
  setter: string;
  pack: string | null;
}

const ARRAY_ELEMENT_TYPE_MAP: Record<string, ArrayUniformMeta> = {
  f32: { tsType: 'number[]', setter: 'setFloats', pack: null },
  i32: { tsType: 'number[]', setter: 'setFloats', pack: null },
  u32: { tsType: 'number[]', setter: 'setFloats', pack: null },
  vec2f: { tsType: 'Vec2Like[]', setter: 'setArray4', pack: 'packVec2ArrayWGSL' },
  vec3f: { tsType: 'Vec3Like[]', setter: 'setArray4', pack: 'packVec3ArrayWGSL' },
  vec4f: { tsType: 'Vec4Like[]', setter: 'setArray4', pack: 'packVec4Array' },
};

function toPascalCase(value: string): string {
  return value
    .replace(/[-_]/g, ' ')
    .split(' ')
    .filter(Boolean)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
}

function escapeTemplateLiteral(value: string): string {
  return `\`${value
    .replace(/\\/g, '\\\\')
    .replace(/`/g, '\\`')
    .replace(/\$\{/g, '\\${')}\``;
}

function validateUvArgument(argument: ArgumentInfo): void {
  const typeName = argument.type.getTypeName();
  if (typeName !== 'vec2f') {
    throw new Error(`First argument must be a vec2f called uv. Received ${argument.name}: ${typeName}`);
  }
}

function validateTextureArgument(argument: ArgumentInfo): void {
  const typeName = argument.type.getTypeName();
  if (typeName !== 'texture_2d<f32>') {
    throw new Error(`Texture argument must be texture_2d<f32>. Received ${argument.name}: ${typeName}`);
  }
}

function validateSamplerArgument(argument: ArgumentInfo): void {
  const typeName = argument.type.getTypeName();
  if (typeName !== 'sampler') {
    throw new Error(`Sampler argument must be sampler. Received ${argument.name}: ${typeName}`);
  }
}

function collectUniformFields(struct: StructInfo, uniformArgName: string, shaderSource: string): UniformField[] {
  const annotationMap = extractUniformAnnotations(shaderSource, struct.name);
  return struct.members.map((member) => {
    if (member.type.isStruct) {
      throw new Error(`Uniform field ${member.name} uses unsupported type ${member.type.getTypeName()}. Nested structs are not supported.`);
    }
    const bindingName = `${uniformArgName}_${member.name}`;
    const annotations = annotationMap[member.name];

    if (member.type.isArray) {
      const elementType = member.format?.getTypeName();
      if (!elementType) {
        throw new Error(`Uniform field ${member.name} is an array but element type could not be determined.`);
      }
      if (!ARRAY_ELEMENT_TYPE_MAP[elementType]) {
        throw new Error(`Uniform array field ${member.name} uses unsupported element type ${elementType}.`);
      }
      const arraySize = member.count;
      if (!arraySize || arraySize <= 0) {
        throw new Error(`Uniform array field ${member.name} must have a fixed size.`);
      }
      return {
        name: member.name,
        bindingName,
        wgslType: member.type.getTypeName(),
        defaultExpression: annotations?.defaultExpression,
        uiMin: annotations?.uiMin,
        uiMax: annotations?.uiMax,
        uiStep: annotations?.uiStep,
        isArray: true,
        arraySize,
        elementType,
      };
    }

    const typeName = member.type.getTypeName();
    if (!UNIFORM_TYPE_MAP[typeName]) {
      throw new Error(`Uniform field ${member.name} uses unsupported type ${typeName}.`);
    }
    return {
      name: member.name,
      bindingName,
      wgslType: typeName,
      defaultExpression: annotations?.defaultExpression,
      uiMin: annotations?.uiMin,
      uiMax: annotations?.uiMax,
      uiStep: annotations?.uiStep,
    };
  });
}

function extractUniformAnnotations(source: string, structName: string): Record<string, UniformCommentAnnotation> {
  const annotations: Record<string, UniformCommentAnnotation> = {};
  const structRegex = new RegExp(`struct\\s+${structName}\\s*\\{`, 'g');
  const match = structRegex.exec(source);
  if (!match) {
    return annotations;
  }
  const braceStart = source.indexOf('{', match.index);
  if (braceStart === -1) {
    return annotations;
  }
  let depth = 0;
  let endIndex = braceStart;
  for (let i = braceStart; i < source.length; i++) {
    const char = source[i];
    if (char === '{') {
      depth++;
    } else if (char === '}') {
      depth--;
      if (depth === 0) {
        endIndex = i;
        break;
      }
    }
  }
  const body = source.slice(braceStart + 1, endIndex);
  const lines = body.split(/\r?\n/);
  for (const rawLine of lines) {
    const line = rawLine.trim();
    if (!line) {
      continue;
    }
    const commentIndex = line.indexOf('//');
    if (commentIndex === -1) {
      continue;
    }
    const comment = line.slice(commentIndex + 2).trim();
    if (!comment) {
      continue;
    }
    const declarationPart = line.slice(0, commentIndex).trim().replace(/,+$/, '');
    const fieldMatch = declarationPart.match(/^([A-Za-z0-9_]+)\s*:/);
    if (!fieldMatch) {
      continue;
    }
    const fieldName = fieldMatch[1];
    const annotation = parseUniformComment(comment);
    if (annotation) {
      annotations[fieldName] = annotation;
    }
  }
  return annotations;
}

function parseUniformComment(comment: string): UniformCommentAnnotation | null {
  const trimmed = comment.trim();
  if (!trimmed) {
    return null;
  }
  const annotation: UniformCommentAnnotation = {};
  const defaultExpression = parseDefaultExpression(trimmed);
  if (defaultExpression !== null) {
    annotation.defaultExpression = defaultExpression;
  }
  const minMatch = trimmed.match(/(?:^|\s)min=([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)/);
  const maxMatch = trimmed.match(/(?:^|\s)max=([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)/);
  const stepMatch = trimmed.match(/(?:^|\s)step=([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)/);
  if (minMatch) {
    const value = Number(minMatch[1]);
    if (!Number.isNaN(value)) {
      annotation.uiMin = value;
    }
  }
  if (maxMatch) {
    const value = Number(maxMatch[1]);
    if (!Number.isNaN(value)) {
      annotation.uiMax = value;
    }
  }
  if (stepMatch) {
    const value = Number(stepMatch[1]);
    if (!Number.isNaN(value)) {
      annotation.uiStep = value;
    }
  }
  return Object.keys(annotation).length > 0 ? annotation : null;
}

function parseDefaultExpression(comment: string): string | null {
  const trimmed = comment.trim();
  if (!trimmed || /^(?:min|max|step)=/i.test(trimmed)) {
    return null;
  }

  let candidate = trimmed;
  const firstChar = trimmed[0];

  if (firstChar === '[') {
    const match = trimmed.match(/^\[[^\]]*\]/);
    if (match) {
      candidate = match[0];
    }
  } else if (firstChar === '{') {
    const match = trimmed.match(/^\{[^}]*\}/);
    if (match) {
      candidate = match[0];
    }
  } else {
    // eslint-disable-next-line no-useless-escape
    const quotedMatch = trimmed.match(/^(\"[^\"]*\"|\'[^\']*\')/);
    if (quotedMatch) {
      candidate = quotedMatch[0];
    } else {
      const boolMatch = trimmed.match(/^(true|false)/i);
      if (boolMatch) {
        candidate = boolMatch[1].toLowerCase();
      } else {
        const numericMatch = trimmed.match(/^[-+]?(?:\d+\.\d*|\d*\.\d+|\d+)(?:[eE][-+]?\d+)?/);
        if (numericMatch && numericMatch[0] !== '') {
          candidate = numericMatch[0];
        } else {
          const firstToken = trimmed.split(/\s+/)[0];
          candidate = firstToken;
        }
      }
    }
  }

  try {
    const parsed = JSON.parse(candidate);
    if (typeof parsed === 'boolean') {
      return parsed ? 'true' : 'false';
    }
    if (typeof parsed === 'number') {
      return candidate;
    }
    if (typeof parsed === 'string') {
      return JSON.stringify(parsed);
    }
    return candidate;
  } catch (error) {
    const lower = candidate.toLowerCase();
    if (lower === 'true' || lower === 'false') {
      return lower;
    }
    const numeric = Number(candidate);
    if (!Number.isNaN(numeric)) {
      return candidate;
    }
  }
  return null;
}

function generateUniformStructConstruction(struct: StructInfo, fields: UniformField[]): string {
  if (fields.length === 0) {
    return '';
  }
  // Use assignment syntax instead of constructor to support arrays
  const assignments = fields
    .map((field) => {
      if (field.isArray && field.arraySize) {
        return `  for (var i = 0; i < ${field.arraySize}; i = i + 1) {\n    result.${field.name}[i] = uniforms.${field.bindingName}[i];\n  }`;
      }
      return `  result.${field.name} = uniforms.${field.bindingName};`;
    })
    .join('\n');
  return `fn load_${struct.name}() -> ${struct.name} {\n  var result: ${struct.name};\n${assignments}\n  return result;\n}`;
}

function buildVertexSource(commonDeclarations: string[], varyingName: string): string {
  const lines: string[] = [];
  lines.push(HEADER_COMMENT);
  if (commonDeclarations.length > 0) {
    lines.push(...commonDeclarations);
    lines.push('');
  }
  lines.push('#define CUSTOM_VERTEX_DEFINITIONS');
  lines.push('@vertex');
  lines.push('fn main(input : VertexInputs) -> FragmentInputs {');
  lines.push('#define CUSTOM_VERTEX_MAIN_BEGIN');
  lines.push('  vertexOutputs.position = vec4<f32>(vertexInputs.position, 1.0);');
  lines.push(`  vertexOutputs.${varyingName} = vertexInputs.uv;`);
  lines.push('#define CUSTOM_VERTEX_MAIN_END');
  lines.push('}');
  lines.push('');
  return `${lines.join('\n')}\n`;
}

function buildFragmentSource(
  rawSource: string,
  commonDeclarations: string[],
  uniformStruct: StructInfo | null,
  uniformLoaderFn: string,
  functionName: string,
  uvArgName: string,
  uniformArgName: string | null,
  uniformArgIsPointer: boolean,
  passArgs: ArgumentInfo[],
  resourceStartIndex: number,
  varyingName: string,
): string {
  const lines: string[] = [];
  lines.push(HEADER_COMMENT);
  if (commonDeclarations.length > 0) {
    lines.push(...commonDeclarations);
    lines.push('');
  }
  lines.push('// Source fragment function');
  lines.push(rawSource.trimEnd());
  lines.push('');
  if (uniformStruct && uniformLoaderFn) {
    lines.push(uniformLoaderFn);
    lines.push('');
  }
  lines.push('#define CUSTOM_FRAGMENT_DEFINITIONS');
  lines.push('@fragment');
  lines.push('fn main(input: FragmentInputs) -> FragmentOutputs {');
  lines.push('#define CUSTOM_FRAGMENT_MAIN_BEGIN');
  if (uniformStruct) {
    const declKeyword = uniformArgIsPointer ? 'var' : 'let';
    lines.push(`  ${declKeyword} ${uniformArgName}_value = load_${uniformStruct.name}();`);
  }
  lines.push(`  let ${uvArgName}_local = fragmentInputs.${varyingName};`);
  const resourceArgNames = passArgs.slice(resourceStartIndex).map((argument) => argument.name);
  const args: string[] = [`${uvArgName}_local`];
  if (uniformStruct) {
    args.push(uniformArgIsPointer ? `&${uniformArgName}_value` : `${uniformArgName}_value`);
  }
  resourceArgNames.forEach((name) => {
    args.push(name);
  });
  lines.push(`  let color = ${functionName}(${args.join(', ')});`);
  lines.push('  fragmentOutputs.color = color;');
  lines.push('#define CUSTOM_FRAGMENT_MAIN_END');
  lines.push('}');
  lines.push('');
  return `${lines.join('\n')}\n`;
}

function analyzeShaderSource(
  shaderCode: string,
  reflect: WgslReflect,
  shaderBaseName: string,
): ShaderAnalysis {
  const shaderPrefix = toPascalCase(shaderBaseName);
  const effectClassName = `${shaderPrefix}Effect`;

  const freeFunctions = reflect.functions.filter((fn) => !fn.stage);
  const passFunctions = freeFunctions.filter((fn) => /^pass\d+$/.test(fn.name));

  if (passFunctions.length === 0) {
    const helperNames = freeFunctions.map((fn) => fn.name).join(', ');
    const suffix = helperNames ? ` Found helper functions: ${helperNames}` : '';
    throw new Error(`No pass functions found. Expected one or more functions named pass0, pass1, ... in fragment shader.${suffix}`);
  }

  const indexedPasses = passFunctions
    .map((fn) => {
      const index = Number(fn.name.replace('pass', ''));
      if (!Number.isInteger(index)) {
        throw new Error(`Pass function ${fn.name} uses an invalid index.`);
      }
      return { fn, index };
    })
    .sort((a, b) => a.index - b.index);

  const seenIndexes = new Set<number>();
  indexedPasses.forEach(({ index }) => {
    if (seenIndexes.has(index)) {
      throw new Error(`Duplicate pass index detected for pass${index}.`);
    }
    seenIndexes.add(index);
  });

  indexedPasses.forEach(({ index }) => {
    if (index < 0) {
      throw new Error(`Pass indexes must start at 0. Received pass${index}.`);
    }
  });

  indexedPasses.forEach(({ index }, position) => {
    if (index !== position) {
      throw new Error(`Missing pass${position}. Pass functions must form a contiguous sequence starting at pass0.`);
    }
  });

  const orderedPassFunctions = indexedPasses.map(({ fn }) => fn);
  const passCount = orderedPassFunctions.length;

  orderedPassFunctions.forEach((fn) => {
    const returnType = fn.returnType?.getTypeName();
    if (returnType !== 'vec4f') {
      throw new Error(`Fragment pass ${fn.name} must return vec4f. Received ${returnType ?? 'void'}.`);
    }
  });

  const primaryPass = orderedPassFunctions[0];
  const primaryArgs = primaryPass.arguments;
  if (primaryArgs.length < 3) {
    throw new Error('Fragment function must include uv followed by at least one texture/sampler pair.');
  }

  const uvArg = primaryArgs[0];
  validateUvArgument(uvArg);
  const uvArgName = uvArg.name;

  let uniformStruct: StructInfo | null = null;
  let uniformFields: UniformField[] = [];
  let uniformArgName: string | null = null;
  let uniformArgIsPointer = false;
  let resourceStartIndex = 1;

  if (primaryArgs.length >= 4) {
    const potentialUniform = primaryArgs[1];
    const typeName = potentialUniform.type.getTypeName();
    let structInfo = reflect.structs.find((entry) => entry.name === typeName);
    if (!structInfo) {
      const pointerMatch = /^&(.+)$/.exec(typeName);
      if (pointerMatch) {
        structInfo = reflect.structs.find((entry) => entry.name === pointerMatch[1]);
        if (structInfo) {
          uniformArgIsPointer = true;
        }
      }
    }
    if (structInfo) {
      uniformStruct = structInfo;
      uniformArgName = potentialUniform.name;
      uniformFields = collectUniformFields(structInfo, uniformArgName, shaderCode);
      resourceStartIndex = 2;
    }
  }

  const baseArgumentNames = primaryArgs.slice(0, resourceStartIndex).map((argument) => argument.name);
  const baseArgumentTypes = primaryArgs.slice(0, resourceStartIndex).map((argument) => argument.type.getTypeName());

  const passAnalyses: PassAnalysis[] = [];
  const passTextureBindings: PassTextureBinding[][] = [];
  const baseTextureParams: TextureParam[] = [];
  const baseTextureLookup = new Map<string, TextureParam>();
  const textureParamMap = new Map<string, TextureParam>();

  const analyzePassResources = (
    passFn: typeof primaryPass,
    passIndex: number,
  ): PassTextureBinding[] => {
    const passArgs = passFn.arguments;
    if (passArgs.length < resourceStartIndex) {
      throw new Error(
        `${passFn.name} must declare at least ${resourceStartIndex} arguments (uv${uniformStruct ? ', uniforms' : ''}).`,
      );
    }

    for (let index = 0; index < resourceStartIndex; index++) {
      const expectedName = baseArgumentNames[index];
      const expectedType = baseArgumentTypes[index];
      const argument = passArgs[index];
      if (!argument) {
        throw new Error(`Argument ${index} of ${passFn.name} must be ${expectedType} named ${expectedName}.`);
      }
      const actualType = argument.type.getTypeName();
      if (actualType !== expectedType) {
        throw new Error(`Argument ${index} of ${passFn.name} must be ${expectedType}. Received ${actualType}.`);
      }
      if (argument.name !== expectedName) {
        throw new Error(`Argument ${index} of ${passFn.name} must be named ${expectedName}. Received ${argument.name}.`);
      }
    }

    const bindings: PassTextureBinding[] = [];
    const seenPassDependencies = new Set<number>();
    const seenTextureNames = new Set<string>();
    const extraCount = passArgs.length - resourceStartIndex;
    if (extraCount < 0 || extraCount % 2 !== 0) {
      throw new Error(`Additional arguments for ${passFn.name} must be provided in texture/sampler pairs.`);
    }

    for (let offset = 0; offset < extraCount; offset += 2) {
      const argumentIndex = resourceStartIndex + offset;
      const textureArg = passArgs[argumentIndex];
      const samplerArg = passArgs[argumentIndex + 1];
      if (!samplerArg) {
        throw new Error('Texture parameter must be followed by a sampler parameter.');
      }
      validateTextureArgument(textureArg);
      validateSamplerArgument(samplerArg);
      if (seenTextureNames.has(textureArg.name)) {
        throw new Error(`Duplicate texture parameter ${textureArg.name} detected in ${passFn.name}.`);
      }
      seenTextureNames.add(textureArg.name);

      const passDependencyMatch = /^pass(\d+)Texture$/.exec(textureArg.name);
      if (passDependencyMatch) {
        const dependencyIndex = Number(passDependencyMatch[1]);
        if (!Number.isInteger(dependencyIndex)) {
          throw new Error(`Invalid pass dependency ${textureArg.name} in ${passFn.name}.`);
        }
        if (dependencyIndex < 0 || dependencyIndex >= passIndex) {
          throw new Error(
            `Pass ${passFn.name} can only depend on earlier passes. Received dependency on pass${dependencyIndex}.`,
          );
        }
        if (seenPassDependencies.has(dependencyIndex)) {
          throw new Error(`Duplicate dependency on pass${dependencyIndex} detected in ${passFn.name}.`);
        }
        seenPassDependencies.add(dependencyIndex);
        const expectedSamplerName = `pass${dependencyIndex}Sampler`;
        if (samplerArg.name !== expectedSamplerName) {
          throw new Error(
            `Sampler parameter for dependency ${textureArg.name} must be named ${expectedSamplerName}. Received ${samplerArg.name}.`,
          );
        }
        bindings.push({
          textureName: textureArg.name,
          samplerName: samplerArg.name,
          source: 'pass',
          passIndex: dependencyIndex,
        });
        if (!textureParamMap.has(textureArg.name)) {
          textureParamMap.set(textureArg.name, {
            textureName: textureArg.name,
            samplerName: samplerArg.name,
          });
        }
        continue;
      }

      const baseTexture = baseTextureLookup.get(textureArg.name);
      if (!baseTexture) {
        if (passIndex === 0) {
          const expectedSamplerName = `${textureArg.name}Sampler`;
          if (samplerArg.name !== expectedSamplerName) {
            throw new Error(
              `Sampler parameter must be named ${expectedSamplerName} to match the texture parameter ${textureArg.name}.`,
            );
          }
          const param: TextureParam = {
            textureName: textureArg.name,
            samplerName: samplerArg.name,
          };
          baseTextureParams.push(param);
          baseTextureLookup.set(textureArg.name, param);
          textureParamMap.set(textureArg.name, param);
          bindings.push({
            textureName: textureArg.name,
            samplerName: samplerArg.name,
            source: 'input',
          });
        } else {
          throw new Error(
            `Pass ${passFn.name} references unknown texture ${textureArg.name}. Base textures must be declared in pass0.`,
          );
        }
        continue;
      }

      const expectedSamplerName = baseTexture.samplerName;
      if (samplerArg.name !== expectedSamplerName) {
        throw new Error(
          `Sampler parameter must be named ${expectedSamplerName} to match the texture parameter ${textureArg.name}.`,
        );
      }
      bindings.push({
        textureName: textureArg.name,
        samplerName: samplerArg.name,
        source: 'input',
      });
    }

    return bindings;
  };

  orderedPassFunctions.forEach((passFn, passIndex) => {
    const bindings = analyzePassResources(passFn, passIndex);
    passAnalyses.push({
      index: passIndex,
      name: passFn.name,
      args: passFn.arguments,
      resourceBindings: bindings,
    });
    passTextureBindings.push(bindings);
  });

  if (baseTextureParams.length === 0) {
    throw new Error('At least one texture argument is required for a pass.');
  }

  const textureParams = Array.from(textureParamMap.values());

  return {
    shaderCode,
    shaderBaseName,
    shaderPrefix,
    effectClassName,
    uvArgName,
    uniformStruct,
    uniformFields,
    uniformArgName,
    uniformArgIsPointer,
    resourceStartIndex,
    baseTextureParams,
    passAnalyses,
    passTextureBindings,
    textureParams,
    inputTextureParams: baseTextureParams,
    passCount,
  };
}

function expectMeta(typeName: string): UniformTypeMetadata {
  const meta = UNIFORM_TYPE_MAP[typeName];
  if (!meta) {
    throw new Error(`Unsupported uniform type ${typeName}`);
  }
  return meta;
}

export interface FragmentShaderNaming {
  shaderPrefix: string;
  effectClassName: string;
  defaultUniformInterfaceName: string;
}

export function getFragmentShaderNaming(shaderBaseName: string): FragmentShaderNaming {
  const shaderPrefix = toPascalCase(shaderBaseName);
  return {
    shaderPrefix,
    effectClassName: `${shaderPrefix}Effect`,
    defaultUniformInterfaceName: `${shaderPrefix}Uniforms`,
  };
}

export interface GenerateFragmentShaderArtifactsSourceOptions {
  shaderCode: string;
  shaderBaseName: string;
  shaderFxImportPath: string;
}

export interface GenerateFragmentShaderArtifactsSourceResult {
  typesSource: string;
  shaderPrefix: string;
  effectClassName: string;
  uniformInterfaceName: string;
}

export function generateFragmentShaderArtifactsSource(
  options: GenerateFragmentShaderArtifactsSourceOptions,
): GenerateFragmentShaderArtifactsSourceResult {
  const { shaderCode, shaderBaseName, shaderFxImportPath } = options;

  const naming = getFragmentShaderNaming(shaderBaseName);
  const { shaderPrefix, effectClassName, defaultUniformInterfaceName } = naming;

  const reflect = new WgslReflect(shaderCode);
  const analysis = analyzeShaderSource(shaderCode, reflect, shaderBaseName);
  const {
    uvArgName,
    uniformStruct,
    uniformFields,
    uniformArgName,
    uniformArgIsPointer,
    resourceStartIndex,
    baseTextureParams,
    passAnalyses,
    passTextureBindings,
    textureParams,
    inputTextureParams,
    passCount,
  } = analysis;

  const primaryTextureName = inputTextureParams[0]?.textureName;
  if (!primaryTextureName) {
    throw new Error('At least one texture argument is required for a pass.');
  }

  const shaderFxImports = [
    'CustomShaderEffect',
    'type ShaderSource',
    'type RenderPrecision',
    'type UniformDescriptor',
  ];
  if (uniformFields.length > 0) {
    shaderFxImports.push('type ShaderUniforms', 'type Dynamic');
  }

  const uniformLoaderFn = uniformStruct ? generateUniformStructConstruction(uniformStruct, uniformFields) : '';
  const uniformDeclarations = uniformFields.map((field) => {
    if (field.isArray && field.elementType && field.arraySize) {
      return `uniform ${field.bindingName}: array<${field.elementType}, ${field.arraySize}>;`;
    }
    return `uniform ${field.bindingName}: ${field.wgslType};`;
  });

  const varyingName = 'vUV';

  const vertexDeclarations: string[] = [
    'attribute position: vec3<f32>;',
    'attribute uv: vec2<f32>;',
    `varying ${varyingName}: vec2<f32>;`,
  ];

  const vertexSource = buildVertexSource(vertexDeclarations, varyingName);
  const fragmentSources = passAnalyses.map((passInfo) => {
    const fragmentDeclarations: string[] = [`varying ${varyingName}: vec2<f32>;`];
    if (uniformDeclarations.length > 0) {
      fragmentDeclarations.push(...uniformDeclarations);
    }
    const declared = new Set<string>();
    for (let argumentIndex = resourceStartIndex; argumentIndex < passInfo.args.length; argumentIndex += 2) {
      const textureArg = passInfo.args[argumentIndex];
      const samplerArg = passInfo.args[argumentIndex + 1];
      if (!textureArg || !samplerArg) {
        throw new Error(`Texture parameters in ${passInfo.name} must be provided in texture/sampler pairs.`);
      }
      if (!declared.has(textureArg.name)) {
        fragmentDeclarations.push(`var ${textureArg.name}: texture_2d<f32>;`);
        declared.add(textureArg.name);
      }
      if (!declared.has(samplerArg.name)) {
        fragmentDeclarations.push(`var ${samplerArg.name}: sampler;`);
        declared.add(samplerArg.name);
      }
    }

    return buildFragmentSource(
      shaderCode,
      fragmentDeclarations,
      uniformStruct,
      uniformLoaderFn,
      passInfo.name,
      uvArgName,
      uniformArgName,
      uniformArgIsPointer,
      passInfo.args,
      resourceStartIndex,
      varyingName,
    );
  });

  const uniformInterfaceName = uniformStruct
    ? (uniformStruct.name.startsWith(shaderPrefix) ? uniformStruct.name : `${shaderPrefix}${uniformStruct.name}`)
    : defaultUniformInterfaceName;

  const helperNames = new Set<string>();
  const uniformInterfaceLines: string[] = [];
  const uniformSetterLines: string[] = [];

  const hasArrayFields = uniformFields.some((field) => field.isArray);

  if (uniformStruct && uniformFields.length > 0) {
    uniformInterfaceLines.push(`export interface ${uniformInterfaceName} {`);
    for (const field of uniformFields) {
      if (field.isArray && field.elementType) {
        const arrayMeta = ARRAY_ELEMENT_TYPE_MAP[field.elementType];
        if (!arrayMeta) {
          throw new Error(`Unsupported array element type ${field.elementType}.`);
        }
        uniformInterfaceLines.push(`  ${field.name}: ${arrayMeta.tsType};`);
        if (arrayMeta.pack) {
          helperNames.add(arrayMeta.pack);
        }
      } else {
        const meta = UNIFORM_TYPE_MAP[field.wgslType];
        if (!meta) {
          throw new Error(`Unsupported uniform field type ${field.wgslType}.`);
        }
        uniformInterfaceLines.push(`  ${field.name}: ${meta.tsType};`);
        if (meta.helper) {
          helperNames.add(meta.helper);
        }
      }
    }
    uniformInterfaceLines.push('}');

    uniformSetterLines.push(`export function set${uniformInterfaceName}(material: BABYLON.ShaderMaterial, uniforms: Partial<${uniformInterfaceName}>): void {`);
    uniformSetterLines.push('  if (!uniforms) {');
    uniformSetterLines.push('    return;');
    uniformSetterLines.push('  }');
    for (const field of uniformFields) {
      uniformSetterLines.push(`  if (uniforms.${field.name} !== undefined) {`);
      if (field.isArray && field.elementType) {
        const arrayMeta = ARRAY_ELEMENT_TYPE_MAP[field.elementType];
        if (arrayMeta.pack) {
          uniformSetterLines.push(`    material.${arrayMeta.setter}('${field.bindingName}', ${arrayMeta.pack}(uniforms.${field.name}));`);
        } else {
          uniformSetterLines.push(`    material.${arrayMeta.setter}('${field.bindingName}', uniforms.${field.name});`);
        }
      } else {
        const meta = expectMeta(field.wgslType);
        uniformSetterLines.push(`    material.${meta.setter}('${field.bindingName}', ${meta.expression(`uniforms.${field.name}`)});`);
      }
      uniformSetterLines.push('  }');
    }
    uniformSetterLines.push('}');
  }

  const helperBlocks = Array.from(helperNames).map((name) => HELPER_SNIPPETS[name]);

  const uniformsArrayLiteral = uniformFields.length
    ? `[${uniformFields.map((field) => `'${field.bindingName}'`).join(', ')}]`
    : '[]';

  const textureNamesArrayLiteral = `[${textureParams.map((param) => `'${param.textureName}'`).join(', ')}]`;
  const samplerObjectsArrayLiteral = `[${textureParams.map((param) => `'${param.samplerName}'`).join(', ')}]`;
  const samplerLookupLiteral = `{ ${textureParams
    .map((param) => `'${param.textureName}': '${param.samplerName}'`)
    .join(', ')} } as const`;
  const inputTextureNamesArrayLiteral = `[${inputTextureParams.map((param) => `'${param.textureName}'`).join(', ')}]`;

  const materialHandlesName = `${shaderPrefix}MaterialHandles`;
  const materialOptionsName = `${shaderPrefix}MaterialOptions`;
  const setUniformsFunctionName = uniformStruct && uniformFields.length > 0 ? `set${uniformInterfaceName}` : null;
  const uniformMetaConstName = `${shaderPrefix}UniformMeta`;

  const tsLines: string[] = [];
  tsLines.push(HEADER_COMMENT);
  tsLines.push(`import * as BABYLON from 'babylonjs';`);
  tsLines.push(`import { ${shaderFxImports.join(', ')} } from '${shaderFxImportPath}';`);
  tsLines.push(`export const ${shaderPrefix}VertexSource = ${escapeTemplateLiteral(vertexSource)};`);
  tsLines.push(`export const ${shaderPrefix}FragmentSources = [`);
  fragmentSources.forEach((source, index) => {
    tsLines.push(`  ${escapeTemplateLiteral(source)}, // pass${index}`);
  });
  tsLines.push(`] as const;`);
  tsLines.push(`export const ${shaderPrefix}PassCount = ${passCount} as const;`);
  tsLines.push(`export const ${shaderPrefix}PrimaryTextureName = '${primaryTextureName}' as const;`);
  tsLines.push('');

  const passTextureSourceLines: string[] = [];
  passTextureSourceLines.push(`export const ${shaderPrefix}PassTextureSources = [`);
  passTextureBindings.forEach((bindings) => {
    passTextureSourceLines.push('  [');
    bindings.forEach((binding) => {
      if (binding.source === 'input') {
        passTextureSourceLines.push(
          `    { binding: '${binding.textureName}', source: { kind: 'input', key: '${binding.textureName}' } },`,
        );
      } else {
        passTextureSourceLines.push(
          `    { binding: '${binding.textureName}', source: { kind: 'pass', passIndex: ${binding.passIndex} } },`,
        );
      }
    });
    passTextureSourceLines.push('  ],');
  });
  passTextureSourceLines.push(`] as const;`);
  passTextureSourceLines.push('');
  tsLines.push(...passTextureSourceLines);

  const uniformMetaLines: string[] = [];
  if (uniformFields.length > 0) {
    uniformMetaLines.push(`export const ${uniformMetaConstName}: UniformDescriptor[] = [`);
    uniformFields.forEach((field) => {
      uniformMetaLines.push('  {');
      uniformMetaLines.push(`    name: '${field.name}',`);
      if (field.isArray && field.elementType) {
        uniformMetaLines.push(`    kind: '${field.elementType}',`);
        uniformMetaLines.push(`    isArray: true,`);
        uniformMetaLines.push(`    arraySize: ${field.arraySize},`);
      } else {
        uniformMetaLines.push(`    kind: '${field.wgslType}',`);
      }
      uniformMetaLines.push(`    bindingName: '${field.bindingName}',`);
      if (field.defaultExpression) {
        uniformMetaLines.push(`    default: ${field.defaultExpression},`);
      }
      const uiEntries: string[] = [];
      if (field.uiMin !== undefined) {
        uiEntries.push(`min: ${field.uiMin}`);
      }
      if (field.uiMax !== undefined) {
        uiEntries.push(`max: ${field.uiMax}`);
      }
      if (field.uiStep !== undefined) {
        uiEntries.push(`step: ${field.uiStep}`);
      }
      if (uiEntries.length > 0) {
        uniformMetaLines.push(`    ui: { ${uiEntries.join(', ')} },`);
      }
      uniformMetaLines.push('  },');
    });
    uniformMetaLines.push('];');
  } else {
    uniformMetaLines.push(`export const ${uniformMetaConstName}: UniformDescriptor[] = [];`);
  }
  uniformMetaLines.push('');
  tsLines.push(...uniformMetaLines);

  if (hasArrayFields) {
    tsLines.push(VEC_LIKE_INTERFACES);
    tsLines.push('');
  }
  if (helperBlocks.length > 0) {
    tsLines.push(...helperBlocks);
    tsLines.push('');
  }
  if (uniformStruct && uniformFields.length > 0) {
    tsLines.push(...uniformInterfaceLines);
    tsLines.push('');
    tsLines.push(...uniformSetterLines);
    tsLines.push('');
  } else {
    tsLines.push(`export type ${uniformInterfaceName} = Record<string, never>;`);
    tsLines.push(`export function set${uniformInterfaceName}(_material: BABYLON.ShaderMaterial, _uniforms: Partial<${uniformInterfaceName}>): void {}`);
    tsLines.push('');
  }
  const textureNameUnion = textureParams.map((param) => `'${param.textureName}'`).join(' | ');
  const inputsTypeName = `${shaderPrefix}Inputs`;
  tsLines.push(`export type ${shaderPrefix}TextureName = ${textureNameUnion};`);
  tsLines.push(`export interface ${inputsTypeName} {`);
  inputTextureParams.forEach((param) => {
    tsLines.push(`  ${param.textureName}: ShaderSource;`);
  });
  tsLines.push('}');
  tsLines.push('');
  tsLines.push(`export interface ${materialHandlesName} {`);
  tsLines.push('  material: BABYLON.ShaderMaterial;');
  tsLines.push(`  setTexture(name: ${shaderPrefix}TextureName, texture: BABYLON.BaseTexture): void;`);
  tsLines.push(`  setTextureSampler(name: ${shaderPrefix}TextureName, sampler: BABYLON.TextureSampler): void;`);
  tsLines.push(`  setUniforms(uniforms: Partial<${uniformInterfaceName}>): void;`);
  tsLines.push('}');
  tsLines.push('');
  tsLines.push(`export interface ${materialOptionsName} {`);
  tsLines.push('  name?: string;');
  tsLines.push('  passIndex?: number;');
  tsLines.push('}');
  tsLines.push('');
  tsLines.push(`export function create${shaderPrefix}Material(scene: BABYLON.Scene, options: ${materialOptionsName} = {}): ${materialHandlesName} {`);
  tsLines.push('  const passIndex = options.passIndex ?? 0;');
  tsLines.push(`  if (passIndex < 0 || passIndex >= ${passCount}) {`);
  tsLines.push(`    throw new Error(\`Invalid passIndex \${passIndex} for ${shaderPrefix}. Expected 0 <= passIndex < ${passCount}.\`);`);
  tsLines.push('  }');
  tsLines.push(`  const baseName = options.name ?? '${shaderPrefix}Material';`);
  tsLines.push('  const shaderName = `${baseName}_pass${passIndex}`;');
  tsLines.push('  // Register shaders in the WGSL store to enable preprocessor');
  tsLines.push('  const vertexShaderName = `${shaderName}VertexShader`;');
  tsLines.push('  const fragmentShaderName = `${shaderName}FragmentShader`;');
  tsLines.push('  ');
  tsLines.push(`  BABYLON.ShaderStore.ShadersStoreWGSL[vertexShaderName] = ${shaderPrefix}VertexSource;`);
  tsLines.push(`  BABYLON.ShaderStore.ShadersStoreWGSL[fragmentShaderName] = ${shaderPrefix}FragmentSources[passIndex];`);
  tsLines.push('  ');
  tsLines.push('  const material = new BABYLON.ShaderMaterial(shaderName, scene, {');
  tsLines.push('    vertex: shaderName,');
  tsLines.push('    fragment: shaderName,');
  tsLines.push('  }, {');
  tsLines.push(`    attributes: ['position', 'uv'],`);
  tsLines.push(`    uniforms: ${uniformsArrayLiteral},`);
  tsLines.push(`    samplers: ${textureNamesArrayLiteral},`);
  tsLines.push(`    samplerObjects: ${samplerObjectsArrayLiteral},`);
  tsLines.push('    shaderLanguage: BABYLON.ShaderLanguage.WGSL,');
  tsLines.push('  });');
  tsLines.push('');
  tsLines.push(`  const samplerLookup = ${samplerLookupLiteral};`);
  tsLines.push('');
  tsLines.push(`  const handles: ${materialHandlesName} = {`);
  tsLines.push('    material,');
  tsLines.push('    setTexture: (name, texture) => material.setTexture(name, texture),');
  tsLines.push('    setTextureSampler: (name, sampler) => material.setTextureSampler(samplerLookup[name], sampler),');
  if (setUniformsFunctionName) {
    tsLines.push(`    setUniforms: (values) => ${setUniformsFunctionName}(material, values),`);
  } else {
    tsLines.push('    setUniforms: () => {},');
  }
  tsLines.push('  };');
  tsLines.push('');
  tsLines.push('  return handles;');
  tsLines.push('}');
  tsLines.push('');

  const effectLines: string[] = [];
  effectLines.push(`export class ${effectClassName} extends CustomShaderEffect<${uniformInterfaceName}, ${inputsTypeName}> {`);
  effectLines.push(`  effectName = '${shaderPrefix}'`);
  effectLines.push('');
  effectLines.push(`  constructor(engine: BABYLON.WebGPUEngine, inputs: ${inputsTypeName}, width = 1280, height = 720, sampleMode: 'nearest' | 'linear' = 'linear', precision: RenderPrecision = 'half_float') {`);
  effectLines.push('    super(engine, inputs, {');
  effectLines.push(`      factory: (sceneRef, options) => create${shaderPrefix}Material(sceneRef, options),`);
  effectLines.push(`      textureInputKeys: ${inputTextureNamesArrayLiteral},`);
  effectLines.push(`      textureBindingKeys: ${textureNamesArrayLiteral},`);
  effectLines.push(`      passTextureSources: ${shaderPrefix}PassTextureSources,`);
  effectLines.push(`      passCount: ${passCount},`);
  effectLines.push(`      primaryTextureKey: '${primaryTextureName}',`);
  effectLines.push('      width,');
  effectLines.push('      height,');
  effectLines.push(`      materialName: '${shaderPrefix}Material',`);
  effectLines.push('      sampleMode,');
  effectLines.push('      precision,');
  effectLines.push(`      uniformMeta: ${uniformMetaConstName},`);
  effectLines.push('    })');
  const fieldsWithDefaults = uniformFields.filter((field) => field.defaultExpression);
  if (fieldsWithDefaults.length > 0) {
    effectLines.push('    this.setUniforms({');
    fieldsWithDefaults.forEach((field) => {
      effectLines.push(`      ${field.name}: ${field.defaultExpression},`);
    });
    effectLines.push('    });');
  } else {
    const uniformNames = new Set(uniformFields.map((field) => field.name));
    const hasTransformDefaults = ['rotate', 'anchor', 'translate', 'scale'].every((name) => uniformNames.has(name));
    if (hasTransformDefaults) {
      effectLines.push('    this.setUniforms({ rotate: 0, anchor: [0.5, 0.5], translate: [0, 0], scale: [1, 1] });');
    }
  }
  effectLines.push('  }');

  effectLines.push('');
  effectLines.push(`  override setSrcs(inputs: Partial<${inputsTypeName}>): void {`);
  effectLines.push('    super.setSrcs(inputs);');
  effectLines.push('  }');

  if (uniformFields.length > 0) {
    const uniformParams = uniformFields
      .map((field) => {
        if (field.isArray && field.elementType) {
          const arrayMeta = ARRAY_ELEMENT_TYPE_MAP[field.elementType];
          return `${field.name}?: Dynamic<${arrayMeta.tsType}>`;
        }
        const meta = UNIFORM_TYPE_MAP[field.wgslType];
        return `${field.name}?: Dynamic<${meta.tsType}>`;
      })
      .join(', ');
    effectLines.push('');
    effectLines.push(`  override setUniforms(uniforms: { ${uniformParams} }): void {`);
    effectLines.push('    const record: ShaderUniforms = {};');
    uniformFields.forEach((field) => {
      effectLines.push(`    if (uniforms.${field.name} !== undefined) {`);
      effectLines.push(`      record['${field.name}'] = uniforms.${field.name};`);
      effectLines.push('    }');
    });
    effectLines.push('    super.setUniforms(record);');
    effectLines.push('  }');
  }

  effectLines.push('}');
  effectLines.push('');
  tsLines.push(...effectLines);

  const typesSource = `${tsLines.join('\n')}\n`;

  return {
    typesSource,
    shaderPrefix,
    effectClassName,
    uniformInterfaceName,
  };
}

export interface FragmentShaderErrorArtifactOptions {
  effectClassName: string;
  uniformInterfaceName: string;
  shaderPrefix: string;
  relativeSourcePath: string;
  errorMessage: string;
}

export function buildFragmentShaderErrorArtifactSource(options: FragmentShaderErrorArtifactOptions): string {
  const { effectClassName, uniformInterfaceName, shaderPrefix, relativeSourcePath, errorMessage } = options;
  const materialHandlesName = `${shaderPrefix}MaterialHandles`;
  const materialOptionsName = `${shaderPrefix}MaterialOptions`;
  const inputsTypeName = `${shaderPrefix}Inputs`;
  const textureNameType = `${shaderPrefix}TextureName`;
  const message = `Failed to generate shader for ${relativeSourcePath}: ${errorMessage}`;
  const lines: string[] = [];
  lines.push(HEADER_COMMENT);
  lines.push(`export const shaderGenerationErrorMessage = ${JSON.stringify(message)} as const;`);
  lines.push(`export type ${uniformInterfaceName} = never;`);
  lines.push(`export type ${textureNameType} = never;`);
  lines.push(`export interface ${inputsTypeName} {}`);
  lines.push(`export type ${materialHandlesName} = never;`);
  lines.push(`export interface ${materialOptionsName} { name?: string }`);
  lines.push(`export function create${shaderPrefix}Material(): never { throw new Error(shaderGenerationErrorMessage); }`);
  lines.push(`export class ${effectClassName} {`);
  lines.push('  constructor() {');
  lines.push('    throw new Error(shaderGenerationErrorMessage);');
  lines.push('  }');
  lines.push('}');
  lines.push('');
  return `${lines.join('\n')}\n`;
}
