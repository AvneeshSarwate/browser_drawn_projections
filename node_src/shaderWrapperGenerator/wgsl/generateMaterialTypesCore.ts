import { ArgumentInfo, StructInfo, WgslReflect } from 'wgsl_reflect';

export const RAW_SUFFIX = '.material.wgsl';
export const OUTPUT_SUFFIX = '.generated.ts';

const HEADER_COMMENT = '// Auto-generated by power2d material generator. DO NOT EDIT.';
const SHAPE_TRANSLATE_UNIFORM = 'power2d_shapeTranslate';
const SHAPE_ROTATION_UNIFORM = 'power2d_shapeRotation';
const SHAPE_SCALE_UNIFORM = 'power2d_shapeScale';

interface UniformField {
  name: string;
  bindingName: string;
  wgslType: string;
}

interface UniformTypeMetadata {
  tsType: string;
  setter: string;
  expression: (valueRef: string) => string;
  helper?: string;
  defaultValue: string;
}

interface TextureParam {
  textureName: string;
  samplerName: string;
}

interface InstanceField {
  name: string;
  wgslType: string;
  tsType: string;
  attributeType: string;
  floatCount: number;
}

interface InstanceLayout {
  fields: InstanceField[];
  totalFloats: number;
}

const UNIFORM_TYPE_MAP: Record<string, UniformTypeMetadata> = {
  f32: {
    tsType: 'number',
    setter: 'setFloat',
    expression: (valueRef) => valueRef,
    defaultValue: '0',
  },
  i32: {
    tsType: 'number',
    setter: 'setInt',
    expression: (valueRef) => valueRef,
    defaultValue: '0',
  },
  u32: {
    tsType: 'number',
    setter: 'setUInt',
    expression: (valueRef) => valueRef,
    defaultValue: '0',
  },
  bool: {
    tsType: 'boolean',
    setter: 'setFloat',
    expression: (valueRef) => `(${valueRef} ? 1 : 0)`,
    defaultValue: 'false',
  },
  vec2f: {
    tsType: 'BABYLON.Vector2 | readonly [number, number]',
    setter: 'setVector2',
    expression: (valueRef) => `ensureVector2(${valueRef})`,
    helper: 'ensureVector2',
    defaultValue: '[0, 0]',
  },
  vec3f: {
    tsType: 'BABYLON.Vector3 | readonly [number, number, number]',
    setter: 'setVector3',
    expression: (valueRef) => `ensureVector3(${valueRef})`,
    helper: 'ensureVector3',
    defaultValue: '[0, 0, 0]',
  },
  vec4f: {
    tsType: 'BABYLON.Vector4 | readonly [number, number, number, number]',
    setter: 'setVector4',
    expression: (valueRef) => `ensureVector4(${valueRef})`,
    helper: 'ensureVector4',
    defaultValue: '[0, 0, 0, 0]',
  },
  mat4x4f: {
    tsType: 'BABYLON.Matrix | Float32Array | readonly number[]',
    setter: 'setMatrix',
    expression: (valueRef) => `ensureMatrix(${valueRef})`,
    helper: 'ensureMatrix',
    defaultValue: 'new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])',
  },
};

const INSTANCE_TYPE_MAP: Record<string, { tsType: string; attributeType: string; floatCount: number }> = {
  f32: { tsType: 'number', attributeType: 'f32', floatCount: 1 },
  vec2f: { tsType: 'readonly [number, number]', attributeType: 'vec2<f32>', floatCount: 2 },
  vec3f: { tsType: 'readonly [number, number, number]', attributeType: 'vec3<f32>', floatCount: 3 },
  vec4f: { tsType: 'readonly [number, number, number, number]', attributeType: 'vec4<f32>', floatCount: 4 },
};

const HELPER_SNIPPETS: Record<string, string> = {
  ensureVector2: `function ensureVector2(value: BABYLON.Vector2 | readonly [number, number]): BABYLON.Vector2 {\n  return value instanceof BABYLON.Vector2 ? value : BABYLON.Vector2.FromArray(value as readonly [number, number]);\n}`,
  ensureVector3: `function ensureVector3(value: BABYLON.Vector3 | readonly [number, number, number]): BABYLON.Vector3 {\n  return value instanceof BABYLON.Vector3 ? value : BABYLON.Vector3.FromArray(value as readonly [number, number, number]);\n}`,
  ensureVector4: `function ensureVector4(value: BABYLON.Vector4 | readonly [number, number, number, number]): BABYLON.Vector4 {\n  return value instanceof BABYLON.Vector4 ? value : BABYLON.Vector4.FromArray(value as readonly [number, number, number, number]);\n}`,
  ensureMatrix: `function ensureMatrix(value: BABYLON.Matrix | Float32Array | readonly number[]): BABYLON.Matrix {\n  if (value instanceof BABYLON.Matrix) {\n    return value;\n  }\n  const matrix = BABYLON.Matrix.Identity();\n  matrix.copyFromArray(Array.from(value));\n  return matrix;\n}`,
};

function toPascalCase(value: string): string {
  return value
    .replace(/[-_]/g, ' ')
    .split(' ')
    .filter(Boolean)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
}

function escapeTemplateLiteral(value: string): string {
  return `\`${value
    .replace(/\\/g, '\\\\')
    .replace(/`/g, '\\`')
    .replace(/\$\{/g, '\\${')}\``;
}

function validateType(argument: ArgumentInfo, expected: string, label: string): void {
  const typeName = argument.type.getTypeName();
  if (typeName !== expected) {
    throw new Error(`${label} must be ${expected}. Received ${argument.name}: ${typeName}`);
  }
}

function collectUniformFields(struct: StructInfo, uniformArgName: string): UniformField[] {
  return struct.members.map((member) => {
    if (member.type.isStruct || member.type.isArray) {
      throw new Error(`Uniform field ${member.name} uses unsupported type ${member.type.getTypeName()}. Nested structs/arrays are not supported.`);
    }
    const typeName = member.type.getTypeName();
    if (!UNIFORM_TYPE_MAP[typeName]) {
      throw new Error(`Uniform field ${member.name} uses unsupported type ${typeName}.`);
    }
    return {
      name: member.name,
      bindingName: `${uniformArgName}_${member.name}`,
      wgslType: typeName,
    };
  });
}

function collectInstanceLayout(struct: StructInfo): InstanceLayout {
  const fields: InstanceField[] = [];
  let offset = 0;
  for (const member of struct.members) {
    if (member.type.isStruct || member.type.isArray) {
      throw new Error(`Instance field ${member.name} uses unsupported type ${member.type.getTypeName()}. Nested structs/arrays are not supported.`);
    }
    const typeName = member.type.getTypeName();
    const meta = INSTANCE_TYPE_MAP[typeName];
    if (!meta) {
      throw new Error(`Instance field ${member.name} uses unsupported type ${typeName}.`);
    }
    fields.push({
      name: member.name,
      wgslType: typeName,
      tsType: meta.tsType,
      attributeType: meta.attributeType,
      floatCount: meta.floatCount,
    });
    offset += meta.floatCount;
  }
  return { fields, totalFloats: offset };
}

function parseTextureParams(args: ArgumentInfo[], startIndex: number, functionName: string): TextureParam[] {
  const params: TextureParam[] = [];
  const seenTextures = new Set<string>();

  for (let index = startIndex; index < args.length; index += 2) {
    const textureArg = args[index];
    const samplerArg = args[index + 1];

    if (!textureArg || !samplerArg) {
      throw new Error(`Texture parameters in ${functionName} must be provided in texture/sampler pairs.`);
    }

    const textureType = textureArg.type.getTypeName();
    if (textureType !== 'texture_2d<f32>') {
      throw new Error(`Texture argument must be texture_2d<f32>. Received ${textureArg.name}: ${textureType}`);
    }

    const samplerType = samplerArg.type.getTypeName();
    if (samplerType !== 'sampler') {
      throw new Error(`Expected sampler after texture ${textureArg.name}, but got ${samplerArg.name}: ${samplerType}. Texture parameters must be provided in texture/sampler pairs.`);
    }

    if (seenTextures.has(textureArg.name)) {
      throw new Error(`Duplicate texture parameter ${textureArg.name} detected.`);
    }
    seenTextures.add(textureArg.name);

    params.push({
      textureName: textureArg.name,
      samplerName: samplerArg.name,
    });
  }

  return params;
}

function generateUniformStructConstruction(struct: StructInfo, fields: UniformField[]): string {
  if (fields.length === 0) {
    return `fn load_${struct.name}() -> ${struct.name} {\n  return ${struct.name}();\n}`;
  }
  const ctorArguments = fields.map((field) => `  uniforms.${field.bindingName}`).join(',\n');
  return `fn load_${struct.name}() -> ${struct.name} {\n  return ${struct.name}(\n${ctorArguments}\n  );\n}`;
}

function generateInstanceStructConstruction(struct: StructInfo, fields: InstanceField[], source: 'vertex' | 'fragment'): string {
  if (fields.length === 0) {
    return '';
  }
  const prefix = source === 'vertex' ? 'vertexInputs.inst_' : 'fragmentInputs.vInst_';
  const ctorArguments = fields.map((field) => `  ${prefix}${field.name}`).join(',\n');
  return `fn load_${struct.name}_${source}() -> ${struct.name} {\n  return ${struct.name}(\n${ctorArguments}\n  );\n}`;
}

function buildVertexSource(options: {
  shaderCode: string;
  uniformStruct: StructInfo;
  uniformFields: UniformField[];
  uniformLoaderFn: string;
  instanceStruct?: StructInfo;
  instanceLayout?: InstanceLayout;
  useInstanceInFragment: boolean;
}): string {
  const { shaderCode, uniformStruct, uniformFields, uniformLoaderFn, instanceStruct, instanceLayout, useInstanceInFragment } = options;
  const lines: string[] = [];
  lines.push(HEADER_COMMENT);
  lines.push('attribute position: vec3<f32>;');
  lines.push('attribute uv: vec2<f32>;');
  if (instanceStruct && instanceLayout) {
    for (const field of instanceLayout.fields) {
      lines.push(`attribute inst_${field.name}: ${field.attributeType};`);
    }
  }
  lines.push('varying vUV: vec2<f32>;');
  if (instanceStruct && instanceLayout && useInstanceInFragment) {
    for (const field of instanceLayout.fields) {
      lines.push(`varying vInst_${field.name}: ${field.attributeType};`);
    }
  }
  uniformFields.forEach((field) => {
    lines.push(`uniform ${field.bindingName}: ${field.wgslType};`);
  });
  lines.push(`uniform ${SHAPE_TRANSLATE_UNIFORM}: vec2f;`);
  lines.push(`uniform ${SHAPE_ROTATION_UNIFORM}: f32;`);
  lines.push(`uniform ${SHAPE_SCALE_UNIFORM}: vec2f;`);
  lines.push('uniform power2d_canvasWidth: f32;');
  lines.push('uniform power2d_canvasHeight: f32;');
  lines.push('');
  lines.push(shaderCode.trimEnd());
  lines.push('');
  lines.push(uniformLoaderFn);
  lines.push('');
  if (instanceStruct && instanceLayout) {
    lines.push(generateInstanceStructConstruction(instanceStruct, instanceLayout.fields, 'vertex'));
    lines.push('');
  }
  lines.push('fn power2d_applyShapeTransform(pixel: vec2f) -> vec2f {');
  lines.push(`  let scaled = pixel * uniforms.${SHAPE_SCALE_UNIFORM};`);
  lines.push(`  let s = sin(uniforms.${SHAPE_ROTATION_UNIFORM});`);
  lines.push(`  let c = cos(uniforms.${SHAPE_ROTATION_UNIFORM});`);
  lines.push('  let rotated = vec2f(');
  lines.push('    scaled.x * c - scaled.y * s,');
  lines.push('    scaled.x * s + scaled.y * c,');
  lines.push('  );');
  lines.push(`  return rotated + uniforms.${SHAPE_TRANSLATE_UNIFORM};`);
  lines.push('}');
  lines.push('');
  lines.push('fn power2d_pixelToNDC(pixel: vec2f) -> vec4f {');
  lines.push('  let ndcX = (pixel.x / uniforms.power2d_canvasWidth) * 2.0 - 1.0;');
  lines.push('  let ndcY = -((pixel.y / uniforms.power2d_canvasHeight) * 2.0 - 1.0);');
  lines.push('  return vec4f(ndcX, ndcY, 0.0, 1.0);');
  lines.push('}');
  lines.push('');
  lines.push('#define CUSTOM_VERTEX_DEFINITIONS');
  lines.push('@vertex');
  lines.push('fn main(input : VertexInputs) -> FragmentInputs {');
  lines.push('#define CUSTOM_VERTEX_MAIN_BEGIN');
  lines.push(`  let uniformsValue = load_${uniformStruct.name}();`);
  if (instanceStruct) {
    lines.push(`  let instValue = load_${instanceStruct.name}_vertex();`);
  }
  lines.push('  let pixelPos = vec2f(vertexInputs.position.x, vertexInputs.position.y);');
  lines.push('  let uv = vertexInputs.uv;');
  const vertArgs = ['pixelPos', 'uv', 'uniformsValue'];
  if (instanceStruct) {
    vertArgs.push('instValue');
  }
  lines.push(`  let adjustedPixelPos = vertShader(${vertArgs.join(', ')});`);
  lines.push('  let transformedPixelPos = power2d_applyShapeTransform(adjustedPixelPos);');
  lines.push('  vertexOutputs.position = power2d_pixelToNDC(transformedPixelPos);');
  lines.push('  vertexOutputs.vUV = uv;');
  if (instanceStruct && instanceLayout && useInstanceInFragment) {
    for (const field of instanceLayout.fields) {
      lines.push(`  vertexOutputs.vInst_${field.name} = vertexInputs.inst_${field.name};`);
    }
  }
  lines.push('#define CUSTOM_VERTEX_MAIN_END');
  lines.push('}');
  lines.push('');
  return `${lines.join('\n')}\n`;
}

function buildFragmentSource(options: {
  shaderCode: string;
  uniformStruct: StructInfo;
  uniformFields: UniformField[];
  uniformLoaderFn: string;
  textureParams: TextureParam[];
  instanceStruct?: StructInfo;
  instanceLayout?: InstanceLayout;
  useInstanceInFragment: boolean;
}): string {
  const { shaderCode, uniformStruct, uniformFields, uniformLoaderFn, textureParams, instanceStruct, instanceLayout, useInstanceInFragment } = options;
  const lines: string[] = [];
  lines.push(HEADER_COMMENT);
  lines.push('varying vUV: vec2<f32>;');
  if (instanceStruct && instanceLayout && useInstanceInFragment) {
    for (const field of instanceLayout.fields) {
      lines.push(`varying vInst_${field.name}: ${field.attributeType};`);
    }
  }
  uniformFields.forEach((field) => {
    lines.push(`uniform ${field.bindingName}: ${field.wgslType};`);
  });
  lines.push(`uniform ${SHAPE_TRANSLATE_UNIFORM}: vec2f;`);
  lines.push(`uniform ${SHAPE_ROTATION_UNIFORM}: f32;`);
  lines.push(`uniform ${SHAPE_SCALE_UNIFORM}: vec2f;`);
  lines.push('uniform power2d_canvasWidth: f32;');
  lines.push('uniform power2d_canvasHeight: f32;');
  textureParams.forEach((param) => {
    lines.push(`var ${param.textureName}: texture_2d<f32>;`);
    lines.push(`var ${param.samplerName}: sampler;`);
  });
  lines.push('');
  lines.push(shaderCode.trimEnd());
  lines.push('');
  lines.push(uniformLoaderFn);
  lines.push('');
  if (instanceStruct && instanceLayout && useInstanceInFragment) {
    lines.push(generateInstanceStructConstruction(instanceStruct, instanceLayout.fields, 'fragment'));
    lines.push('');
  }
  lines.push('#define CUSTOM_FRAGMENT_DEFINITIONS');
  lines.push('@fragment');
  lines.push('fn main(input: FragmentInputs) -> FragmentOutputs {');
  lines.push('#define CUSTOM_FRAGMENT_MAIN_BEGIN');
  lines.push('  let uv = fragmentInputs.vUV;');
  lines.push(`  let uniformsValue = load_${uniformStruct.name}();`);
  const args: string[] = ['uv', 'uniformsValue'];
  if (instanceStruct && useInstanceInFragment) {
    lines.push(`  let instValue = load_${instanceStruct.name}_fragment();`);
    args.push('instValue');
  }
  textureParams.forEach((param) => {
    args.push(param.textureName);
    args.push(param.samplerName);
  });
  lines.push(`  let color = fragShader(${args.join(', ')});`);
  lines.push('  fragmentOutputs.color = color;');
  lines.push('#define CUSTOM_FRAGMENT_MAIN_END');
  lines.push('}');
  lines.push('');
  return `${lines.join('\n')}\n`;
}

export interface GenerateMaterialTypesSourceResult {
  typesSource: string;
}

export function generateMaterialTypesSource(shaderCode: string, shaderBaseName: string): GenerateMaterialTypesSourceResult {
  const shaderPrefix = toPascalCase(shaderBaseName);

  const reflect = new WgslReflect(shaderCode);

  const vertFn = reflect.functions.find((fn) => fn.name === 'vertShader' && !fn.stage);
  const fragFn = reflect.functions.find((fn) => fn.name === 'fragShader' && !fn.stage);
  if (!vertFn) {
    throw new Error('Missing vertShader function.');
  }
  if (!fragFn) {
    throw new Error('Missing fragShader function.');
  }

  if (vertFn.arguments.length !== 3 && vertFn.arguments.length !== 4) {
    throw new Error('vertShader must declare 3 arguments (position, uv, uniforms) or 4 arguments (position, uv, uniforms, instance).');
  }

  validateType(vertFn.arguments[0], 'vec2f', 'vertShader position argument');
  validateType(vertFn.arguments[1], 'vec2f', 'vertShader uv argument');

  const uniformArg = vertFn.arguments[2];
  const uniformStruct = reflect.structs.find((entry) => entry.name === uniformArg.type.getTypeName());
  if (!uniformStruct) {
    throw new Error(`Uniform struct ${uniformArg.type.getTypeName()} not found.`);
  }

  let instanceStruct: StructInfo | undefined;
  if (vertFn.arguments.length === 4) {
    const instanceArg = vertFn.arguments[3];
    instanceStruct = reflect.structs.find((entry) => entry.name === instanceArg.type.getTypeName());
    if (!instanceStruct) {
      throw new Error(`Instance struct ${instanceArg.type.getTypeName()} not found.`);
    }
  }

  const uniformFields = collectUniformFields(uniformStruct, uniformArg.name);
  const uniformLoaderFn = generateUniformStructConstruction(uniformStruct, uniformFields);

  if (fragFn.arguments.length < 2) {
    throw new Error('fragShader must declare at least 2 arguments (uv, uniforms).');
  }

  validateType(fragFn.arguments[0], 'vec2f', 'fragShader uv argument');
  const fragUniformArg = fragFn.arguments[1];
  if (fragUniformArg.type.getTypeName() !== uniformStruct.name) {
    throw new Error(`fragShader uniforms must use struct ${uniformStruct.name}.`);
  }

  let resourceStartIndex = 2;
  let useInstanceInFragment = false;
  let instanceLayout: InstanceLayout | undefined;
  if (instanceStruct) {
    if (fragFn.arguments.length < 3) {
      throw new Error('fragShader must declare instance argument when vertShader does.');
    }
    const fragInstanceArg = fragFn.arguments[2];
    if (fragInstanceArg.type.getTypeName() !== instanceStruct.name) {
      throw new Error(`fragShader instance must use struct ${instanceStruct.name}.`);
    }
    useInstanceInFragment = true;
    resourceStartIndex = 3;
    instanceLayout = collectInstanceLayout(instanceStruct);
  }

  const textureParams = parseTextureParams(fragFn.arguments, resourceStartIndex, 'fragShader');

  const vertexSource = buildVertexSource({
    shaderCode,
    uniformStruct,
    uniformFields,
    uniformLoaderFn,
    instanceStruct,
    instanceLayout,
    useInstanceInFragment,
  });

  const fragmentSource = buildFragmentSource({
    shaderCode,
    uniformStruct,
    uniformFields,
    uniformLoaderFn,
    textureParams,
    instanceStruct,
    instanceLayout,
    useInstanceInFragment,
  });

  const uniformInterfaceName = uniformStruct.name;
  const helperNames = new Set<string>();
  const uniformInterfaceLines: string[] = [];
  const uniformSetterLines: string[] = [];

  uniformInterfaceLines.push(`export interface ${uniformInterfaceName} {`);
  for (const field of uniformFields) {
    const meta = UNIFORM_TYPE_MAP[field.wgslType];
    if (!meta) {
      throw new Error(`Unsupported uniform field type ${field.wgslType}.`);
    }
    uniformInterfaceLines.push(`  ${field.name}: ${meta.tsType};`);
    if (meta.helper) {
      helperNames.add(meta.helper);
    }
  }
  uniformInterfaceLines.push('}');

  uniformSetterLines.push(`export function set${uniformInterfaceName}(material: BABYLON.ShaderMaterial, uniforms: Partial<${uniformInterfaceName}>): void {`);
  uniformSetterLines.push('  if (!uniforms) {');
  uniformSetterLines.push('    return;');
  uniformSetterLines.push('  }');
  for (const field of uniformFields) {
    const meta = UNIFORM_TYPE_MAP[field.wgslType];
    uniformSetterLines.push(`  if (uniforms.${field.name} !== undefined) {`);
    uniformSetterLines.push(`    material.${meta.setter}('${field.bindingName}', ${meta.expression(`uniforms.${field.name}`)});`);
    uniformSetterLines.push('  }');
  }
  uniformSetterLines.push('}');

  const helperBlocks = Array.from(helperNames).map((name) => HELPER_SNIPPETS[name]);

  const uniformDefaultsLines: string[] = [];
  uniformDefaultsLines.push(`export const ${shaderPrefix}UniformDefaults: ${uniformInterfaceName} = {`);
  for (const field of uniformFields) {
    const meta = UNIFORM_TYPE_MAP[field.wgslType];
    uniformDefaultsLines.push(`  ${field.name}: ${meta.defaultValue},`);
  }
  uniformDefaultsLines.push('};');

  const uniformMetaLines: string[] = [];
  uniformMetaLines.push(`export const ${shaderPrefix}UniformMeta = [`);
  for (const field of uniformFields) {
    uniformMetaLines.push('  {');
    uniformMetaLines.push(`    name: '${field.name}',`);
    uniformMetaLines.push(`    kind: '${field.wgslType}',`);
    uniformMetaLines.push(`    bindingName: '${field.bindingName}',`);
    uniformMetaLines.push('  },');
  }
  uniformMetaLines.push('] as const;');

  const textureNames = textureParams.map((param) => param.textureName);
  const textureNameUnion = textureNames.length ? textureNames.map((name) => `'${name}'`).join(' | ') : 'never';
  const textureNamesLiteral = textureNames.length ? `[${textureNames.map((name) => `'${name}'`).join(', ')}] as const` : '[] as const';

  const samplerNames = textureParams.map((param) => param.samplerName);
  const samplerLookupEntries = textureParams
    .map((param) => `'${param.textureName}': '${param.samplerName}'`)
    .join(', ');

  const materialInterfaceName = `${shaderPrefix}MaterialDef`;
  const materialInstanceName = `${shaderPrefix}MaterialInstance`;
  const materialConstName = `${shaderPrefix}Material`;

  const materialInterfaceLines: string[] = [];
  materialInterfaceLines.push(`export interface ${materialInterfaceName} {`);
  materialInterfaceLines.push(`  readonly uniformType: ${uniformInterfaceName};`);
  materialInterfaceLines.push(`  readonly textureNames: readonly ${textureNameUnion}[];`);
  materialInterfaceLines.push('  readonly vertexSource: string;');
  materialInterfaceLines.push('  readonly fragmentSource: string;');
  materialInterfaceLines.push(`  readonly uniformMeta: typeof ${shaderPrefix}UniformMeta;`);
  materialInterfaceLines.push(`  readonly uniformDefaults: ${uniformInterfaceName};`);
  if (instanceLayout && instanceStruct) {
    materialInterfaceLines.push(`  readonly instanceAttrLayout: InstanceAttrLayout<${instanceStruct.name}>;`);
  }
  materialInterfaceLines.push(`  readonly createMaterial: (scene: BABYLON.Scene, name?: string) => ${materialInstanceName};`);
  materialInterfaceLines.push('}');

  const materialInstanceLines: string[] = [];
  materialInstanceLines.push(`export interface ${materialInstanceName} {`);
  materialInstanceLines.push('  material: BABYLON.ShaderMaterial;');
  materialInstanceLines.push(`  setUniforms(uniforms: Partial<${uniformInterfaceName}>): void;`);
  materialInstanceLines.push(`  setTexture(name: ${shaderPrefix}TextureName, texture: BABYLON.BaseTexture): void;`);
  if (textureParams.length > 0) {
    materialInstanceLines.push(`  setTextureSampler(name: ${shaderPrefix}TextureName, sampler: BABYLON.TextureSampler): void;`);
  }
  materialInstanceLines.push('  setCanvasSize(width: number, height: number): void;');
  materialInstanceLines.push('  dispose(): void;');
  materialInstanceLines.push('}');

  const instanceLayoutLines: string[] = [];
  if (instanceLayout && instanceStruct) {
    instanceLayoutLines.push(`export interface ${instanceStruct.name} {`);
    for (const field of instanceLayout.fields) {
      instanceLayoutLines.push(`  ${field.name}: ${field.tsType};`);
    }
    instanceLayoutLines.push('}');
    instanceLayoutLines.push('');
    instanceLayoutLines.push('export interface InstanceAttrLayout<I> {');
    instanceLayoutLines.push('  size: number;');
    instanceLayoutLines.push('  members: Array<{');
    instanceLayoutLines.push('    name: keyof I;');
    instanceLayoutLines.push('    offset: number;');
    instanceLayoutLines.push('    floatCount: number;');
    instanceLayoutLines.push('  }>;');
    instanceLayoutLines.push('}');
    instanceLayoutLines.push('');
    instanceLayoutLines.push(`export const ${shaderPrefix}InstanceAttrLayout: InstanceAttrLayout<${instanceStruct.name}> = {`);
    instanceLayoutLines.push(`  size: ${instanceLayout.totalFloats},`);
    instanceLayoutLines.push('  members: [');
    let offset = 0;
    for (const field of instanceLayout.fields) {
      instanceLayoutLines.push(`    { name: '${field.name}', offset: ${offset}, floatCount: ${field.floatCount} },`);
      offset += field.floatCount;
    }
    instanceLayoutLines.push('  ],');
    instanceLayoutLines.push('};');
  }

  const attributesList = ['position', 'uv'];
  if (instanceLayout) {
    for (const field of instanceLayout.fields) {
      attributesList.push(`inst_${field.name}`);
    }
  }

  const uniformsList = uniformFields.map((field) => `'${field.bindingName}'`);
  uniformsList.push(
    `'${SHAPE_TRANSLATE_UNIFORM}'`,
    `'${SHAPE_ROTATION_UNIFORM}'`,
    `'${SHAPE_SCALE_UNIFORM}'`,
    "'power2d_canvasWidth'",
    "'power2d_canvasHeight'",
  );

  const defaultSamplerLines: string[] = [];
  if (textureParams.length > 0) {
    defaultSamplerLines.push('  const defaultSampler = new BABYLON.TextureSampler();');
    defaultSamplerLines.push('  defaultSampler.setParameters(');
    defaultSamplerLines.push('    BABYLON.Texture.CLAMP_ADDRESSMODE,');
    defaultSamplerLines.push('    BABYLON.Texture.CLAMP_ADDRESSMODE,');
    defaultSamplerLines.push('    BABYLON.Texture.CLAMP_ADDRESSMODE,');
    defaultSamplerLines.push('    undefined,');
    defaultSamplerLines.push('    BABYLON.Texture.BILINEAR_SAMPLINGMODE,');
    defaultSamplerLines.push('  );');
    for (const samplerName of samplerNames) {
      defaultSamplerLines.push(`  material.setTextureSampler('${samplerName}', defaultSampler);`);
    }
  }

  const createMaterialLines: string[] = [];
  createMaterialLines.push(`export function create${shaderPrefix}Material(scene: BABYLON.Scene, name: string = '${shaderPrefix}Material'): ${materialInstanceName} {`);
  createMaterialLines.push('  const vertexShaderName = `${name}VertexShader`;');
  createMaterialLines.push('  const fragmentShaderName = `${name}FragmentShader`;');
  createMaterialLines.push('');
  createMaterialLines.push('  BABYLON.ShaderStore.ShadersStoreWGSL[vertexShaderName] = ' + `${shaderPrefix}VertexSource;`);
  createMaterialLines.push('  BABYLON.ShaderStore.ShadersStoreWGSL[fragmentShaderName] = ' + `${shaderPrefix}FragmentSource;`);
  createMaterialLines.push('');
  createMaterialLines.push('  const material = new BABYLON.ShaderMaterial(name, scene, {');
  createMaterialLines.push('    vertex: name,');
  createMaterialLines.push('    fragment: name,');
  createMaterialLines.push('  }, {');
  createMaterialLines.push(`    attributes: [${attributesList.map((attr) => `'${attr}'`).join(', ')}],`);
  createMaterialLines.push(`    uniforms: [${uniformsList.join(', ')}],`);
  createMaterialLines.push(`    samplers: [${textureNames.map((name) => `'${name}'`).join(', ')}],`);
  createMaterialLines.push(`    samplerObjects: [${samplerNames.map((name) => `'${name}'`).join(', ')}],`);
  createMaterialLines.push('    shaderLanguage: BABYLON.ShaderLanguage.WGSL,');
  createMaterialLines.push('  });');
  createMaterialLines.push('');
  if (defaultSamplerLines.length > 0) {
    createMaterialLines.push(...defaultSamplerLines);
    createMaterialLines.push('');
  }
  if (uniformFields.length > 0) {
    createMaterialLines.push(`  set${uniformInterfaceName}(material, ${shaderPrefix}UniformDefaults);`);
  }
  createMaterialLines.push(`  material.setVector2('${SHAPE_TRANSLATE_UNIFORM}', new BABYLON.Vector2(0, 0));`);
  createMaterialLines.push(`  material.setFloat('${SHAPE_ROTATION_UNIFORM}', 0);`);
  createMaterialLines.push(`  material.setVector2('${SHAPE_SCALE_UNIFORM}', new BABYLON.Vector2(1, 1));`);
  createMaterialLines.push('  material.disableDepthWrite = true;');
  createMaterialLines.push('  material.depthFunction = BABYLON.Constants.ALWAYS;');
  createMaterialLines.push('  material.backFaceCulling = false;');
  createMaterialLines.push('  material.alphaMode = BABYLON.Engine.ALPHA_COMBINE;');
  createMaterialLines.push('');
  if (textureParams.length > 0) {
    createMaterialLines.push(`  const samplerLookup = { ${samplerLookupEntries} } as const;`);
    createMaterialLines.push('');
  }
  createMaterialLines.push(`  const handles: ${materialInstanceName} = {`);
  createMaterialLines.push('    material,');
  createMaterialLines.push(`    setUniforms: (uniforms) => set${uniformInterfaceName}(material, uniforms),`);
  createMaterialLines.push('    setTexture: (name, texture) => material.setTexture(name, texture),');
  if (textureParams.length > 0) {
    createMaterialLines.push('    setTextureSampler: (name, sampler) => {');
    createMaterialLines.push('      const samplerName = (samplerLookup as Record<string, string | undefined>)[name];');
    createMaterialLines.push('      if (samplerName) {');
    createMaterialLines.push('        material.setTextureSampler(samplerName, sampler);');
    createMaterialLines.push('      }');
    createMaterialLines.push('    },');
  }
  createMaterialLines.push('    setCanvasSize: (width, height) => {');
  createMaterialLines.push('      material.setFloat(\'power2d_canvasWidth\', width);');
  createMaterialLines.push('      material.setFloat(\'power2d_canvasHeight\', height);');
  createMaterialLines.push('    },');
  createMaterialLines.push('    dispose: () => {');
  createMaterialLines.push('      material.dispose(true, false);');
  createMaterialLines.push('      delete BABYLON.ShaderStore.ShadersStoreWGSL[vertexShaderName];');
  createMaterialLines.push('      delete BABYLON.ShaderStore.ShadersStoreWGSL[fragmentShaderName];');
  createMaterialLines.push('    },');
  createMaterialLines.push('  };');
  createMaterialLines.push('');
  createMaterialLines.push('  return handles;');
  createMaterialLines.push('}');

  const materialDefLines: string[] = [];
  materialDefLines.push(`export const ${materialConstName}: ${materialInterfaceName} = {`);
  materialDefLines.push(`  uniformType: undefined as unknown as ${uniformInterfaceName},`);
  materialDefLines.push(`  textureNames: ${shaderPrefix}TextureNames,`);
  materialDefLines.push(`  vertexSource: ${shaderPrefix}VertexSource,`);
  materialDefLines.push(`  fragmentSource: ${shaderPrefix}FragmentSource,`);
  materialDefLines.push(`  uniformMeta: ${shaderPrefix}UniformMeta,`);
  materialDefLines.push(`  uniformDefaults: ${shaderPrefix}UniformDefaults,`);
  if (instanceLayout && instanceStruct) {
    materialDefLines.push(`  instanceAttrLayout: ${shaderPrefix}InstanceAttrLayout,`);
  }
  materialDefLines.push(`  createMaterial: create${shaderPrefix}Material,`);
  materialDefLines.push('};');

  const tsLines: string[] = [];
  tsLines.push(HEADER_COMMENT);
  tsLines.push(`import * as BABYLON from 'babylonjs';`);
  tsLines.push('');
  tsLines.push(`export const ${shaderPrefix}VertexSource = ${escapeTemplateLiteral(vertexSource)};`);
  tsLines.push(`export const ${shaderPrefix}FragmentSource = ${escapeTemplateLiteral(fragmentSource)};`);
  tsLines.push('');
  if (helperBlocks.length > 0) {
    tsLines.push(...helperBlocks);
    tsLines.push('');
  }
  tsLines.push(...uniformInterfaceLines);
  tsLines.push('');
  tsLines.push(...uniformDefaultsLines);
  tsLines.push('');
  tsLines.push(...uniformMetaLines);
  tsLines.push('');
  tsLines.push(...uniformSetterLines);
  tsLines.push('');
  tsLines.push(`export type ${shaderPrefix}TextureName = ${textureNameUnion};`);
  tsLines.push(`export const ${shaderPrefix}TextureNames = ${textureNamesLiteral};`);
  tsLines.push('');
  if (instanceLayoutLines.length > 0) {
    tsLines.push(...instanceLayoutLines);
    tsLines.push('');
  }
  tsLines.push(...materialInterfaceLines);
  tsLines.push('');
  tsLines.push(...materialInstanceLines);
  tsLines.push('');
  tsLines.push(...createMaterialLines);
  tsLines.push('');
  tsLines.push(...materialDefLines);
  tsLines.push('');
  tsLines.push(`export default ${materialConstName};`);

  const typesSource = `${tsLines.join('\n')}\n`;

  return { typesSource };
}
