import { promises as fs } from 'node:fs';
import * as path from 'node:path';
import {
  ArgumentInfo,
  StructInfo,
  WgslReflect,
} from 'wgsl_reflect';

type Logger = (message: string) => void;

export interface GenerateFragmentShaderOptions {
  projectRoot: string;
  logger?: Logger;
}

export interface GenerateFragmentShaderResult {
  sourcePath: string;
  typesPath: string;
  updated: boolean;
}

const RAW_SUFFIX = '.fragFunc.wgsl';
const TYPES_SUFFIX = '.frag.generated.ts';

const HEADER_COMMENT = '// Auto-generated by wgsl fragment generator. DO NOT EDIT.';

interface UniformField {
  name: string;
  bindingName: string;
  wgslType: string;
  defaultExpression?: string;
}

interface TextureParam {
  textureName: string;
  samplerName: string;
}

interface PassTextureBinding extends TextureParam {
  source: 'input' | 'pass';
  passIndex?: number;
}

interface PassAnalysis {
  index: number;
  name: string;
  args: ArgumentInfo[];
  resourceBindings: PassTextureBinding[];
}

interface ShaderAnalysis {
  shaderCode: string;
  shaderBaseName: string;
  shaderPrefix: string;
  effectClassName: string;
  uvArgName: string;
  uniformStruct: StructInfo | null;
  uniformFields: UniformField[];
  uniformArgName: string | null;
  resourceStartIndex: number;
  baseTextureParams: TextureParam[];
  passAnalyses: PassAnalysis[];
  passTextureBindings: PassTextureBinding[][];
  textureParams: TextureParam[];
  inputTextureParams: TextureParam[];
  passCount: number;
}

interface UniformTypeMetadata {
  tsType: string;
  setter: string;
  expression: (valueRef: string) => string;
  helper?: string;
}

const UNIFORM_TYPE_MAP: Record<string, UniformTypeMetadata> = {
  f32: {
    tsType: 'number',
    setter: 'setFloat',
    expression: (valueRef) => valueRef,
  },
  i32: {
    tsType: 'number',
    setter: 'setInt',
    expression: (valueRef) => valueRef,
  },
  u32: {
    tsType: 'number',
    setter: 'setUInt',
    expression: (valueRef) => valueRef,
  },
  bool: {
    tsType: 'boolean',
    setter: 'setFloat',
    expression: (valueRef) => `(${valueRef} ? 1 : 0)`,
  },
  vec2f: {
    tsType: 'BABYLON.Vector2 | readonly [number, number]',
    setter: 'setVector2',
    expression: (valueRef) => `ensureVector2(${valueRef})`,
    helper: 'ensureVector2',
  },
  vec3f: {
    tsType: 'BABYLON.Vector3 | readonly [number, number, number]',
    setter: 'setVector3',
    expression: (valueRef) => `ensureVector3(${valueRef})`,
    helper: 'ensureVector3',
  },
  vec4f: {
    tsType: 'BABYLON.Vector4 | readonly [number, number, number, number]',
    setter: 'setVector4',
    expression: (valueRef) => `ensureVector4(${valueRef})`,
    helper: 'ensureVector4',
  },
  mat4x4f: {
    tsType: 'BABYLON.Matrix | Float32Array | readonly number[]',
    setter: 'setMatrix',
    expression: (valueRef) => `ensureMatrix(${valueRef})`,
    helper: 'ensureMatrix',
  },
};

const HELPER_SNIPPETS: Record<string, string> = {
  ensureVector2: `function ensureVector2(value: BABYLON.Vector2 | readonly [number, number]): BABYLON.Vector2 {\n  return value instanceof BABYLON.Vector2 ? value : BABYLON.Vector2.FromArray(value as readonly [number, number]);\n}`,
  ensureVector3: `function ensureVector3(value: BABYLON.Vector3 | readonly [number, number, number]): BABYLON.Vector3 {\n  return value instanceof BABYLON.Vector3 ? value : BABYLON.Vector3.FromArray(value as readonly [number, number, number]);\n}`,
  ensureVector4: `function ensureVector4(value: BABYLON.Vector4 | readonly [number, number, number, number]): BABYLON.Vector4 {\n  return value instanceof BABYLON.Vector4 ? value : BABYLON.Vector4.FromArray(value as readonly [number, number, number, number]);\n}`,
  ensureMatrix: `function ensureMatrix(value: BABYLON.Matrix | Float32Array | readonly number[]): BABYLON.Matrix {\n  if (value instanceof BABYLON.Matrix) {\n    return value;\n  }\n  const matrix = BABYLON.Matrix.Identity();\n  matrix.copyFromArray(Array.from(value));\n  return matrix;\n}`,
};

function toPascalCase(value: string): string {
  return value
    .replace(/[-_]/g, ' ')
    .split(' ')
    .filter(Boolean)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
}

function escapeTemplateLiteral(value: string): string {
  return `\`${value
    .replace(/\\/g, '\\\\')
    .replace(/`/g, '\\`')
    .replace(/\$\{/g, '\\${')}\``;
}

async function writeFileIfChanged(filePath: string, content: string): Promise<boolean> {
  let existing: string | null = null;
  try {
    existing = await fs.readFile(filePath, 'utf8');
  } catch (error: any) {
    if (error?.code !== 'ENOENT') {
      throw error;
    }
  }
  if (existing === content) {
    return false;
  }
  await fs.mkdir(path.dirname(filePath), { recursive: true });
  await fs.writeFile(filePath, content, 'utf8');
  return true;
}

function validateUvArgument(argument: ArgumentInfo): void {
  const typeName = argument.type.getTypeName();
  if (typeName !== 'vec2f') {
    throw new Error(`First argument must be a vec2f called uv. Received ${argument.name}: ${typeName}`);
  }
}

function validateTextureArgument(argument: ArgumentInfo): void {
  const typeName = argument.type.getTypeName();
  if (typeName !== 'texture_2d<f32>') {
    throw new Error(`Texture argument must be texture_2d<f32>. Received ${argument.name}: ${typeName}`);
  }
}

function validateSamplerArgument(argument: ArgumentInfo): void {
  const typeName = argument.type.getTypeName();
  if (typeName !== 'sampler') {
    throw new Error(`Sampler argument must be sampler. Received ${argument.name}: ${typeName}`);
  }
}

function collectUniformFields(struct: StructInfo, uniformArgName: string, shaderSource: string): UniformField[] {
  const defaultMap = extractUniformDefaults(shaderSource, struct.name);
  return struct.members.map((member) => {
    if (member.type.isStruct || member.type.isArray) {
      throw new Error(`Uniform field ${member.name} uses unsupported type ${member.type.getTypeName()}. Nested structs/arrays are not supported.`);
    }
    const typeName = member.type.getTypeName();
    if (!UNIFORM_TYPE_MAP[typeName]) {
      throw new Error(`Uniform field ${member.name} uses unsupported type ${typeName}.`);
    }
    const bindingName = `${uniformArgName}_${member.name}`;
    return {
      name: member.name,
      bindingName,
      wgslType: typeName,
      defaultExpression: defaultMap[member.name],
    };
  });
}

function extractUniformDefaults(source: string, structName: string): Record<string, string> {
  const defaults: Record<string, string> = {};
  const structRegex = new RegExp(`struct\\s+${structName}\\s*\\{`, 'g');
  const match = structRegex.exec(source);
  if (!match) {
    return defaults;
  }
  const braceStart = source.indexOf('{', match.index);
  if (braceStart === -1) {
    return defaults;
  }
  let depth = 0;
  let endIndex = braceStart;
  for (let i = braceStart; i < source.length; i++) {
    const char = source[i];
    if (char === '{') {
      depth++;
    } else if (char === '}') {
      depth--;
      if (depth === 0) {
        endIndex = i;
        break;
      }
    }
  }
  const body = source.slice(braceStart + 1, endIndex);
  const lines = body.split(/\r?\n/);
  for (const rawLine of lines) {
    const line = rawLine.trim();
    if (!line) {
      continue;
    }
    const commentIndex = line.indexOf('//');
    if (commentIndex === -1) {
      continue;
    }
    const comment = line.slice(commentIndex + 2).trim();
    if (!comment) {
      continue;
    }
    const declarationPart = line.slice(0, commentIndex).trim().replace(/,+$/, '');
    const fieldMatch = declarationPart.match(/^([A-Za-z0-9_]+)\s*:/);
    if (!fieldMatch) {
      continue;
    }
    const fieldName = fieldMatch[1];
    const expression = parseDefaultExpression(comment);
    if (expression !== null) {
      defaults[fieldName] = expression;
    }
  }
  return defaults;
}

function parseDefaultExpression(comment: string): string | null {
  const trimmed = comment.trim();
  if (!trimmed) {
    return null;
  }
  try {
    const parsed = JSON.parse(trimmed);
    if (typeof parsed === 'boolean') {
      return parsed ? 'true' : 'false';
    }
    return trimmed;
  } catch (error) {
    const lower = trimmed.toLowerCase();
    if (lower === 'true' || lower === 'false') {
      return lower;
    }
    const numeric = Number(trimmed);
    if (!Number.isNaN(numeric)) {
      return trimmed;
    }
  }
  return null;
}

function generateUniformStructConstruction(struct: StructInfo, fields: UniformField[]): string {
  if (fields.length === 0) {
    return '';
  }
  const ctorArguments = fields.map((field) => `  uniforms.${field.bindingName}`).join(',\n');
  return `fn load_${struct.name}() -> ${struct.name} {\n  return ${struct.name}(\n${ctorArguments}\n  );\n}`;
}

function buildVertexSource(commonDeclarations: string[], varyingName: string): string {
  const lines: string[] = [];
  lines.push(HEADER_COMMENT);
  if (commonDeclarations.length > 0) {
    lines.push(...commonDeclarations);
    lines.push('');
  }
  lines.push('#define CUSTOM_VERTEX_DEFINITIONS');
  lines.push('@vertex');
  lines.push('fn main(input : VertexInputs) -> FragmentInputs {');
  lines.push('#define CUSTOM_VERTEX_MAIN_BEGIN');
  lines.push('  vertexOutputs.position = vec4<f32>(vertexInputs.position, 1.0);');
  lines.push(`  vertexOutputs.${varyingName} = vertexInputs.uv;`);
  lines.push('#define CUSTOM_VERTEX_MAIN_END');
  lines.push('}');
  lines.push('');
  return `${lines.join('\n')}\n`;
}

function buildFragmentSource(
  rawSource: string,
  commonDeclarations: string[],
  uniformStruct: StructInfo | null,
  uniformLoaderFn: string,
  functionName: string,
  uvArgName: string,
  uniformArgName: string | null,
  passArgs: ArgumentInfo[],
  resourceStartIndex: number,
  varyingName: string,
): string {
  const lines: string[] = [];
  lines.push(HEADER_COMMENT);
  if (commonDeclarations.length > 0) {
    lines.push(...commonDeclarations);
    lines.push('');
  }
  lines.push('// Source fragment function');
  lines.push(rawSource.trimEnd());
  lines.push('');
  if (uniformStruct && uniformLoaderFn) {
    lines.push(uniformLoaderFn);
    lines.push('');
  }
  lines.push('#define CUSTOM_FRAGMENT_DEFINITIONS');
  lines.push('@fragment');
  lines.push('fn main(input: FragmentInputs) -> FragmentOutputs {');
  lines.push('#define CUSTOM_FRAGMENT_MAIN_BEGIN');
  if (uniformStruct) {
    lines.push(`  let ${uniformArgName}_value = load_${uniformStruct.name}();`);
  }
  lines.push(`  let ${uvArgName}_local = fragmentInputs.${varyingName};`);
  const resourceArgNames = passArgs.slice(resourceStartIndex).map((argument) => argument.name);
  const args: string[] = [`${uvArgName}_local`];
  if (uniformStruct) {
    args.push(`${uniformArgName}_value`);
  }
  resourceArgNames.forEach((name) => {
    args.push(name);
  });
  lines.push(`  let color = ${functionName}(${args.join(', ')});`);
  lines.push('  fragmentOutputs.color = color;');
  lines.push('#define CUSTOM_FRAGMENT_MAIN_END');
  lines.push('}');
  lines.push('');
  return `${lines.join('\n')}\n`;
}

function analyzeShaderSource(
  shaderCode: string,
  reflect: WgslReflect,
  shaderBaseName: string,
): ShaderAnalysis {
  const shaderPrefix = toPascalCase(shaderBaseName);
  const effectClassName = `${shaderPrefix}Effect`;

  const freeFunctions = reflect.functions.filter((fn) => !fn.stage);
  const passFunctions = freeFunctions.filter((fn) => /^pass\d+$/.test(fn.name));

  if (passFunctions.length === 0) {
    const helperNames = freeFunctions.map((fn) => fn.name).join(', ');
    const suffix = helperNames ? ` Found helper functions: ${helperNames}` : '';
    throw new Error(`No pass functions found. Expected one or more functions named pass0, pass1, ... in fragment shader.${suffix}`);
  }

  const indexedPasses = passFunctions
    .map((fn) => {
      const index = Number(fn.name.replace('pass', ''));
      if (!Number.isInteger(index)) {
        throw new Error(`Pass function ${fn.name} uses an invalid index.`);
      }
      return { fn, index };
    })
    .sort((a, b) => a.index - b.index);

  const seenIndexes = new Set<number>();
  indexedPasses.forEach(({ index }) => {
    if (seenIndexes.has(index)) {
      throw new Error(`Duplicate pass index detected for pass${index}.`);
    }
    seenIndexes.add(index);
  });

  indexedPasses.forEach(({ index }) => {
    if (index < 0) {
      throw new Error(`Pass indexes must start at 0. Received pass${index}.`);
    }
  });

  indexedPasses.forEach(({ index }, position) => {
    if (index !== position) {
      throw new Error(`Missing pass${position}. Pass functions must form a contiguous sequence starting at pass0.`);
    }
  });

  const orderedPassFunctions = indexedPasses.map(({ fn }) => fn);
  const passCount = orderedPassFunctions.length;

  orderedPassFunctions.forEach((fn) => {
    const returnType = fn.returnType?.getTypeName();
    if (returnType !== 'vec4f') {
      throw new Error(`Fragment pass ${fn.name} must return vec4f. Received ${returnType ?? 'void'}.`);
    }
  });

  const primaryPass = orderedPassFunctions[0];
  const primaryArgs = primaryPass.arguments;
  if (primaryArgs.length < 3) {
    throw new Error('Fragment function must include uv followed by at least one texture/sampler pair.');
  }

  const uvArg = primaryArgs[0];
  validateUvArgument(uvArg);
  const uvArgName = uvArg.name;

  let uniformStruct: StructInfo | null = null;
  let uniformFields: UniformField[] = [];
  let uniformArgName: string | null = null;
  let resourceStartIndex = 1;

  if (primaryArgs.length >= 4) {
    const potentialUniform = primaryArgs[1];
    const structInfo = reflect.structs.find((entry) => entry.name === potentialUniform.type.getTypeName());
    if (structInfo) {
      uniformStruct = structInfo;
      uniformArgName = potentialUniform.name;
      uniformFields = collectUniformFields(structInfo, uniformArgName, shaderCode);
      resourceStartIndex = 2;
    }
  }

  const baseArgumentNames = primaryArgs.slice(0, resourceStartIndex).map((argument) => argument.name);
  const baseArgumentTypes = primaryArgs.slice(0, resourceStartIndex).map((argument) => argument.type.getTypeName());

  const passAnalyses: PassAnalysis[] = [];
  const passTextureBindings: PassTextureBinding[][] = [];
  const baseTextureParams: TextureParam[] = [];
  const baseTextureLookup = new Map<string, TextureParam>();
  const textureParamMap = new Map<string, TextureParam>();

  const analyzePassResources = (
    passFn: typeof primaryPass,
    passIndex: number,
  ): PassTextureBinding[] => {
    const passArgs = passFn.arguments;
    if (passArgs.length < resourceStartIndex) {
      throw new Error(
        `${passFn.name} must declare at least ${resourceStartIndex} arguments (uv${uniformStruct ? ', uniforms' : ''}).`,
      );
    }

    for (let index = 0; index < resourceStartIndex; index++) {
      const expectedName = baseArgumentNames[index];
      const expectedType = baseArgumentTypes[index];
      const argument = passArgs[index];
      if (!argument) {
        throw new Error(`Argument ${index} of ${passFn.name} must be ${expectedType} named ${expectedName}.`);
      }
      const actualType = argument.type.getTypeName();
      if (actualType !== expectedType) {
        throw new Error(`Argument ${index} of ${passFn.name} must be ${expectedType}. Received ${actualType}.`);
      }
      if (argument.name !== expectedName) {
        throw new Error(`Argument ${index} of ${passFn.name} must be named ${expectedName}. Received ${argument.name}.`);
      }
    }

    const bindings: PassTextureBinding[] = [];
    const seenPassDependencies = new Set<number>();
    const seenTextureNames = new Set<string>();
    const extraCount = passArgs.length - resourceStartIndex;
    if (extraCount < 0 || extraCount % 2 !== 0) {
      throw new Error(`Additional arguments for ${passFn.name} must be provided in texture/sampler pairs.`);
    }

    for (let offset = 0; offset < extraCount; offset += 2) {
      const argumentIndex = resourceStartIndex + offset;
      const textureArg = passArgs[argumentIndex];
      const samplerArg = passArgs[argumentIndex + 1];
      if (!samplerArg) {
        throw new Error('Texture parameter must be followed by a sampler parameter.');
      }
      validateTextureArgument(textureArg);
      validateSamplerArgument(samplerArg);
      if (seenTextureNames.has(textureArg.name)) {
        throw new Error(`Duplicate texture parameter ${textureArg.name} detected in ${passFn.name}.`);
      }
      seenTextureNames.add(textureArg.name);

      const passDependencyMatch = /^pass(\d+)Texture$/.exec(textureArg.name);
      if (passDependencyMatch) {
        const dependencyIndex = Number(passDependencyMatch[1]);
        if (!Number.isInteger(dependencyIndex)) {
          throw new Error(`Invalid pass dependency ${textureArg.name} in ${passFn.name}.`);
        }
        if (dependencyIndex < 0 || dependencyIndex >= passIndex) {
          throw new Error(
            `Pass ${passFn.name} can only depend on earlier passes. Received dependency on pass${dependencyIndex}.`,
          );
        }
        if (seenPassDependencies.has(dependencyIndex)) {
          throw new Error(`Duplicate dependency on pass${dependencyIndex} detected in ${passFn.name}.`);
        }
        seenPassDependencies.add(dependencyIndex);
        const expectedSamplerName = `pass${dependencyIndex}Sampler`;
        if (samplerArg.name !== expectedSamplerName) {
          throw new Error(
            `Sampler parameter for dependency ${textureArg.name} must be named ${expectedSamplerName}. Received ${samplerArg.name}.`,
          );
        }
        bindings.push({
          textureName: textureArg.name,
          samplerName: samplerArg.name,
          source: 'pass',
          passIndex: dependencyIndex,
        });
        if (!textureParamMap.has(textureArg.name)) {
          textureParamMap.set(textureArg.name, {
            textureName: textureArg.name,
            samplerName: samplerArg.name,
          });
        }
        continue;
      }

      const baseTexture = baseTextureLookup.get(textureArg.name);
      if (!baseTexture) {
        if (passIndex === 0) {
          const expectedSamplerName = `${textureArg.name}Sampler`;
          if (samplerArg.name !== expectedSamplerName) {
            throw new Error(
              `Sampler parameter must be named ${expectedSamplerName} to match the texture parameter ${textureArg.name}.`,
            );
          }
          const param: TextureParam = {
            textureName: textureArg.name,
            samplerName: samplerArg.name,
          };
          baseTextureParams.push(param);
          baseTextureLookup.set(textureArg.name, param);
          textureParamMap.set(textureArg.name, param);
          bindings.push({
            textureName: textureArg.name,
            samplerName: samplerArg.name,
            source: 'input',
          });
        } else {
          throw new Error(
            `Pass ${passFn.name} references unknown texture ${textureArg.name}. Base textures must be declared in pass0.`,
          );
        }
        continue;
      }

      const expectedSamplerName = baseTexture.samplerName;
      if (samplerArg.name !== expectedSamplerName) {
        throw new Error(
          `Sampler parameter must be named ${expectedSamplerName} to match the texture parameter ${textureArg.name}.`,
        );
      }
      bindings.push({
        textureName: textureArg.name,
        samplerName: samplerArg.name,
        source: 'input',
      });
    }

    return bindings;
  };

  orderedPassFunctions.forEach((passFn, passIndex) => {
    const bindings = analyzePassResources(passFn, passIndex);
    passAnalyses.push({
      index: passIndex,
      name: passFn.name,
      args: passFn.arguments,
      resourceBindings: bindings,
    });
    passTextureBindings.push(bindings);
  });

  if (baseTextureParams.length === 0) {
    throw new Error('At least one texture argument is required for a pass.');
  }

  const textureParams = Array.from(textureParamMap.values());

  return {
    shaderCode,
    shaderBaseName,
    shaderPrefix,
    effectClassName,
    uvArgName,
    uniformStruct,
    uniformFields,
    uniformArgName,
    resourceStartIndex,
    baseTextureParams,
    passAnalyses,
    passTextureBindings,
    textureParams,
    inputTextureParams: baseTextureParams,
    passCount,
  };
}

export async function generateFragmentShaderArtifacts(
  sourcePath: string,
  options: GenerateFragmentShaderOptions,
): Promise<GenerateFragmentShaderResult> {
  if (!sourcePath.endsWith(RAW_SUFFIX)) {
    throw new Error(`Expected a ${RAW_SUFFIX} file. Received ${sourcePath}`);
  }

  const { projectRoot, logger } = options;
  const absoluteSource = path.resolve(sourcePath);
  const shaderDirectory = path.dirname(absoluteSource);
  const shaderBaseName = path.basename(sourcePath, RAW_SUFFIX);
  const typesPath = path.join(shaderDirectory, `${shaderBaseName}${TYPES_SUFFIX}`);
  const shaderPrefix = toPascalCase(shaderBaseName);
  const effectClassName = `${shaderPrefix}Effect`;
  const defaultUniformInterfaceName = `${shaderPrefix}Uniforms`;

  try {
    const shaderCode = await fs.readFile(absoluteSource, 'utf8');
    const reflect = new WgslReflect(shaderCode);
    const analysis = analyzeShaderSource(shaderCode, reflect, shaderBaseName);
    const {
      uvArgName,
      uniformStruct,
      uniformFields,
      uniformArgName,
      resourceStartIndex,
      baseTextureParams,
      passAnalyses,
      passTextureBindings,
      textureParams,
      inputTextureParams,
      passCount,
    } = analysis;

    const primaryTextureName = inputTextureParams[0]?.textureName;
    if (!primaryTextureName) {
      throw new Error('At least one texture argument is required for a pass.');
    }

    const shaderFxImportPath = (() => {
      const shaderFxAbsolute = path.join(options.projectRoot, 'src/rendering/shaderFXBabylon.ts');
      let relative = path.relative(shaderDirectory, shaderFxAbsolute).replace(/\\/g, '/');
      if (!relative.startsWith('.')) {
        relative = `./${relative}`;
      }
      return relative.replace(/\.ts$/, '');
    })();
    const shaderFxImports = ['CustomShaderEffect', 'type ShaderSource', 'type RenderPrecision'];
    if (uniformFields.length > 0) {
      shaderFxImports.push('type ShaderUniforms', 'type Dynamic');
    }

    const uniformLoaderFn = uniformStruct ? generateUniformStructConstruction(uniformStruct, uniformFields) : '';
    const uniformDeclarations = uniformFields.map((field) => `uniform ${field.bindingName}: ${field.wgslType};`);

    const varyingName = 'vUV';

    const vertexDeclarations: string[] = [
      'attribute position: vec3<f32>;',
      'attribute uv: vec2<f32>;',
      `varying ${varyingName}: vec2<f32>;`,
    ];

    const vertexSource = buildVertexSource(vertexDeclarations, varyingName);
    const fragmentSources = passAnalyses.map((passInfo) => {
      const fragmentDeclarations: string[] = [`varying ${varyingName}: vec2<f32>;`];
      if (uniformDeclarations.length > 0) {
        fragmentDeclarations.push(...uniformDeclarations);
      }
      const declared = new Set<string>();
      for (let argumentIndex = resourceStartIndex; argumentIndex < passInfo.args.length; argumentIndex += 2) {
        const textureArg = passInfo.args[argumentIndex];
        const samplerArg = passInfo.args[argumentIndex + 1];
        if (!textureArg || !samplerArg) {
          throw new Error(`Texture parameters in ${passInfo.name} must be provided in texture/sampler pairs.`);
        }
        if (!declared.has(textureArg.name)) {
          fragmentDeclarations.push(`var ${textureArg.name}: texture_2d<f32>;`);
          declared.add(textureArg.name);
        }
        if (!declared.has(samplerArg.name)) {
          fragmentDeclarations.push(`var ${samplerArg.name}: sampler;`);
          declared.add(samplerArg.name);
        }
      }

      return buildFragmentSource(
        shaderCode,
        fragmentDeclarations,
        uniformStruct,
        uniformLoaderFn,
        passInfo.name,
        uvArgName,
        uniformArgName,
        passInfo.args,
        resourceStartIndex,
        varyingName,
      );
    });

    const uniformInterfaceName = uniformStruct
      ? (uniformStruct.name.startsWith(shaderPrefix) ? uniformStruct.name : `${shaderPrefix}${uniformStruct.name}`)
      : defaultUniformInterfaceName;

    const helperNames = new Set<string>();
    const uniformInterfaceLines: string[] = [];
    const uniformSetterLines: string[] = [];

    if (uniformStruct && uniformFields.length > 0) {
      uniformInterfaceLines.push(`export interface ${uniformInterfaceName} {`);
      for (const field of uniformFields) {
        const meta = UNIFORM_TYPE_MAP[field.wgslType];
        if (!meta) {
          throw new Error(`Unsupported uniform field type ${field.wgslType}.`);
        }
        uniformInterfaceLines.push(`  ${field.name}: ${meta.tsType};`);
        if (meta.helper) {
          helperNames.add(meta.helper);
        }
      }
      uniformInterfaceLines.push('}');

      uniformSetterLines.push(`export function set${uniformInterfaceName}(material: BABYLON.ShaderMaterial, uniforms: Partial<${uniformInterfaceName}>): void {`);
      uniformSetterLines.push('  if (!uniforms) {');
      uniformSetterLines.push('    return;');
      uniformSetterLines.push('  }');
      for (const field of uniformFields) {
        const meta = expectMeta(field.wgslType);
        uniformSetterLines.push(`  if (uniforms.${field.name} !== undefined) {`);
        uniformSetterLines.push(`    material.${meta.setter}('${field.bindingName}', ${meta.expression(`uniforms.${field.name}`)});`);
        uniformSetterLines.push('  }');
      }
      uniformSetterLines.push('}');
    }

    const helperBlocks = Array.from(helperNames).map((name) => HELPER_SNIPPETS[name]);

    const uniformsArrayLiteral = uniformFields.length
      ? `[${uniformFields.map((field) => `'${field.bindingName}'`).join(', ')}]`
      : '[]';

    const textureNamesArrayLiteral = `[${textureParams.map((param) => `'${param.textureName}'`).join(', ')}]`;
    const samplerObjectsArrayLiteral = `[${textureParams.map((param) => `'${param.samplerName}'`).join(', ')}]`;
    const samplerLookupLiteral = `{ ${textureParams
      .map((param) => `'${param.textureName}': '${param.samplerName}'`)
      .join(', ')} } as const`;
    const inputTextureNamesArrayLiteral = `[${inputTextureParams.map((param) => `'${param.textureName}'`).join(', ')}]`;

    const materialHandlesName = `${shaderPrefix}MaterialHandles`;
    const materialOptionsName = `${shaderPrefix}MaterialOptions`;
    const setUniformsFunctionName = uniformStruct && uniformFields.length > 0 ? `set${uniformInterfaceName}` : null;

    const tsLines: string[] = [];
    tsLines.push(HEADER_COMMENT);
    tsLines.push(`import * as BABYLON from 'babylonjs';`);
    tsLines.push(`import { ${shaderFxImports.join(', ')} } from '${shaderFxImportPath}';`);
    tsLines.push(`export const ${shaderPrefix}VertexSource = ${escapeTemplateLiteral(vertexSource)};`);
    tsLines.push(`export const ${shaderPrefix}FragmentSources = [`);
    fragmentSources.forEach((source, index) => {
      tsLines.push(`  ${escapeTemplateLiteral(source)}, // pass${index}`);
    });
    tsLines.push(`] as const;`);
    tsLines.push(`export const ${shaderPrefix}PassCount = ${passCount} as const;`);
    tsLines.push(`export const ${shaderPrefix}PrimaryTextureName = '${primaryTextureName}' as const;`);
    tsLines.push('');

    const passTextureSourceLines: string[] = [];
    passTextureSourceLines.push(`export const ${shaderPrefix}PassTextureSources = [`);
    passTextureBindings.forEach((bindings) => {
      passTextureSourceLines.push('  [');
      bindings.forEach((binding) => {
        if (binding.source === 'input') {
          passTextureSourceLines.push(
            `    { binding: '${binding.textureName}', source: { kind: 'input', key: '${binding.textureName}' } },`,
          );
        } else {
          passTextureSourceLines.push(
            `    { binding: '${binding.textureName}', source: { kind: 'pass', passIndex: ${binding.passIndex} } },`,
          );
        }
      });
      passTextureSourceLines.push('  ],');
    });
    passTextureSourceLines.push(`] as const;`);
    passTextureSourceLines.push('');
    tsLines.push(...passTextureSourceLines);

    if (helperBlocks.length > 0) {
      tsLines.push(...helperBlocks);
      tsLines.push('');
    }
    if (uniformStruct && uniformFields.length > 0) {
      tsLines.push(...uniformInterfaceLines);
      tsLines.push('');
      tsLines.push(...uniformSetterLines);
      tsLines.push('');
    } else {
      tsLines.push(`export type ${uniformInterfaceName} = Record<string, never>;`);
      tsLines.push(`export function set${uniformInterfaceName}(_material: BABYLON.ShaderMaterial, _uniforms: Partial<${uniformInterfaceName}>): void {}`);
      tsLines.push('');
    }
    const textureNameUnion = textureParams.map((param) => `'${param.textureName}'`).join(' | ');
    const inputsTypeName = `${shaderPrefix}Inputs`;
    tsLines.push(`export type ${shaderPrefix}TextureName = ${textureNameUnion};`);
    tsLines.push(`export interface ${inputsTypeName} {`);
    inputTextureParams.forEach((param) => {
      tsLines.push(`  ${param.textureName}: ShaderSource;`);
    });
    tsLines.push('}');
    tsLines.push('');
    tsLines.push(`export interface ${materialHandlesName} {`);
    tsLines.push('  material: BABYLON.ShaderMaterial;');
    tsLines.push(`  setTexture(name: ${shaderPrefix}TextureName, texture: BABYLON.BaseTexture): void;`);
    tsLines.push(`  setTextureSampler(name: ${shaderPrefix}TextureName, sampler: BABYLON.TextureSampler): void;`);
    tsLines.push(`  setUniforms(uniforms: Partial<${uniformInterfaceName}>): void;`);
    tsLines.push('}');
    tsLines.push('');
    tsLines.push(`export interface ${materialOptionsName} {`);
    tsLines.push('  name?: string;');
    tsLines.push('  passIndex?: number;');
    tsLines.push('}');
    tsLines.push('');
    tsLines.push(`export function create${shaderPrefix}Material(scene: BABYLON.Scene, options: ${materialOptionsName} = {}): ${materialHandlesName} {`);
    tsLines.push('  const passIndex = options.passIndex ?? 0;');
    tsLines.push(`  if (passIndex < 0 || passIndex >= ${passCount}) {`);
    tsLines.push(`    throw new Error(\`Invalid passIndex \${passIndex} for ${shaderPrefix}. Expected 0 <= passIndex < ${passCount}.\`);`);
    tsLines.push('  }');
    tsLines.push(`  const baseName = options.name ?? '${shaderPrefix}Material';`);
    tsLines.push('  const shaderName = `${baseName}_pass${passIndex}`;');
    tsLines.push('  // Register shaders in the WGSL store to enable preprocessor');
    tsLines.push('  const vertexShaderName = `${shaderName}VertexShader`;');
    tsLines.push('  const fragmentShaderName = `${shaderName}FragmentShader`;');
    tsLines.push('  ');
    tsLines.push(`  BABYLON.ShaderStore.ShadersStoreWGSL[vertexShaderName] = ${shaderPrefix}VertexSource;`);
    tsLines.push(`  BABYLON.ShaderStore.ShadersStoreWGSL[fragmentShaderName] = ${shaderPrefix}FragmentSources[passIndex];`);
    tsLines.push('  ');
    tsLines.push('  const material = new BABYLON.ShaderMaterial(shaderName, scene, {');
    tsLines.push('    vertex: shaderName,');
    tsLines.push('    fragment: shaderName,');
    tsLines.push('  }, {');
    tsLines.push(`    attributes: ['position', 'uv'],`);
    tsLines.push(`    uniforms: ${uniformsArrayLiteral},`);
    tsLines.push(`    samplers: ${textureNamesArrayLiteral},`);
    tsLines.push(`    samplerObjects: ${samplerObjectsArrayLiteral},`);
    tsLines.push('    shaderLanguage: BABYLON.ShaderLanguage.WGSL,');
    tsLines.push('  });');
    tsLines.push('');
    tsLines.push(`  const samplerLookup = ${samplerLookupLiteral};`);
    tsLines.push('');
    tsLines.push(`  const handles: ${materialHandlesName} = {`);
    tsLines.push('    material,');
    tsLines.push('    setTexture: (name, texture) => material.setTexture(name, texture),');
    tsLines.push('    setTextureSampler: (name, sampler) => material.setTextureSampler(samplerLookup[name], sampler),');
    if (setUniformsFunctionName) {
      tsLines.push(`    setUniforms: (values) => ${setUniformsFunctionName}(material, values),`);
    } else {
      tsLines.push('    setUniforms: () => {},');
    }
    tsLines.push('  };');
    tsLines.push('');
    tsLines.push('  return handles;');
    tsLines.push('}');
    tsLines.push('');

    const effectLines: string[] = [];
    effectLines.push(`export class ${effectClassName} extends CustomShaderEffect<${uniformInterfaceName}, ${inputsTypeName}> {`);
    effectLines.push(`  effectName = '${shaderPrefix}'`);
    effectLines.push('');
    effectLines.push(`  constructor(engine: BABYLON.WebGPUEngine, inputs: ${inputsTypeName}, width = 1280, height = 720, sampleMode: 'nearest' | 'linear' = 'linear', precision: RenderPrecision = 'half_float') {`);
    effectLines.push('    super(engine, inputs, {');
    effectLines.push(`      factory: (sceneRef, options) => create${shaderPrefix}Material(sceneRef, options),`);
    effectLines.push(`      textureInputKeys: ${inputTextureNamesArrayLiteral},`);
    effectLines.push(`      textureBindingKeys: ${textureNamesArrayLiteral},`);
    effectLines.push(`      passTextureSources: ${shaderPrefix}PassTextureSources,`);
    effectLines.push(`      passCount: ${passCount},`);
    effectLines.push(`      primaryTextureKey: '${primaryTextureName}',`);
    effectLines.push('      width,');
    effectLines.push('      height,');
    effectLines.push(`      materialName: '${shaderPrefix}Material',`);
    effectLines.push('      sampleMode,');
    effectLines.push('      precision,');
    effectLines.push('    })');
    const fieldsWithDefaults = uniformFields.filter((field) => field.defaultExpression);
    if (fieldsWithDefaults.length > 0) {
      effectLines.push('    this.setUniforms({');
      fieldsWithDefaults.forEach((field) => {
        effectLines.push(`      ${field.name}: ${field.defaultExpression},`);
      });
      effectLines.push('    });');
    } else {
      const uniformNames = new Set(uniformFields.map((field) => field.name));
      const hasTransformDefaults = ['rotate', 'anchor', 'translate', 'scale'].every((name) => uniformNames.has(name));
      if (hasTransformDefaults) {
        effectLines.push('    this.setUniforms({ rotate: 0, anchor: [0.5, 0.5], translate: [0, 0], scale: [1, 1] });');
      }
    }
    effectLines.push('  }');

    effectLines.push('');
    effectLines.push(`  override setSrcs(inputs: Partial<${inputsTypeName}>): void {`);
    effectLines.push('    super.setSrcs(inputs);');
    effectLines.push('  }');

    if (uniformFields.length > 0) {
      const uniformParams = uniformFields
        .map((field) => {
          const meta = UNIFORM_TYPE_MAP[field.wgslType];
          return `${field.name}?: Dynamic<${meta.tsType}>`;
        })
        .join(', ');
      effectLines.push('');
      effectLines.push(`  override setUniforms(uniforms: { ${uniformParams} }): void {`);
      effectLines.push('    const record: ShaderUniforms = {};');
      uniformFields.forEach((field) => {
        effectLines.push(`    if (uniforms.${field.name} !== undefined) {`);
        effectLines.push(`      record['${field.name}'] = uniforms.${field.name};`);
        effectLines.push('    }');
      });
      effectLines.push('    super.setUniforms(record);');
      effectLines.push('  }');
    }

    effectLines.push('}');
    effectLines.push('');
    tsLines.push(...effectLines);

    const typesSource = `${tsLines.join('\n')}\n`;

    const typesUpdated = await writeFileIfChanged(typesPath, typesSource);

    if (logger) {
      const relativeTypes = path.relative(projectRoot, typesPath);
      if (typesUpdated) {
        logger(`Updated ${relativeTypes}`);
      }
    }

    return {
      sourcePath: absoluteSource,
      typesPath,
      updated: typesUpdated,
    };
  } catch (error: any) {
    const message = error instanceof Error ? error.message : String(error);
    const errorUpdated = await writeErrorArtifact({
      typesPath,
      effectClassName,
      uniformInterfaceName: defaultUniformInterfaceName,
      shaderPrefix,
      projectRoot,
      sourcePath: absoluteSource,
      errorMessage: message,
    });
    if (logger) {
      const relativeTypes = path.relative(projectRoot, typesPath);
      logger(`${errorUpdated ? 'Updated' : 'Retained'} error artifact for ${relativeTypes}`);
    }
    throw error;
  }
}

function expectMeta(typeName: string): UniformTypeMetadata {
  const meta = UNIFORM_TYPE_MAP[typeName];
  if (!meta) {
    throw new Error(`Unsupported uniform type ${typeName}`);
  }
  return meta;
}

interface ErrorArtifactOptions {
  typesPath: string;
  effectClassName: string;
  uniformInterfaceName: string;
  shaderPrefix: string;
  projectRoot: string;
  sourcePath: string;
  errorMessage: string;
}

async function writeErrorArtifact(options: ErrorArtifactOptions): Promise<boolean> {
  const { typesPath, effectClassName, uniformInterfaceName, shaderPrefix, projectRoot, sourcePath, errorMessage } = options;
  const relativeSource = path.relative(projectRoot, sourcePath).replace(/\\/g, '/');
  const materialHandlesName = `${shaderPrefix}MaterialHandles`;
  const materialOptionsName = `${shaderPrefix}MaterialOptions`;
  const inputsTypeName = `${shaderPrefix}Inputs`;
  const textureNameType = `${shaderPrefix}TextureName`;
  const message = `Failed to generate shader for ${relativeSource}: ${errorMessage}`;
  const lines: string[] = [];
  lines.push(HEADER_COMMENT);
  lines.push(`export const shaderGenerationErrorMessage = ${JSON.stringify(message)} as const;`);
  lines.push(`export type ${uniformInterfaceName} = never;`);
  lines.push(`export type ${textureNameType} = never;`);
  lines.push(`export interface ${inputsTypeName} {}`);
  lines.push(`export type ${materialHandlesName} = never;`);
  lines.push(`export interface ${materialOptionsName} { name?: string }`);
  lines.push(`export function create${shaderPrefix}Material(): never { throw new Error(shaderGenerationErrorMessage); }`);
  lines.push(`export class ${effectClassName} {`);
  lines.push('  constructor() {');
  lines.push('    throw new Error(shaderGenerationErrorMessage);');
  lines.push('  }');
  lines.push('}');
  lines.push('');
  return writeFileIfChanged(typesPath, `${lines.join('\n')}\n`);
}
