/**
 * WGSL â†’ Babylon.js helper generator.
 *
 * Generates TypeScript companions for WGSL compute shaders, including:
 * - Uniform buffer helpers (f32 / i32 / u32 / bool scalars and vectors).
 * - Storage buffer packers/unpackers for reflected structs.
 * - Bindings for sampled textures, storage textures, and samplers.
 * - Compute shader creation/update helpers with Babylon's ComputeShader API.
 *
 * Missing features / TODOs:
 * - Binding arrays or bindless resource arrays.
 * - Texture arrays, cube textures, and explicit depth-texture helper typing.
 * - Overrides (@id) / specialization values and multi-entry compute pipelines.
 * - Module includes or splitting shaders across multiple files.
 *
 * Usage example:
 * see `src/sketches/handwriting_animator/gpuStrokes/strokeAnimation.wgsl.generated.ts`
 */

import { promises as fs } from 'node:fs';
import * as path from 'node:path';
import {
  ResourceType,
  StructInfo,
  TypeInfo,
  VariableInfo,
  WgslReflect,
} from 'wgsl_reflect';

type Logger = (message: string) => void;

export interface GenerateShaderTypesOptions {
  projectRoot: string;
  outputExtension?: string;
  logger?: Logger;
}

export interface GenerateShaderTypesResult {
  sourcePath: string;
  outputPath: string;
  updated: boolean;
}

const DEFAULT_OUTPUT_SUFFIX = '.generated.ts';

interface TypeMapping {
  tsType: string;
  slotCount: number;
  valueLength: number;
  defaultExpression: string;
  componentType: 'f32' | 'i32' | 'u32' | 'bool';
  isVector: boolean;
}

function floatVectorMapping(componentCount: number, slotCount?: number): TypeMapping {
  const requiredSlots = slotCount ?? componentCount;
  return {
    tsType: 'Float32Array | readonly number[]',
    slotCount: requiredSlots,
    valueLength: componentCount,
    defaultExpression: `new Float32Array(${requiredSlots})`,
    componentType: 'f32',
    isVector: true,
  };
}

function intVectorMapping(componentCount: number, slotCount: number, unsigned: boolean): TypeMapping {
  const arrayCtor = unsigned ? 'Uint32Array' : 'Int32Array';
  const valueType = unsigned ? 'Uint32Array | readonly number[]' : 'Int32Array | readonly number[]';
  return {
    tsType: valueType,
    slotCount,
    valueLength: componentCount,
    defaultExpression: `new ${arrayCtor}(${slotCount})`,
    componentType: unsigned ? 'u32' : 'i32',
    isVector: true,
  };
}

const TYPE_MAP: Record<string, TypeMapping> = {
  f32: { tsType: 'number', slotCount: 1, valueLength: 1, defaultExpression: '0', componentType: 'f32', isVector: false },
  i32: { tsType: 'number', slotCount: 1, valueLength: 1, defaultExpression: '0', componentType: 'i32', isVector: false },
  u32: { tsType: 'number', slotCount: 1, valueLength: 1, defaultExpression: '0', componentType: 'u32', isVector: false },
  bool: { tsType: 'boolean', slotCount: 1, valueLength: 1, defaultExpression: 'false', componentType: 'bool', isVector: false },
  vec2f: floatVectorMapping(2),
  vec3f: floatVectorMapping(3, 4),
  vec4f: floatVectorMapping(4),
  mat4x4f: floatVectorMapping(16),
  vec2i: intVectorMapping(2, 2, false),
  vec3i: intVectorMapping(3, 4, false),
  vec4i: intVectorMapping(4, 4, false),
  vec2u: intVectorMapping(2, 2, true),
  vec3u: intVectorMapping(3, 4, true),
  vec4u: intVectorMapping(4, 4, true),
};

const HEADER_COMMENT = '// Auto-generated by wgsl type generator. DO NOT EDIT.';

interface StructDescriptor {
  struct: StructInfo;
  interfaceName: string;
  layoutName: string;
  packFn: string;
}

interface UniformDescriptor {
  variable: VariableInfo;
  interfaceName: string;
  stateName: string;
  layoutName: string;
  createFn: string;
  updateFn: string;
  aliasCreate?: string;
  aliasUpdate?: string;
}

interface StorageDescriptor {
  variable: VariableInfo;
  stateName: string;
  layoutName: string;
  createFn: string;
  updateFn: string;
  writeFn: string;
  valueType: string;
}

function toPascalCase(value: string): string {
  return value
    .replace(/[-_]/g, ' ')
    .split(' ')
    .filter(Boolean)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
}

function indent(lines: string[], spaces = 2): string {
  const pad = ' '.repeat(spaces);
  return lines
    .map((line) => (line.length > 0 ? pad + line : line))
    .join('\n');
}

function mappingFor(type: TypeInfo): TypeMapping | null {
  const name = type.getTypeName();
  if (TYPE_MAP[name]) {
    return TYPE_MAP[name];
  }
  if (type.isTemplate && (type as any).format) {
    const templateName = (type as any).name as string;
    const format = (type as any).format as TypeInfo;
    if (templateName === 'atomic') {
      return mappingFor(format);
    }
    const formatKey = format.getTypeName();
    if (templateName.startsWith('vec')) {
      const key = `${templateName}${formatKey[0]}`;
      if (TYPE_MAP[key]) {
        return TYPE_MAP[key];
      }
    }
  }
  return null;
}

function generateStructBlock(prefix: string, descriptor: StructDescriptor, structMap: Map<string, StructDescriptor>): string {
  const { struct, interfaceName, layoutName, packFn } = descriptor;
  const interfaceLines = struct.members.map((member) => {
    const mapping = mappingFor(member.type);
    const tsType = mapping ? mapping.tsType : member.type.isStruct ? `${prefix}${member.type.getTypeName()}` : 'number';
    return `${member.name}: ${tsType};`;
  });

  const layoutMembers = struct.members.map((member) => {
    const mapping = mappingFor(member.type);
    const slot = mapping ? mapping.slotCount : member.size / 4;
    return `  { name: '${member.name}', offset: ${member.offset}, size: ${member.size}, slot: ${slot} }`;
  });

  let needsIntView = false;
  let needsUintView = false;
  const packLines: string[] = [];

  struct.members.forEach((member) => {
    const mapping = mappingFor(member.type);
    const memberOffset = member.offset / 4;
    if (mapping) {
      if (mapping.componentType === 'i32' || mapping.componentType === 'bool') {
        needsIntView = true;
      }
      if (mapping.componentType === 'u32') {
        needsUintView = true;
      }
      const baseDecl = `const base = floatOffset + ${memberOffset};`;
      packLines.push('{');
      packLines.push(`  ${baseDecl}`);
      if (!mapping.isVector) {
        switch (mapping.componentType) {
          case 'f32':
            packLines.push(`  const raw = value.${member.name};`);
            packLines.push('  target[base] = raw !== undefined ? Number(raw) : 0;');
            break;
          case 'i32':
            packLines.push(`  const raw = value.${member.name};`);
            packLines.push('  intView[base] = raw !== undefined ? Math.trunc(raw as number) : 0;');
            break;
          case 'u32':
            packLines.push(`  const raw = value.${member.name};`);
            packLines.push('  uintView[base] = raw !== undefined ? Math.trunc(raw as number) >>> 0 : 0;');
            break;
          case 'bool':
            packLines.push(`  const raw = value.${member.name};`);
            packLines.push('  intView[base] = raw ? 1 : 0;');
            break;
        }
      } else {
        const sourceVar = `${member.name}Source`;
        packLines.push(`  const ${sourceVar} = value.${member.name} as any;`);
        packLines.push(`  for (let i = 0; i < ${mapping.valueLength}; i++) {`);
        packLines.push(`    const component = ${sourceVar}?.[i];`);
        switch (mapping.componentType) {
          case 'f32':
            packLines.push('    target[base + i] = component !== undefined ? Number(component) : 0;');
            break;
          case 'i32':
            packLines.push('    intView[base + i] = component !== undefined ? Math.trunc(component as number) : 0;');
            break;
          case 'u32':
            packLines.push('    uintView[base + i] = component !== undefined ? Math.trunc(component as number) >>> 0 : 0;');
            break;
          case 'bool':
            packLines.push('    intView[base + i] = component ? 1 : 0;');
            break;
        }
        packLines.push('  }');
        if (mapping.slotCount > mapping.valueLength) {
          const padStart = mapping.valueLength;
          packLines.push(`  for (let i = ${padStart}; i < ${mapping.slotCount}; i++) {`);
          if (mapping.componentType === 'u32') {
            packLines.push('    uintView[base + i] = 0;');
          } else if (mapping.componentType === 'i32' || mapping.componentType === 'bool') {
            packLines.push('    intView[base + i] = 0;');
          } else {
            packLines.push('    target[base + i] = 0;');
          }
          packLines.push('  }');
        }
      }
      packLines.push('}');
    } else if (member.type.isStruct) {
      const nested = structMap.get(member.type.getTypeName());
      if (nested) {
        packLines.push('{');
        packLines.push(`  ${nested.packFn}(target, floatOffset + ${memberOffset}, value.${member.name});`);
        packLines.push('}');
      } else {
        packLines.push(`// ${member.name}: struct type ${member.type.getTypeName()} not recognized`);
      }
    } else {
      packLines.push(`// ${member.name}: unsupported type`);
    }
  });

  const preamble: string[] = [];
  if (needsIntView) {
    preamble.push('const intView = new Int32Array(target.buffer);');
  }
  if (needsUintView) {
    preamble.push('const uintView = new Uint32Array(target.buffer);');
  }

  return [
    `export interface ${interfaceName} {`,
    indent(interfaceLines),
    '}',
    '',
    `export const ${layoutName} = {`,
    `  size: ${struct.size},`,
    `  align: ${struct.align},`,
    '  members: [',
    layoutMembers.join(',\n'),
    '  ] as const,',
    '} as const;',
    '',
    `export function ${packFn}(target: Float32Array, floatOffset: number, value: ${interfaceName}): void {`,
    indent([...preamble, ...packLines].length ? [...preamble, ...packLines] : ['// No supported members']),
    '}',
  ].join('\n');
}

function generateUniformBlock(descriptor: UniformDescriptor, structDescriptor: StructDescriptor | undefined): string {
  const { interfaceName, stateName, layoutName, createFn, updateFn } = descriptor;
  const structMembers = structDescriptor?.struct.members ?? [];

  const layoutArray = structMembers.map((member) => {
    const mapping = mappingFor(member.type);
    const slot = mapping ? mapping.slotCount : member.size / 4;
    return `  { name: '${member.name}', slot: ${slot} }`;
  });

  const defaultAssignments = structMembers.map((member) => {
    const mapping = mappingFor(member.type);
    const defaultExpr = mapping ? mapping.defaultExpression : '0';
    return `  ${member.name}: ${defaultExpr},`;
  });

  const createBody: string[] = [];
  createBody.push('const buffer = new BABYLON.UniformBuffer(engine);');
  createBody.push(`const uniforms: ${interfaceName} = {`);
  createBody.push(...defaultAssignments);
  createBody.push('};');
  createBody.push(`for (const entry of ${layoutName}) {`);
  createBody.push('  buffer.addUniform(entry.name, entry.slot);');
  createBody.push('}');
  createBody.push('if (initial) {');
  createBody.push(`  ${updateFn}({ buffer, uniforms }, initial);`);
  createBody.push('} else {');
  createBody.push('  buffer.update();');
  createBody.push('}');
  createBody.push('return { buffer, uniforms };');

  const updateBody: string[] = [];
  updateBody.push('let dirty = false;');
  structMembers.forEach((member) => {
    const mapping = mappingFor(member.type);
    if (!mapping) {
      updateBody.push(`// ${member.name}: unsupported uniform type`);
      return;
    }
    const slot = mapping.slotCount;
    const kind = mapping.componentType;
    updateBody.push(`if (updates.${member.name} !== undefined) {`);
    updateBody.push('  dirty = true;');
    updateBody.push(`  const raw = updates.${member.name}! as any;`);
    if (!mapping.isVector) {
      if (kind === 'f32') {
        updateBody.push('  const numeric = raw !== undefined ? Number(raw) : 0;');
        updateBody.push(`  state.uniforms.${member.name} = numeric;`);
        updateBody.push('  const bufferView = new Float32Array(1);');
        updateBody.push('  bufferView[0] = numeric;');
        updateBody.push(`  state.buffer.updateUniform('${member.name}', bufferView, 1);`);
      } else if (kind === 'i32') {
        updateBody.push('  const numeric = raw !== undefined ? Math.trunc(raw as number) : 0;');
        updateBody.push('  const scratch = new ArrayBuffer(4);');
        updateBody.push('  new Int32Array(scratch)[0] = numeric;');
        updateBody.push(`  state.uniforms.${member.name} = numeric;`);
        updateBody.push(`  state.buffer.updateUniform('${member.name}', new Float32Array(scratch), 1);`);
      } else if (kind === 'u32') {
        updateBody.push('  const numeric = raw !== undefined ? Math.trunc(raw as number) >>> 0 : 0;');
        updateBody.push('  const scratch = new ArrayBuffer(4);');
        updateBody.push('  new Uint32Array(scratch)[0] = numeric;');
        updateBody.push(`  state.uniforms.${member.name} = numeric;`);
        updateBody.push(`  state.buffer.updateUniform('${member.name}', new Float32Array(scratch), 1);`);
      } else {
        updateBody.push('  const flagged = !!raw;');
        updateBody.push('  const scratch = new ArrayBuffer(4);');
        updateBody.push('  new Int32Array(scratch)[0] = flagged ? 1 : 0;');
        updateBody.push(`  state.uniforms.${member.name} = flagged;`);
        updateBody.push(`  state.buffer.updateUniform('${member.name}', new Float32Array(scratch), 1);`);
      }
    } else {
      if (kind === 'f32') {
        updateBody.push(`  let view: Float32Array = raw instanceof Float32Array ? raw : Array.isArray(raw) ? new Float32Array(raw as readonly number[]) : new Float32Array(${slot});`);
        updateBody.push('  if (!(raw instanceof Float32Array) && !Array.isArray(raw) && typeof raw === "number") {');
        updateBody.push('    view[0] = raw;');
        updateBody.push('  }');
        updateBody.push(`  state.uniforms.${member.name} = view;`);
        updateBody.push(`  state.buffer.updateUniform('${member.name}', view, ${slot});`);
      } else if (kind === 'i32') {
        updateBody.push(`  const buffer = new ArrayBuffer(${slot} * 4);`);
        updateBody.push('  const view = new Int32Array(buffer);');
        updateBody.push('  if (raw instanceof Int32Array) {');
        updateBody.push('    view.set(raw.subarray(0, view.length));');
        updateBody.push('  } else if (Array.isArray(raw)) {');
        updateBody.push('    for (let i = 0; i < view.length; i++) {');
        updateBody.push('      const component = raw[i];');
        updateBody.push('      view[i] = component !== undefined ? Math.trunc(component as number) : 0;');
        updateBody.push('    }');
        updateBody.push('  } else if (typeof raw === "number") {');
        updateBody.push('    view[0] = Math.trunc(raw);');
        updateBody.push('  }');
        updateBody.push(`  state.uniforms.${member.name} = view;`);
        updateBody.push(`  state.buffer.updateUniform('${member.name}', new Float32Array(buffer), ${slot});`);
      } else if (kind === 'u32') {
        updateBody.push(`  const buffer = new ArrayBuffer(${slot} * 4);`);
        updateBody.push('  const view = new Uint32Array(buffer);');
        updateBody.push('  if (raw instanceof Uint32Array) {');
        updateBody.push('    view.set(raw.subarray(0, view.length));');
        updateBody.push('  } else if (Array.isArray(raw)) {');
        updateBody.push('    for (let i = 0; i < view.length; i++) {');
        updateBody.push('      const component = raw[i];');
        updateBody.push('      view[i] = component !== undefined ? Math.trunc(component as number) >>> 0 : 0;');
        updateBody.push('    }');
        updateBody.push('  } else if (typeof raw === "number") {');
        updateBody.push('    view[0] = Math.trunc(raw) >>> 0;');
        updateBody.push('  }');
        updateBody.push(`  state.uniforms.${member.name} = view;`);
        updateBody.push(`  state.buffer.updateUniform('${member.name}', new Float32Array(buffer), ${slot});`);
      } else {
        updateBody.push(`  const buffer = new ArrayBuffer(${slot} * 4);`);
        updateBody.push('  const view = new Int32Array(buffer);');
        updateBody.push('  if (raw instanceof Int32Array) {');
        updateBody.push('    view.set(raw.subarray(0, view.length));');
        updateBody.push('  } else if (Array.isArray(raw)) {');
        updateBody.push('    for (let i = 0; i < view.length; i++) {');
        updateBody.push('      const component = raw[i];');
        updateBody.push('      view[i] = component ? 1 : 0;');
        updateBody.push('    }');
        updateBody.push('  } else {');
        updateBody.push('    view[0] = raw ? 1 : 0;');
        updateBody.push('  }');
        updateBody.push(`  state.uniforms.${member.name} = view;`);
        updateBody.push(`  state.buffer.updateUniform('${member.name}', new Float32Array(buffer), ${slot});`);
      }
    }
    updateBody.push('}');
  });
  updateBody.push('if (dirty) {');
  updateBody.push('  state.buffer.update();');
  updateBody.push('}');

  const interfaceLines = structMembers.map((member) => {
    const mapping = mappingFor(member.type);
    const tsType = mapping ? mapping.tsType : 'number';
    return `${member.name}: ${tsType};`;
  });

  return [
    `const ${layoutName} = [`,
    layoutArray.join(',\n'),
    '] as const;',
    '',
    `export interface ${interfaceName} {`,
    indent(interfaceLines),
    '}',
    '',
    `export interface ${stateName} {`,
    '  buffer: BABYLON.UniformBuffer;',
    `  uniforms: ${interfaceName};`,
    '}',
    '',
    `export function ${createFn}(engine: BABYLON.WebGPUEngine, initial?: Partial<${interfaceName}>): ${stateName} {`,
    indent(createBody),
    '}',
    '',
    `export function ${updateFn}(state: ${stateName}, updates: Partial<${interfaceName}>): void {`,
    indent(updateBody),
    '}',
  ].join('\n');
}


function generateStorageBlock(descriptor: StorageDescriptor, structDescriptor: StructDescriptor | undefined): string {
  const { stateName, createFn, updateFn, writeFn, valueType } = descriptor;
  const byteStrideValue = structDescriptor ? structDescriptor.struct.size : descriptor.variable.stride || 0;

  const createBody: string[] = [];
  createBody.push(`const byteStride = ${byteStrideValue};`);
  createBody.push('const floatsPerElement = byteStride / Float32Array.BYTES_PER_ELEMENT;');
  createBody.push('const totalFloats = floatsPerElement * capacity;');
  createBody.push('const data = new Float32Array(totalFloats);');
  createBody.push('const usage = options?.usage ?? (BABYLON.Constants.BUFFER_CREATIONFLAG_STORAGE | BABYLON.Constants.BUFFER_CREATIONFLAG_WRITE);');
  createBody.push('const buffer = new BABYLON.StorageBuffer(engine, byteStride * capacity, usage);');
  createBody.push('if (options?.initial) {');
  if (structDescriptor) {
    createBody.push('  options.initial.slice(0, capacity).forEach((value, index) => {');
    createBody.push(`    ${structDescriptor.packFn}(data, index * floatsPerElement, value);`);
    createBody.push('  });');
  } else {
    createBody.push('  data.set(options.initial.flat().slice(0, totalFloats));');
  }
  createBody.push('  buffer.update(data);');
  createBody.push('}');
  createBody.push('return { buffer, data, capacity, floatsPerElement };');

  const writeBody: string[] = [];
  if (structDescriptor) {
    writeBody.push(`const offset = index * state.floatsPerElement;`);
    writeBody.push(`${structDescriptor.packFn}(state.data, offset, value);`);
  } else {
    writeBody.push('const offset = index * state.floatsPerElement;');
    writeBody.push('for (let i = 0; i < state.floatsPerElement; i++) {');
    writeBody.push('  state.data[offset + i] = value[i] ?? 0;');
    writeBody.push('}');
  }

  return [
    `export interface ${stateName} {`,
    '  buffer: BABYLON.StorageBuffer;',
    '  data: Float32Array;',
    '  capacity: number;',
    '  floatsPerElement: number;',
    '}',
    '',
    `export function ${createFn}(engine: BABYLON.WebGPUEngine, capacity: number, options?: { initial?: ${valueType}[]; usage?: number; }): ${stateName} {`,
    indent(createBody),
    '}',
    '',
    `export function ${writeFn}(state: ${stateName}, index: number, value: ${valueType}): void {`,
    indent(writeBody),
    '}',
    '',
    `export function ${updateFn}(state: ${stateName}): void {`,
    indent(['state.buffer.update(state.data);']),
    '}',
  ].join('\n');
}

function classify(variable: VariableInfo): 'storage' | 'uniform' | 'texture' | 'sampler' | 'storageTexture' {
  switch (variable.resourceType) {
    case ResourceType.Uniform:
      return 'uniform';
    case ResourceType.Storage:
      return 'storage';
    case ResourceType.Texture:
      return 'texture';
    case ResourceType.Sampler:
      return 'sampler';
    case ResourceType.StorageTexture:
      return 'storageTexture';
    default:
      return 'storage';
  }
}

function generateShaderFactory(
  shaderIdentifier: string,
  shaderPrefix: string,
  shaderSourceImport: string,
  bindings: Array<{ variable: VariableInfo; kind: ReturnType<typeof classify>; typeRef: string }>,
  uniforms: UniformDescriptor[],
): string {
  const mappingEntries = bindings.map((entry) => `    ${entry.variable.name}: { group: ${entry.variable.group}, binding: ${entry.variable.binding} }`);

  const interfaceLines = bindings.map((entry) => {
    if (entry.kind === 'uniform') {
      const uniform = uniforms.find((u) => u.variable === entry.variable);
      return `  ${entry.variable.name}: ${uniform ? uniform.stateName : 'BABYLON.UniformBuffer'};`;
    }
    return `  ${entry.variable.name}: ${entry.typeRef};`;
  });

  const bindingAssignments: string[] = [];
  bindings.forEach((entry) => {
    const name = entry.variable.name;
    switch (entry.kind) {
      case 'storage':
        bindingAssignments.push(`shader.setStorageBuffer('${name}', bindings.${name});`);
        break;
      case 'uniform': {
        const uniform = uniforms.find((u) => u.variable === entry.variable);
        if (uniform) {
          bindingAssignments.push(`shader.setUniformBuffer('${name}', bindings.${name}.buffer);`);
        } else {
          bindingAssignments.push(`shader.setUniformBuffer('${name}', bindings.${name});`);
        }
        break;
      }
      case 'texture':
        bindingAssignments.push(`shader.setTexture('${name}', bindings.${name}, false);`);
        break;
      case 'sampler':
        bindingAssignments.push(`shader.setTextureSampler('${name}', bindings.${name});`);
        break;
      case 'storageTexture':
        bindingAssignments.push(`shader.setStorageTexture('${name}', bindings.${name});`);
        break;
      default:
        break;
    }
  });

  const updateLines: string[] = [];
  bindings.forEach((entry) => {
    const name = entry.variable.name;
    updateLines.push(`if (updates.${name} !== undefined) {`);
    switch (entry.kind) {
      case 'storage':
        updateLines.push(`  state.bindings.${name} = updates.${name}!;`);
        updateLines.push(`  state.shader.setStorageBuffer('${name}', updates.${name}!);`);
        break;
      case 'uniform': {
        const uniform = uniforms.find((u) => u.variable === entry.variable);
        if (uniform) {
          updateLines.push(`  state.bindings.${name} = updates.${name}!;`);
          updateLines.push(`  state.shader.setUniformBuffer('${name}', updates.${name}!.buffer);`);
        } else {
          updateLines.push(`  state.bindings.${name} = updates.${name}!;`);
          updateLines.push(`  state.shader.setUniformBuffer('${name}', updates.${name}!);`);
        }
        break;
      }
      case 'texture':
        updateLines.push(`  state.bindings.${name} = updates.${name}!;`);
        updateLines.push(`  state.shader.setTexture('${name}', updates.${name}!, false);`);
        break;
      case 'sampler':
        updateLines.push(`  state.bindings.${name} = updates.${name}!;`);
        updateLines.push(`  state.shader.setTextureSampler('${name}', updates.${name}!);`);
        break;
      case 'storageTexture':
        updateLines.push(`  state.bindings.${name} = updates.${name}!;`);
        updateLines.push(`  state.shader.setStorageTexture('${name}', updates.${name}!);`);
        break;
      default:
        updateLines.push('  // Unsupported binding');
        break;
    }
    updateLines.push('}');
  });

  const bindingInterfaceName = 'ShaderBindings';
  const stateInterfaceName = 'ShaderState';
  const createFunctionName = 'createShader';
  const updateFunctionName = 'updateBindings';

  return [
    'const bindingLayout = {',
    mappingEntries.join(',\n'),
    '};',
    '',
    `export interface ${bindingInterfaceName} {`,
    indent(interfaceLines),
    '}',
    '',
    `export interface ${stateInterfaceName} {`,
    '  shader: BABYLON.ComputeShader;',
    `  bindings: ${bindingInterfaceName};`,
    '}',
    '',
    `export function ${createFunctionName}(engine: BABYLON.WebGPUEngine, bindings: ${bindingInterfaceName}, options?: { entryPoint?: string; source?: string; name?: string; }): ${stateInterfaceName} {`,
    indent([
      `const shader = new BABYLON.ComputeShader(options?.name ?? '${shaderIdentifier}', engine, { computeSource: options?.source ?? ${shaderSourceImport} }, {`,
      "  entryPoint: options?.entryPoint ?? 'main',",
      '  bindingsMapping: bindingLayout,',
      '});',
      ...bindingAssignments,
      'return { shader, bindings };',
    ]),
    '}',
    '',
    `export function ${updateFunctionName}(state: ${stateInterfaceName}, updates: Partial<${bindingInterfaceName}>): void {`,
    indent(updateLines.length ? updateLines : ['// Nothing to update']),
    '}',
  ].join('\n');
}

async function ensureDir(filePath: string): Promise<void> {
  await fs.mkdir(path.dirname(filePath), { recursive: true });
}

export async function generateShaderTypes(
  sourcePath: string,
  options: GenerateShaderTypesOptions,
): Promise<GenerateShaderTypesResult> {
  const { projectRoot, outputExtension = DEFAULT_OUTPUT_SUFFIX, logger } = options;
  const absoluteSource = path.resolve(sourcePath);
  const shaderCode = await fs.readFile(absoluteSource, 'utf8');
  const reflect = new WgslReflect(shaderCode);

  const baseName = path.basename(sourcePath, path.extname(sourcePath));
  const sanitizedBaseName = baseName.replace(/\.compute$/i, '');
  const shaderPrefix = toPascalCase(sanitizedBaseName);
  const outputPath = path.join(path.dirname(absoluteSource), `${path.basename(sourcePath)}${outputExtension}`);
  const relativeOutput = path.relative(projectRoot, outputPath);

  const usedStructs = reflect.structs.filter((s) => s.inUse);
  const structDescriptors = usedStructs.map<StructDescriptor>((struct) => ({
    struct,
    interfaceName: `${shaderPrefix}${struct.name}`,
    layoutName: `${shaderPrefix}${struct.name}Layout`,
    packFn: `pack${shaderPrefix}${struct.name}`,
  }));

  const structDescriptorMap = new Map<string, StructDescriptor>();
  structDescriptors.forEach((descriptor) => {
    structDescriptorMap.set(descriptor.struct.name, descriptor);
  });

  const structBlocks = structDescriptors.map((descriptor) => generateStructBlock(shaderPrefix, descriptor, structDescriptorMap));

  const uniformDescriptors: UniformDescriptor[] = reflect.uniforms.map((variable) => {
    const pascalName = toPascalCase(variable.name);
    return {
      variable,
      interfaceName: `${pascalName}Uniforms`,
      stateName: `${pascalName}UniformState`,
      layoutName: `uniformLayout_${variable.name}`,
      createFn: `createUniformBuffer_${variable.name}`,
      updateFn: `updateUniformBuffer_${variable.name}`,
      aliasCreate: undefined,
      aliasUpdate: undefined,
    };
  });

  if (uniformDescriptors.length === 1) {
    uniformDescriptors[0].aliasCreate = 'createUniformBuffer';
    uniformDescriptors[0].aliasUpdate = 'updateUniformBuffer';
  }

  const uniformBlocks = uniformDescriptors.map((descriptor) => {
    const struct = structDescriptors.find((entry) => entry.struct.name === descriptor.variable.type.getTypeName());
    return generateUniformBlock(descriptor, struct);
  });

  const storageDescriptors: StorageDescriptor[] = reflect.storage.map((variable) => {
    const pascalName = toPascalCase(variable.name);
    const struct = structDescriptors.find((entry) => entry.struct.name === variable.format?.getTypeName());
    const valueType = struct ? struct.interfaceName : 'number[]';
    return {
      variable,
      stateName: `${pascalName}StorageState`,
      layoutName: struct ? struct.layoutName : `storageLayout_${variable.name}`,
      createFn: `createStorageBuffer_${variable.name}`,
      updateFn: `updateStorageBuffer_${variable.name}`,
      writeFn: `writeStorageValue_${variable.name}`,
      valueType,
    };
  });

  const storageBlocks = storageDescriptors.map((descriptor) => {
    const struct = structDescriptors.find((entry) => entry.struct.name === descriptor.variable.format?.getTypeName());
    return generateStorageBlock(descriptor, struct);
  });

  const sampledTextureVariables = reflect.textures.filter((variable) => variable.resourceType === ResourceType.Texture);
  const storageTextureVariablesReflect = reflect.textures.filter((variable) => variable.resourceType === ResourceType.StorageTexture);

  const textureDescriptors = sampledTextureVariables.map((variable) => ({
    variable,
    kind: classify(variable),
    typeRef: 'BABYLON.BaseTexture',
  }));

  const samplerDescriptors = reflect.samplers.map((variable) => ({
    variable,
    kind: classify(variable),
    typeRef: 'BABYLON.TextureSampler',
  }));

  const storageTextureDescriptors = storageTextureVariablesReflect.map((variable) => ({
    variable,
    kind: classify(variable),
    typeRef: 'BABYLON.StorageTexture',
  }));

  const shaderBindings = [
    ...reflect.uniforms.map((variable) => ({
      variable,
      kind: classify(variable),
      typeRef: 'BABYLON.UniformBuffer',
    })),
    ...reflect.storage.map((variable) => ({
      variable,
      kind: classify(variable),
      typeRef: 'BABYLON.StorageBuffer',
    })),
    ...textureDescriptors,
    ...samplerDescriptors,
    ...storageTextureDescriptors,
  ];

  const shaderFactory = generateShaderFactory(
    sanitizedBaseName,
    shaderPrefix,
    'shaderSource',
    shaderBindings,
    uniformDescriptors,
  );

  const aliasLines = uniformDescriptors
    .filter((descriptor) => descriptor.aliasCreate && descriptor.aliasUpdate)
    .map((descriptor) =>
      [`export const ${descriptor.aliasCreate} = ${descriptor.createFn};`, `export const ${descriptor.aliasUpdate} = ${descriptor.updateFn};`].join('\n'),
    );

  const fileSections: string[] = [
    HEADER_COMMENT,
    "import * as BABYLON from 'babylonjs';",
    `import shaderSource from './${path.basename(sourcePath)}?raw';`,
    '',
    ...structBlocks,
    structBlocks.length ? '' : '',
    ...uniformBlocks,
    uniformBlocks.length ? '' : '',
    ...storageBlocks,
    storageBlocks.length ? '' : '',
    shaderFactory,
    aliasLines.join('\n'),
  ].filter((section) => section !== '');

  const content = fileSections.join('\n\n');

  await ensureDir(outputPath);

  let updated = true;
  try {
    const existing = await fs.readFile(outputPath, 'utf8');
    if (existing === content) {
      updated = false;
    }
  } catch {
    // ignore missing file
  }

  if (updated) {
    await fs.writeFile(outputPath, content, 'utf8');
    logger?.(`Generated ${relativeOutput}`);
  }

  return {
    sourcePath: absoluteSource,
    outputPath,
    updated,
  };
}
