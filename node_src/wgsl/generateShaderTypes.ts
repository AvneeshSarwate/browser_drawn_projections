import { promises as fs } from 'node:fs';
import * as path from 'node:path';
import {
  ResourceType,
  StructInfo,
  TypeInfo,
  VariableInfo,
  WgslReflect,
} from 'wgsl_reflect';

type Logger = (message: string) => void;

export interface GenerateShaderTypesOptions {
  projectRoot: string;
  outputExtension?: string;
  logger?: Logger;
}

export interface GenerateShaderTypesResult {
  sourcePath: string;
  outputPath: string;
  updated: boolean;
}

const DEFAULT_OUTPUT_SUFFIX = '.generated.ts';

interface TypeMapping {
  tsType: string;
  slotCount: number;
  valueLength: number;
  defaultExpression: string;
}

function floatVectorMapping(componentCount: number, slotCount?: number): TypeMapping {
  const requiredSlots = slotCount ?? componentCount;
  return {
    tsType: 'Float32Array',
    slotCount: requiredSlots,
    valueLength: componentCount,
    defaultExpression: `new Float32Array(${requiredSlots})`,
  };
}

const TYPE_MAP: Record<string, TypeMapping> = {
  f32: { tsType: 'number', slotCount: 1, valueLength: 1, defaultExpression: '0' },
  i32: { tsType: 'number', slotCount: 1, valueLength: 1, defaultExpression: '0' },
  u32: { tsType: 'number', slotCount: 1, valueLength: 1, defaultExpression: '0' },
  bool: { tsType: 'boolean', slotCount: 1, valueLength: 1, defaultExpression: 'false' },
  vec2f: floatVectorMapping(2),
  vec3f: floatVectorMapping(3, 4),
  vec4f: floatVectorMapping(4),
  mat4x4f: floatVectorMapping(16),
};

const HEADER_COMMENT = '// Auto-generated by wgsl type generator. DO NOT EDIT.';

interface StructDescriptor {
  struct: StructInfo;
  interfaceName: string;
  layoutName: string;
  packFn: string;
}

interface UniformDescriptor {
  variable: VariableInfo;
  interfaceName: string;
  stateName: string;
  layoutName: string;
  createFn: string;
  updateFn: string;
  aliasCreate?: string;
  aliasUpdate?: string;
}

interface StorageDescriptor {
  variable: VariableInfo;
  stateName: string;
  layoutName: string;
  createFn: string;
  updateFn: string;
  writeFn: string;
  valueType: string;
}

function toPascalCase(value: string): string {
  return value
    .replace(/[-_]/g, ' ')
    .split(' ')
    .filter(Boolean)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
}

function indent(lines: string[], spaces = 2): string {
  const pad = ' '.repeat(spaces);
  return lines
    .map((line) => (line.length > 0 ? pad + line : line))
    .join('\n');
}

function mappingFor(type: TypeInfo): TypeMapping | null {
  const name = type.getTypeName();
  if (TYPE_MAP[name]) {
    return TYPE_MAP[name];
  }
  return null;
}

function generateStructBlock(prefix: string, descriptor: StructDescriptor): string {
  const { struct, interfaceName, layoutName, packFn } = descriptor;
  const interfaceLines = struct.members.map((member) => {
    const mapping = mappingFor(member.type);
    const tsType = mapping ? mapping.tsType : 'number';
    return `${member.name}: ${tsType};`;
  });

  const layoutMembers = struct.members.map((member) => {
    const mapping = mappingFor(member.type);
    const slot = mapping ? mapping.slotCount : member.size / 4;
    return `  { name: '${member.name}', offset: ${member.offset}, size: ${member.size}, slot: ${slot} }`;
  });

  const packLines: string[] = [];
  packLines.push('let offset = floatOffset;');
  struct.members.forEach((member) => {
    const mapping = mappingFor(member.type);
    const floatOffset = member.offset / 4;
    packLines.push(`offset = floatOffset + ${floatOffset};`);
    if (!mapping) {
      packLines.push(`// ${member.name}: unsupported type`);
      return;
    }
    if (mapping.slotCount === 1) {
      if (mapping.tsType === 'boolean') {
        packLines.push(`target[offset] = value.${member.name} ? 1 : 0;`);
      } else {
        packLines.push(`target[offset] = value.${member.name} as number;`);
      }
      return;
    }
    packLines.push(`const ${member.name}Value = Array.isArray(value.${member.name}) ? value.${member.name} : Array.from(value.${member.name} as any);`);
    packLines.push(`for (let i = 0; i < ${mapping.slotCount}; i++) {`);
    packLines.push(`  target[offset + i] = ${member.name}Value[i] ?? 0;`);
    packLines.push('}');
  });

  return [
    `export interface ${interfaceName} {`,
    indent(interfaceLines),
    '}',
    '',
    `export const ${layoutName} = {`,
    `  size: ${struct.size},`,
    `  align: ${struct.align},`,
    '  members: [',
    layoutMembers.join(',\n'),
    '  ] as const,',
    '} as const;',
    '',
    `export function ${packFn}(target: Float32Array, floatOffset: number, value: ${interfaceName}): void {`,
    indent(packLines.length ? packLines : ['// No supported members']),
    '}',
  ].join('\n');
}

function generateUniformBlock(descriptor: UniformDescriptor, structDescriptor: StructDescriptor | undefined): string {
  const { interfaceName, stateName, layoutName, createFn, updateFn } = descriptor;
  const structMembers = structDescriptor?.struct.members ?? [];

  const layoutArray = structMembers.map((member) => {
    const mapping = mappingFor(member.type);
    const slot = mapping ? mapping.slotCount : member.size / 4;
    return `  { name: '${member.name}', slot: ${slot} }`;
  });

  const defaultAssignments = structMembers.map((member) => {
    const mapping = mappingFor(member.type);
    const defaultExpr = mapping ? mapping.defaultExpression : '0';
    return `  ${member.name}: ${defaultExpr},`;
  });

  const createBody: string[] = [];
  createBody.push('const buffer = new BABYLON.UniformBuffer(engine);');
  createBody.push(`const uniforms: ${interfaceName} = {`);
  createBody.push(...defaultAssignments);
  createBody.push('};');
  createBody.push(`for (const entry of ${layoutName}) {`);
  createBody.push('  buffer.addUniform(entry.name, entry.slot);');
  createBody.push('}');
  createBody.push('if (initial) {');
  createBody.push(`  ${updateFn}({ buffer, uniforms }, initial);`);
  createBody.push('} else {');
  createBody.push('  buffer.update();');
  createBody.push('}');
  createBody.push('return { buffer, uniforms };');

  const updateBody: string[] = [];
  updateBody.push('let dirty = false;');
  updateBody.push(`for (const entry of ${layoutName}) {`);
  updateBody.push(`  const key = entry.name as keyof ${interfaceName};`);
  updateBody.push('  if (updates[key] === undefined) {');
  updateBody.push('    continue;');
  updateBody.push('  }');
  updateBody.push('  dirty = true;');
  updateBody.push('  const raw = updates[key]! as unknown;');
  updateBody.push('  if (entry.slot > 1) {');
  updateBody.push('    let arrayValue: Float32Array;');
  updateBody.push('    if (raw instanceof Float32Array) {');
  updateBody.push('      arrayValue = raw;');
  updateBody.push('    } else if (Array.isArray(raw)) {');
  updateBody.push('      arrayValue = new Float32Array(raw as number[]);');
  updateBody.push('    } else if (typeof raw === "number") {');
  updateBody.push('      arrayValue = new Float32Array(entry.slot);');
  updateBody.push('      arrayValue[0] = raw;');
  updateBody.push('    } else {');
  updateBody.push('      arrayValue = new Float32Array(entry.slot);');
  updateBody.push('    }');
  updateBody.push('    state.uniforms[key] = arrayValue as any;');
  updateBody.push('    state.buffer.updateUniform(entry.name, arrayValue, entry.slot);');
  updateBody.push('  } else if (typeof raw === "boolean") {');
  updateBody.push('    const numeric = raw ? 1 : 0;');
  updateBody.push('    state.uniforms[key] = raw as any;');
  updateBody.push('    state.buffer.updateUniform(entry.name, [numeric], entry.slot);');
  updateBody.push('  } else {');
  updateBody.push('    const numeric = typeof raw === "number" ? raw : 0;');
  updateBody.push('    state.uniforms[key] = numeric as any;');
  updateBody.push('    state.buffer.updateUniform(entry.name, [numeric], entry.slot);');
  updateBody.push('  }');
  updateBody.push('}');
  updateBody.push('if (dirty) {');
  updateBody.push('  state.buffer.update();');
  updateBody.push('}');

  const interfaceLines = structMembers.map((member) => {
    const mapping = mappingFor(member.type);
    const tsType = mapping ? mapping.tsType : 'number';
    return `${member.name}: ${tsType};`;
  });

  return [
    `const ${layoutName} = [`,
    layoutArray.join(',\n'),
    '] as const;',
    '',
    `export interface ${interfaceName} {`,
    indent(interfaceLines),
    '}',
    '',
    `export interface ${stateName} {`,
    '  buffer: BABYLON.UniformBuffer;',
    `  uniforms: ${interfaceName};`,
    '}',
    '',
    `export function ${createFn}(engine: BABYLON.WebGPUEngine, initial?: Partial<${interfaceName}>): ${stateName} {`,
    indent(createBody),
    '}',
    '',
    `export function ${updateFn}(state: ${stateName}, updates: Partial<${interfaceName}>): void {`,
    indent(updateBody),
    '}',
  ].join('\n');
}

function generateStorageBlock(descriptor: StorageDescriptor, structDescriptor: StructDescriptor | undefined): string {
  const { stateName, createFn, updateFn, writeFn, valueType } = descriptor;
  const byteStrideValue = structDescriptor ? structDescriptor.struct.size : descriptor.variable.stride || 0;

  const createBody: string[] = [];
  createBody.push(`const byteStride = ${byteStrideValue};`);
  createBody.push('const floatsPerElement = byteStride / Float32Array.BYTES_PER_ELEMENT;');
  createBody.push('const totalFloats = floatsPerElement * capacity;');
  createBody.push('const data = new Float32Array(totalFloats);');
  createBody.push('const usage = options?.usage ?? (BABYLON.Constants.BUFFER_CREATIONFLAG_STORAGE | BABYLON.Constants.BUFFER_CREATIONFLAG_WRITE);');
  createBody.push('const buffer = new BABYLON.StorageBuffer(engine, byteStride * capacity, usage);');
  createBody.push('if (options?.initial) {');
  if (structDescriptor) {
    createBody.push('  options.initial.slice(0, capacity).forEach((value, index) => {');
    createBody.push(`    ${structDescriptor.packFn}(data, index * floatsPerElement, value);`);
    createBody.push('  });');
  } else {
    createBody.push('  data.set(options.initial.flat().slice(0, totalFloats));');
  }
  createBody.push('  buffer.update(data);');
  createBody.push('}');
  createBody.push('return { buffer, data, capacity, floatsPerElement };');

  const writeBody: string[] = [];
  if (structDescriptor) {
    writeBody.push(`const offset = index * state.floatsPerElement;`);
    writeBody.push(`${structDescriptor.packFn}(state.data, offset, value);`);
  } else {
    writeBody.push('const offset = index * state.floatsPerElement;');
    writeBody.push('for (let i = 0; i < state.floatsPerElement; i++) {');
    writeBody.push('  state.data[offset + i] = value[i] ?? 0;');
    writeBody.push('}');
  }

  return [
    `export interface ${stateName} {`,
    '  buffer: BABYLON.StorageBuffer;',
    '  data: Float32Array;',
    '  capacity: number;',
    '  floatsPerElement: number;',
    '}',
    '',
    `export function ${createFn}(engine: BABYLON.WebGPUEngine, capacity: number, options?: { initial?: ${valueType}[]; usage?: number; }): ${stateName} {`,
    indent(createBody),
    '}',
    '',
    `export function ${writeFn}(state: ${stateName}, index: number, value: ${valueType}): void {`,
    indent(writeBody),
    '}',
    '',
    `export function ${updateFn}(state: ${stateName}): void {`,
    indent(['state.buffer.update(state.data);']),
    '}',
  ].join('\n');
}

function classify(variable: VariableInfo): 'storage' | 'uniform' | 'texture' | 'sampler' | 'storageTexture' {
  switch (variable.resourceType) {
    case ResourceType.Uniform:
      return 'uniform';
    case ResourceType.Storage:
      return 'storage';
    case ResourceType.Texture:
      return 'texture';
    case ResourceType.Sampler:
      return 'sampler';
    case ResourceType.StorageTexture:
      return 'storageTexture';
    default:
      return 'storage';
  }
}

function generateShaderFactory(
  shaderIdentifier: string,
  shaderPrefix: string,
  shaderSourceImport: string,
  bindings: Array<{ variable: VariableInfo; kind: ReturnType<typeof classify>; typeRef: string }>,
  uniforms: UniformDescriptor[],
): string {
  const mappingEntries = bindings.map((entry) => `    ${entry.variable.name}: { group: ${entry.variable.group}, binding: ${entry.variable.binding} }`);

  const interfaceLines = bindings.map((entry) => {
    if (entry.kind === 'uniform') {
      const uniform = uniforms.find((u) => u.variable === entry.variable);
      return `  ${entry.variable.name}: ${uniform ? uniform.stateName : 'BABYLON.UniformBuffer'};`;
    }
    return `  ${entry.variable.name}: ${entry.typeRef};`;
  });

  const bindingAssignments: string[] = [];
  bindings.forEach((entry) => {
    const name = entry.variable.name;
    switch (entry.kind) {
      case 'storage':
        bindingAssignments.push(`shader.setStorageBuffer('${name}', bindings.${name});`);
        break;
      case 'uniform': {
        const uniform = uniforms.find((u) => u.variable === entry.variable);
        if (uniform) {
          bindingAssignments.push(`shader.setUniformBuffer('${name}', bindings.${name}.buffer);`);
        } else {
          bindingAssignments.push(`shader.setUniformBuffer('${name}', bindings.${name});`);
        }
        break;
      }
      case 'texture':
        bindingAssignments.push(`shader.setTexture('${name}', bindings.${name}, false);`);
        break;
      case 'sampler':
        bindingAssignments.push(`shader.setTextureSampler('${name}', bindings.${name});`);
        break;
      case 'storageTexture':
        bindingAssignments.push(`shader.setStorageTexture('${name}', bindings.${name});`);
        break;
      default:
        break;
    }
  });

  const updateLines: string[] = [];
  bindings.forEach((entry) => {
    const name = entry.variable.name;
    updateLines.push(`if (updates.${name} !== undefined) {`);
    switch (entry.kind) {
      case 'storage':
        updateLines.push(`  state.bindings.${name} = updates.${name}!;`);
        updateLines.push(`  state.shader.setStorageBuffer('${name}', updates.${name}!);`);
        break;
      case 'uniform': {
        const uniform = uniforms.find((u) => u.variable === entry.variable);
        if (uniform) {
          updateLines.push(`  state.bindings.${name} = updates.${name}!;`);
          updateLines.push(`  state.shader.setUniformBuffer('${name}', updates.${name}!.buffer);`);
        } else {
          updateLines.push(`  state.bindings.${name} = updates.${name}!;`);
          updateLines.push(`  state.shader.setUniformBuffer('${name}', updates.${name}!);`);
        }
        break;
      }
      case 'texture':
        updateLines.push(`  state.bindings.${name} = updates.${name}!;`);
        updateLines.push(`  state.shader.setTexture('${name}', updates.${name}!, false);`);
        break;
      case 'sampler':
        updateLines.push(`  state.bindings.${name} = updates.${name}!;`);
        updateLines.push(`  state.shader.setTextureSampler('${name}', updates.${name}!);`);
        break;
      case 'storageTexture':
        updateLines.push(`  state.bindings.${name} = updates.${name}!;`);
        updateLines.push(`  state.shader.setStorageTexture('${name}', updates.${name}!);`);
        break;
      default:
        updateLines.push('  // Unsupported binding');
        break;
    }
    updateLines.push('}');
  });

  const bindingInterfaceName = 'ShaderBindings';
  const stateInterfaceName = 'ShaderState';
  const createFunctionName = 'createShader';
  const updateFunctionName = 'updateBindings';

  return [
    'const bindingLayout = {',
    mappingEntries.join(',\n'),
    '};',
    '',
    `export interface ${bindingInterfaceName} {`,
    indent(interfaceLines),
    '}',
    '',
    `export interface ${stateInterfaceName} {`,
    '  shader: BABYLON.ComputeShader;',
    `  bindings: ${bindingInterfaceName};`,
    '}',
    '',
    `export function ${createFunctionName}(engine: BABYLON.WebGPUEngine, bindings: ${bindingInterfaceName}, options?: { entryPoint?: string; source?: string; name?: string; }): ${stateInterfaceName} {`,
    indent([
      `const shader = new BABYLON.ComputeShader(options?.name ?? '${shaderIdentifier}', engine, { computeSource: options?.source ?? ${shaderSourceImport} }, {`,
      "  entryPoint: options?.entryPoint ?? 'main',",
      '  bindingsMapping: bindingLayout,',
      '});',
      ...bindingAssignments,
      'return { shader, bindings };',
    ]),
    '}',
    '',
    `export function ${updateFunctionName}(state: ${stateInterfaceName}, updates: Partial<${bindingInterfaceName}>): void {`,
    indent(updateLines.length ? updateLines : ['// Nothing to update']),
    '}',
  ].join('\n');
}

async function ensureDir(filePath: string): Promise<void> {
  await fs.mkdir(path.dirname(filePath), { recursive: true });
}

export async function generateShaderTypes(
  sourcePath: string,
  options: GenerateShaderTypesOptions,
): Promise<GenerateShaderTypesResult> {
  const { projectRoot, outputExtension = DEFAULT_OUTPUT_SUFFIX, logger } = options;
  const absoluteSource = path.resolve(sourcePath);
  const shaderCode = await fs.readFile(absoluteSource, 'utf8');
  const reflect = new WgslReflect(shaderCode);

  const shaderPrefix = toPascalCase(path.basename(sourcePath, path.extname(sourcePath)));
  const outputPath = path.join(path.dirname(absoluteSource), `${path.basename(sourcePath)}${outputExtension}`);
  const relativeOutput = path.relative(projectRoot, outputPath);

  const usedStructs = reflect.structs.filter((s) => s.inUse);
  const structDescriptors = usedStructs.map<StructDescriptor>((struct) => ({
    struct,
    interfaceName: `${shaderPrefix}${struct.name}`,
    layoutName: `${shaderPrefix}${struct.name}Layout`,
    packFn: `pack${shaderPrefix}${struct.name}`,
  }));

  const structBlocks = structDescriptors.map((descriptor) => generateStructBlock(shaderPrefix, descriptor));

  const uniformDescriptors: UniformDescriptor[] = reflect.uniforms.map((variable) => {
    const pascalName = toPascalCase(variable.name);
    return {
      variable,
      interfaceName: `${pascalName}Uniforms`,
      stateName: `${pascalName}UniformState`,
      layoutName: `uniformLayout_${variable.name}`,
      createFn: `createUniformBuffer_${variable.name}`,
      updateFn: `updateUniformBuffer_${variable.name}`,
      aliasCreate: undefined,
      aliasUpdate: undefined,
    };
  });

  if (uniformDescriptors.length === 1) {
    uniformDescriptors[0].aliasCreate = 'createUniformBuffer';
    uniformDescriptors[0].aliasUpdate = 'updateUniformBuffer';
  }

  const uniformBlocks = uniformDescriptors.map((descriptor) => {
    const struct = structDescriptors.find((entry) => entry.struct.name === descriptor.variable.type.getTypeName());
    return generateUniformBlock(descriptor, struct);
  });

  const storageDescriptors: StorageDescriptor[] = reflect.storage.map((variable) => {
    const pascalName = toPascalCase(variable.name);
    const struct = structDescriptors.find((entry) => entry.struct.name === variable.format?.getTypeName());
    const valueType = struct ? struct.interfaceName : 'number[]';
    return {
      variable,
      stateName: `${pascalName}StorageState`,
      layoutName: struct ? struct.layoutName : `storageLayout_${variable.name}`,
      createFn: `createStorageBuffer_${variable.name}`,
      updateFn: `updateStorageBuffer_${variable.name}`,
      writeFn: `writeStorageValue_${variable.name}`,
      valueType,
    };
  });

  const storageBlocks = storageDescriptors.map((descriptor) => {
    const struct = structDescriptors.find((entry) => entry.struct.name === descriptor.variable.format?.getTypeName());
    return generateStorageBlock(descriptor, struct);
  });

  const textureDescriptors = reflect.textures.map((variable) => ({
    variable,
    kind: classify(variable),
    typeRef: 'BABYLON.BaseTexture',
  }));

  const samplerDescriptors = reflect.samplers.map((variable) => ({
    variable,
    kind: classify(variable),
    typeRef: 'BABYLON.TextureSampler',
  }));

  const shaderBindings = [
    ...reflect.uniforms.map((variable) => ({
      variable,
      kind: classify(variable),
      typeRef: 'BABYLON.UniformBuffer',
    })),
    ...reflect.storage.map((variable) => ({
      variable,
      kind: classify(variable),
      typeRef: 'BABYLON.StorageBuffer',
    })),
    ...textureDescriptors,
    ...samplerDescriptors,
  ];

  const shaderFactory = generateShaderFactory(
    path.basename(sourcePath, path.extname(sourcePath)),
    shaderPrefix,
    'shaderSource',
    shaderBindings,
    uniformDescriptors,
  );

  const aliasLines = uniformDescriptors
    .filter((descriptor) => descriptor.aliasCreate && descriptor.aliasUpdate)
    .map((descriptor) =>
      [`export const ${descriptor.aliasCreate} = ${descriptor.createFn};`, `export const ${descriptor.aliasUpdate} = ${descriptor.updateFn};`].join('\n'),
    );

  const fileSections: string[] = [
    HEADER_COMMENT,
    "import * as BABYLON from 'babylonjs';",
    `import shaderSource from './${path.basename(sourcePath)}?raw';`,
    '',
    ...structBlocks,
    structBlocks.length ? '' : '',
    ...uniformBlocks,
    uniformBlocks.length ? '' : '',
    ...storageBlocks,
    storageBlocks.length ? '' : '',
    shaderFactory,
    aliasLines.join('\n'),
  ].filter((section) => section !== '');

  const content = fileSections.join('\n\n');

  await ensureDir(outputPath);

  let updated = true;
  try {
    const existing = await fs.readFile(outputPath, 'utf8');
    if (existing === content) {
      updated = false;
    }
  } catch {
    // ignore missing file
  }

  if (updated) {
    await fs.writeFile(outputPath, content, 'utf8');
    logger?.(`Generated ${relativeOutput}`);
  }

  return {
    sourcePath: absoluteSource,
    outputPath,
    updated,
  };
}
