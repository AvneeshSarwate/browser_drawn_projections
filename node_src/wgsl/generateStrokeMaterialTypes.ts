import { promises as fs } from 'node:fs';
import * as path from 'node:path';
import { ArgumentInfo, StructInfo, WgslReflect } from 'wgsl_reflect';

type Logger = (message: string) => void;

export interface GenerateStrokeMaterialTypesOptions {
  projectRoot: string;
  logger?: Logger;
}

export interface GenerateStrokeMaterialTypesResult {
  sourcePath: string;
  outputPath: string;
  updated: boolean;
}

const RAW_SUFFIX = '.strokeMaterial.wgsl';
const OUTPUT_SUFFIX = '.generated.ts';
const HEADER_COMMENT = '// Auto-generated by power2d stroke material generator. DO NOT EDIT.';

interface UniformField {
  name: string;
  bindingName: string;
  wgslType: string;
}

interface UniformTypeMetadata {
  tsType: string;
  setter: string;
  expression: (valueRef: string) => string;
  helper?: string;
  defaultValue: string;
}

interface TextureParam {
  textureName: string;
  samplerName: string;
}

const UNIFORM_TYPE_MAP: Record<string, UniformTypeMetadata> = {
  f32: {
    tsType: 'number',
    setter: 'setFloat',
    expression: (valueRef) => valueRef,
    defaultValue: '0',
  },
  i32: {
    tsType: 'number',
    setter: 'setInt',
    expression: (valueRef) => valueRef,
    defaultValue: '0',
  },
  u32: {
    tsType: 'number',
    setter: 'setUInt',
    expression: (valueRef) => valueRef,
    defaultValue: '0',
  },
  bool: {
    tsType: 'boolean',
    setter: 'setFloat',
    expression: (valueRef) => `(${valueRef} ? 1 : 0)`,
    defaultValue: 'false',
  },
  vec2f: {
    tsType: 'BABYLON.Vector2 | readonly [number, number]',
    setter: 'setVector2',
    expression: (valueRef) => `ensureVector2(${valueRef})`,
    helper: 'ensureVector2',
    defaultValue: '[0, 0]',
  },
  vec3f: {
    tsType: 'BABYLON.Vector3 | readonly [number, number, number]',
    setter: 'setVector3',
    expression: (valueRef) => `ensureVector3(${valueRef})`,
    helper: 'ensureVector3',
    defaultValue: '[0, 0, 0]',
  },
  vec4f: {
    tsType: 'BABYLON.Vector4 | readonly [number, number, number, number]',
    setter: 'setVector4',
    expression: (valueRef) => `ensureVector4(${valueRef})`,
    helper: 'ensureVector4',
    defaultValue: '[0, 0, 0, 0]',
  },
  mat4x4f: {
    tsType: 'BABYLON.Matrix | Float32Array | readonly number[]',
    setter: 'setMatrix',
    expression: (valueRef) => `ensureMatrix(${valueRef})`,
    helper: 'ensureMatrix',
    defaultValue: 'new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])',
  },
};

const HELPER_SNIPPETS: Record<string, string> = {
  ensureVector2: `function ensureVector2(value: BABYLON.Vector2 | readonly [number, number]): BABYLON.Vector2 {\n  return value instanceof BABYLON.Vector2 ? value : BABYLON.Vector2.FromArray(value as readonly [number, number]);\n}`,
  ensureVector3: `function ensureVector3(value: BABYLON.Vector3 | readonly [number, number, number]): BABYLON.Vector3 {\n  return value instanceof BABYLON.Vector3 ? value : BABYLON.Vector3.FromArray(value as readonly [number, number, number]);\n}`,
  ensureVector4: `function ensureVector4(value: BABYLON.Vector4 | readonly [number, number, number, number]): BABYLON.Vector4 {\n  return value instanceof BABYLON.Vector4 ? value : BABYLON.Vector4.FromArray(value as readonly [number, number, number, number]);\n}`,
  ensureMatrix: `function ensureMatrix(value: BABYLON.Matrix | Float32Array | readonly number[]): BABYLON.Matrix {\n  if (value instanceof BABYLON.Matrix) {\n    return value;\n  }\n  const matrix = BABYLON.Matrix.Identity();\n  matrix.copyFromArray(Array.from(value));\n  return matrix;\n}`,
};

function toPascalCase(value: string): string {
  return value
    .replace(/[-_]/g, ' ')
    .split(' ')
    .filter(Boolean)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
}

function escapeTemplateLiteral(value: string): string {
  return `\`${value
    .replace(/\\/g, '\\\\')
    .replace(/`/g, '\\`')
    .replace(/\$\{/g, '\\${')}\``;
}

async function writeFileIfChanged(filePath: string, content: string): Promise<boolean> {
  let existing: string | null = null;
  try {
    existing = await fs.readFile(filePath, 'utf8');
  } catch (error: any) {
    if (error?.code !== 'ENOENT') {
      throw error;
    }
  }
  if (existing === content) {
    return false;
  }
  await fs.mkdir(path.dirname(filePath), { recursive: true });
  await fs.writeFile(filePath, content, 'utf8');
  return true;
}

function validateType(argument: ArgumentInfo, expected: string, label: string): void {
  const typeName = argument.type.getTypeName();
  if (typeName !== expected) {
    throw new Error(`${label} must be ${expected}. Received ${argument.name}: ${typeName}`);
  }
}

function collectUniformFields(struct: StructInfo, uniformArgName: string): UniformField[] {
  return struct.members.map((member) => {
    if (member.type.isStruct || member.type.isArray) {
      throw new Error(`Uniform field ${member.name} uses unsupported type ${member.type.getTypeName()}. Nested structs/arrays are not supported.`);
    }
    const typeName = member.type.getTypeName();
    if (!UNIFORM_TYPE_MAP[typeName]) {
      throw new Error(`Uniform field ${member.name} uses unsupported type ${typeName}.`);
    }
    return {
      name: member.name,
      bindingName: `${uniformArgName}_${member.name}`,
      wgslType: typeName,
    };
  });
}

function parseTextureParams(args: ArgumentInfo[], startIndex: number, functionName: string): TextureParam[] {
  const params: TextureParam[] = [];
  const seenTextures = new Set<string>();

  for (let index = startIndex; index < args.length; index += 2) {
    const textureArg = args[index];
    const samplerArg = args[index + 1];

    if (!textureArg || !samplerArg) {
      throw new Error(`Texture parameters in ${functionName} must be provided in texture/sampler pairs.`);
    }

    const textureType = textureArg.type.getTypeName();
    if (textureType !== 'texture_2d<f32>') {
      throw new Error(`Texture argument must be texture_2d<f32>. Received ${textureArg.name}: ${textureType}`);
    }

    const samplerType = samplerArg.type.getTypeName();
    if (samplerType !== 'sampler') {
      throw new Error(`Expected sampler after texture ${textureArg.name}, but got ${samplerArg.name}: ${samplerType}. Texture parameters must be provided in texture/sampler pairs.`);
    }

    if (seenTextures.has(textureArg.name)) {
      throw new Error(`Duplicate texture parameter ${textureArg.name} detected.`);
    }
    seenTextures.add(textureArg.name);

    params.push({
      textureName: textureArg.name,
      samplerName: samplerArg.name,
    });
  }

  return params;
}

function generateUniformStructConstruction(struct: StructInfo, fields: UniformField[]): string {
  if (fields.length === 0) {
    return `fn load_${struct.name}() -> ${struct.name} {\n  return ${struct.name}();\n}`;
  }
  const ctorArguments = fields.map((field) => `  uniforms.${field.bindingName}`).join(',\n');
  return `fn load_${struct.name}() -> ${struct.name} {\n  return ${struct.name}(\n${ctorArguments}\n  );\n}`;
}

function buildStrokeVertexSource(options: {
  shaderCode: string;
  uniformStruct: StructInfo;
  uniformFields: UniformField[];
  uniformLoaderFn: string;
}): string {
  const { shaderCode, uniformStruct, uniformFields, uniformLoaderFn } = options;
  const lines: string[] = [];
  lines.push(HEADER_COMMENT);
  lines.push('attribute position: vec3<f32>;');
  lines.push('attribute uv: vec2<f32>;');
  lines.push('attribute strokeNormal: vec2<f32>;');
  lines.push('attribute strokeSide: f32;');
  lines.push('attribute strokeArcLength: f32;');
  lines.push('attribute strokeNormalizedArc: f32;');
  lines.push('attribute strokeMiterFactor: f32;');
  lines.push('varying vUV: vec2<f32>;');
  lines.push('varying vArcLength: f32;');
  lines.push('varying vNormalizedArc: f32;');
  uniformFields.forEach((field) => {
    lines.push(`uniform ${field.bindingName}: ${field.wgslType};`);
  });
  lines.push('uniform power2d_canvasWidth: f32;');
  lines.push('uniform power2d_canvasHeight: f32;');
  lines.push('uniform power2d_strokeThickness: f32;');
  lines.push('');
  lines.push(shaderCode.trimEnd());
  lines.push('');
  lines.push(uniformLoaderFn);
  lines.push('');
  lines.push('fn power2d_pixelToNDC(pixel: vec2f) -> vec4f {');
  lines.push('  let ndcX = (pixel.x / uniforms.power2d_canvasWidth) * 2.0 - 1.0;');
  lines.push('  let ndcY = -((pixel.y / uniforms.power2d_canvasHeight) * 2.0 - 1.0);');
  lines.push('  return vec4f(ndcX, ndcY, 0.0, 1.0);');
  lines.push('}');
  lines.push('');
  lines.push('#define CUSTOM_VERTEX_DEFINITIONS');
  lines.push('@vertex');
  lines.push('fn main(input : VertexInputs) -> FragmentInputs {');
  lines.push('#define CUSTOM_VERTEX_MAIN_BEGIN');
  lines.push(`  let uniformsValue = load_${uniformStruct.name}();`);
  lines.push('  let centerPos = vec2f(vertexInputs.position.x, vertexInputs.position.y);');
  lines.push('  let normal = vertexInputs.strokeNormal;');
  lines.push('  let side = vertexInputs.strokeSide;');
  lines.push('  let arcLength = vertexInputs.strokeArcLength;');
  lines.push('  let normalizedArc = vertexInputs.strokeNormalizedArc;');
  lines.push('  let miterFactor = vertexInputs.strokeMiterFactor;');
  lines.push('  let thickness = uniforms.power2d_strokeThickness;');
  lines.push('  let uv = vertexInputs.uv;');
  lines.push('  let adjustedPixelPos = strokeVertShader(centerPos, normal, side, arcLength, normalizedArc, miterFactor, thickness, uniformsValue);');
  lines.push('  vertexOutputs.position = power2d_pixelToNDC(adjustedPixelPos);');
  lines.push('  vertexOutputs.vUV = uv;');
  lines.push('  vertexOutputs.vArcLength = arcLength;');
  lines.push('  vertexOutputs.vNormalizedArc = normalizedArc;');
  lines.push('#define CUSTOM_VERTEX_MAIN_END');
  lines.push('}');
  lines.push('');
  return `${lines.join('\n')}\n`;
}

function buildStrokeFragmentSource(options: {
  shaderCode: string;
  uniformStruct: StructInfo;
  uniformFields: UniformField[];
  uniformLoaderFn: string;
  textureParams: TextureParam[];
}): string {
  const { shaderCode, uniformStruct, uniformFields, uniformLoaderFn, textureParams } = options;
  const lines: string[] = [];
  lines.push(HEADER_COMMENT);
  lines.push('varying vUV: vec2<f32>;');
  lines.push('varying vArcLength: f32;');
  lines.push('varying vNormalizedArc: f32;');
  uniformFields.forEach((field) => {
    lines.push(`uniform ${field.bindingName}: ${field.wgslType};`);
  });
  lines.push('uniform power2d_canvasWidth: f32;');
  lines.push('uniform power2d_canvasHeight: f32;');
  lines.push('uniform power2d_strokeThickness: f32;');
  textureParams.forEach((param) => {
    lines.push(`var ${param.textureName}: texture_2d<f32>;`);
    lines.push(`var ${param.samplerName}: sampler;`);
  });
  lines.push('');
  lines.push(shaderCode.trimEnd());
  lines.push('');
  lines.push(uniformLoaderFn);
  lines.push('');
  lines.push('#define CUSTOM_FRAGMENT_DEFINITIONS');
  lines.push('@fragment');
  lines.push('fn main(input: FragmentInputs) -> FragmentOutputs {');
  lines.push('#define CUSTOM_FRAGMENT_MAIN_BEGIN');
  lines.push(`  let uniformsValue = load_${uniformStruct.name}();`);
  lines.push('  let uv = fragmentInputs.vUV;');
  lines.push('  let arcLength = fragmentInputs.vArcLength;');
  lines.push('  let normalizedArc = fragmentInputs.vNormalizedArc;');
  const args: string[] = ['uv', 'arcLength', 'normalizedArc', 'uniformsValue'];
  textureParams.forEach((param) => {
    args.push(param.textureName);
    args.push(param.samplerName);
  });
  lines.push(`  let color = strokeFragShader(${args.join(', ')});`);
  lines.push('  fragmentOutputs.color = color;');
  lines.push('#define CUSTOM_FRAGMENT_MAIN_END');
  lines.push('}');
  lines.push('');
  return `${lines.join('\n')}\n`;
}

export async function generateStrokeMaterialTypes(
  sourcePath: string,
  options: GenerateStrokeMaterialTypesOptions,
): Promise<GenerateStrokeMaterialTypesResult> {
  if (!sourcePath.endsWith(RAW_SUFFIX)) {
    throw new Error(`Expected a ${RAW_SUFFIX} file. Received ${sourcePath}`);
  }

  const { projectRoot, logger } = options;
  const absoluteSource = path.resolve(sourcePath);
  const shaderBaseName = path.basename(sourcePath, RAW_SUFFIX);
  const outputPath = `${absoluteSource}${OUTPUT_SUFFIX}`;
  const shaderPrefix = toPascalCase(shaderBaseName);

  const shaderCode = await fs.readFile(absoluteSource, 'utf8');
  const reflect = new WgslReflect(shaderCode);

  const vertFn = reflect.functions.find((fn) => fn.name === 'strokeVertShader' && !fn.stage);
  const fragFn = reflect.functions.find((fn) => fn.name === 'strokeFragShader' && !fn.stage);
  if (!vertFn) {
    throw new Error('Missing strokeVertShader function.');
  }
  if (!fragFn) {
    throw new Error('Missing strokeFragShader function.');
  }

  if (vertFn.arguments.length !== 8) {
    throw new Error('strokeVertShader must declare 8 arguments (centerPos, normal, side, arcLength, normalizedArc, miterFactor, thickness, uniforms).');
  }

  validateType(vertFn.arguments[0], 'vec2f', 'strokeVertShader centerPos');
  validateType(vertFn.arguments[1], 'vec2f', 'strokeVertShader normal');
  validateType(vertFn.arguments[2], 'f32', 'strokeVertShader side');
  validateType(vertFn.arguments[3], 'f32', 'strokeVertShader arcLength');
  validateType(vertFn.arguments[4], 'f32', 'strokeVertShader normalizedArc');
  validateType(vertFn.arguments[5], 'f32', 'strokeVertShader miterFactor');
  validateType(vertFn.arguments[6], 'f32', 'strokeVertShader thickness');

  const uniformArg = vertFn.arguments[7];
  const uniformStruct = reflect.structs.find((entry) => entry.name === uniformArg.type.getTypeName());
  if (!uniformStruct) {
    throw new Error(`Uniform struct ${uniformArg.type.getTypeName()} not found.`);
  }

  if (fragFn.arguments.length < 4) {
    throw new Error('strokeFragShader must declare at least 4 arguments (uv, arcLength, normalizedArc, uniforms).');
  }

  validateType(fragFn.arguments[0], 'vec2f', 'strokeFragShader uv');
  validateType(fragFn.arguments[1], 'f32', 'strokeFragShader arcLength');
  validateType(fragFn.arguments[2], 'f32', 'strokeFragShader normalizedArc');
  const fragUniformArg = fragFn.arguments[3];
  if (fragUniformArg.type.getTypeName() !== uniformStruct.name) {
    throw new Error(`strokeFragShader uniforms must use struct ${uniformStruct.name}.`);
  }

  const uniformFields = collectUniformFields(uniformStruct, uniformArg.name);
  const uniformLoaderFn = generateUniformStructConstruction(uniformStruct, uniformFields);
  const textureParams = parseTextureParams(fragFn.arguments, 4, 'strokeFragShader');

  const vertexSource = buildStrokeVertexSource({
    shaderCode,
    uniformStruct,
    uniformFields,
    uniformLoaderFn,
  });

  const fragmentSource = buildStrokeFragmentSource({
    shaderCode,
    uniformStruct,
    uniformFields,
    uniformLoaderFn,
    textureParams,
  });

  const uniformInterfaceName = uniformStruct.name;
  const helperNames = new Set<string>();
  const uniformInterfaceLines: string[] = [];
  const uniformSetterLines: string[] = [];

  uniformInterfaceLines.push(`export interface ${uniformInterfaceName} {`);
  for (const field of uniformFields) {
    const meta = UNIFORM_TYPE_MAP[field.wgslType];
    if (!meta) {
      throw new Error(`Unsupported uniform field type ${field.wgslType}.`);
    }
    uniformInterfaceLines.push(`  ${field.name}: ${meta.tsType};`);
    if (meta.helper) {
      helperNames.add(meta.helper);
    }
  }
  uniformInterfaceLines.push('}');

  uniformSetterLines.push(`export function set${uniformInterfaceName}(material: BABYLON.ShaderMaterial, uniforms: Partial<${uniformInterfaceName}>): void {`);
  uniformSetterLines.push('  if (!uniforms) {');
  uniformSetterLines.push('    return;');
  uniformSetterLines.push('  }');
  for (const field of uniformFields) {
    const meta = UNIFORM_TYPE_MAP[field.wgslType];
    uniformSetterLines.push(`  if (uniforms.${field.name} !== undefined) {`);
    uniformSetterLines.push(`    material.${meta.setter}('${field.bindingName}', ${meta.expression(`uniforms.${field.name}`)});`);
    uniformSetterLines.push('  }');
  }
  uniformSetterLines.push('}');

  const helperBlocks = Array.from(helperNames).map((name) => HELPER_SNIPPETS[name]);

  const uniformDefaultsLines: string[] = [];
  uniformDefaultsLines.push(`export const ${shaderPrefix}UniformDefaults: ${uniformInterfaceName} = {`);
  for (const field of uniformFields) {
    const meta = UNIFORM_TYPE_MAP[field.wgslType];
    uniformDefaultsLines.push(`  ${field.name}: ${meta.defaultValue},`);
  }
  uniformDefaultsLines.push('};');

  const uniformMetaLines: string[] = [];
  uniformMetaLines.push(`export const ${shaderPrefix}UniformMeta = [`);
  for (const field of uniformFields) {
    uniformMetaLines.push('  {');
    uniformMetaLines.push(`    name: '${field.name}',`);
    uniformMetaLines.push(`    kind: '${field.wgslType}',`);
    uniformMetaLines.push(`    bindingName: '${field.bindingName}',`);
    uniformMetaLines.push('  },');
  }
  uniformMetaLines.push('] as const;');

  const textureNames = textureParams.map((param) => param.textureName);
  const textureNameUnion = textureNames.length ? textureNames.map((name) => `'${name}'`).join(' | ') : 'never';
  const textureNamesLiteral = textureNames.length ? `[${textureNames.map((name) => `'${name}'`).join(', ')}] as const` : '[] as const';

  const samplerNames = textureParams.map((param) => param.samplerName);
  const samplerLookupEntries = textureParams
    .map((param) => `'${param.textureName}': '${param.samplerName}'`)
    .join(', ');

  const materialInterfaceName = `${shaderPrefix}StrokeMaterialDef`;
  const materialInstanceName = `${shaderPrefix}StrokeMaterialInstance`;
  const materialConstName = `${shaderPrefix}StrokeMaterial`;

  const materialInterfaceLines: string[] = [];
  materialInterfaceLines.push(`export interface ${materialInterfaceName} {`);
  materialInterfaceLines.push(`  readonly uniformType: ${uniformInterfaceName};`);
  materialInterfaceLines.push(`  readonly textureNames: readonly ${textureNameUnion}[];`);
  materialInterfaceLines.push('  readonly vertexSource: string;');
  materialInterfaceLines.push('  readonly fragmentSource: string;');
  materialInterfaceLines.push(`  readonly uniformMeta: typeof ${shaderPrefix}UniformMeta;`);
  materialInterfaceLines.push(`  readonly uniformDefaults: ${uniformInterfaceName};`);
  materialInterfaceLines.push(`  readonly createMaterial: (scene: BABYLON.Scene, name?: string) => ${materialInstanceName};`);
  materialInterfaceLines.push('}');

  const materialInstanceLines: string[] = [];
  materialInstanceLines.push(`export interface ${materialInstanceName} {`);
  materialInstanceLines.push('  material: BABYLON.ShaderMaterial;');
  materialInstanceLines.push(`  setUniforms(uniforms: Partial<${uniformInterfaceName}>): void;`);
  materialInstanceLines.push(`  setTexture(name: ${shaderPrefix}TextureName, texture: BABYLON.BaseTexture): void;`);
  if (textureParams.length > 0) {
    materialInstanceLines.push(`  setTextureSampler(name: ${shaderPrefix}TextureName, sampler: BABYLON.TextureSampler): void;`);
  }
  materialInstanceLines.push('  setCanvasSize(width: number, height: number): void;');
  materialInstanceLines.push('  dispose(): void;');
  materialInstanceLines.push('}');

  const attributesList = [
    'position',
    'uv',
    'strokeNormal',
    'strokeSide',
    'strokeArcLength',
    'strokeNormalizedArc',
    'strokeMiterFactor',
  ];

  const uniformsList = uniformFields.map((field) => `'${field.bindingName}'`);
  uniformsList.push("'power2d_canvasWidth'", "'power2d_canvasHeight'", "'power2d_strokeThickness'");

  const defaultSamplerLines: string[] = [];
  if (textureParams.length > 0) {
    defaultSamplerLines.push('  const defaultSampler = new BABYLON.TextureSampler();');
    defaultSamplerLines.push('  defaultSampler.setParameters(');
    defaultSamplerLines.push('    BABYLON.Texture.CLAMP_ADDRESSMODE,');
    defaultSamplerLines.push('    BABYLON.Texture.CLAMP_ADDRESSMODE,');
    defaultSamplerLines.push('    BABYLON.Texture.CLAMP_ADDRESSMODE,');
    defaultSamplerLines.push('    undefined,');
    defaultSamplerLines.push('    BABYLON.Texture.BILINEAR_SAMPLINGMODE,');
    defaultSamplerLines.push('  );');
    for (const samplerName of samplerNames) {
      defaultSamplerLines.push(`  material.setTextureSampler('${samplerName}', defaultSampler);`);
    }
  }

  const createMaterialLines: string[] = [];
  createMaterialLines.push(`export function create${shaderPrefix}StrokeMaterial(scene: BABYLON.Scene, name: string = '${shaderPrefix}StrokeMaterial'): ${materialInstanceName} {`);
  createMaterialLines.push('  const vertexShaderName = `${name}VertexShader`;');
  createMaterialLines.push('  const fragmentShaderName = `${name}FragmentShader`;');
  createMaterialLines.push('');
  createMaterialLines.push('  BABYLON.ShaderStore.ShadersStoreWGSL[vertexShaderName] = ' + `${shaderPrefix}StrokeVertexSource;`);
  createMaterialLines.push('  BABYLON.ShaderStore.ShadersStoreWGSL[fragmentShaderName] = ' + `${shaderPrefix}StrokeFragmentSource;`);
  createMaterialLines.push('');
  createMaterialLines.push('  const material = new BABYLON.ShaderMaterial(name, scene, {');
  createMaterialLines.push('    vertex: name,');
  createMaterialLines.push('    fragment: name,');
  createMaterialLines.push('  }, {');
  createMaterialLines.push(`    attributes: [${attributesList.map((attr) => `'${attr}'`).join(', ')}],`);
  createMaterialLines.push(`    uniforms: [${uniformsList.join(', ')}],`);
  createMaterialLines.push(`    samplers: [${textureNames.map((name) => `'${name}'`).join(', ')}],`);
  createMaterialLines.push(`    samplerObjects: [${samplerNames.map((name) => `'${name}'`).join(', ')}],`);
  createMaterialLines.push('    shaderLanguage: BABYLON.ShaderLanguage.WGSL,');
  createMaterialLines.push('  });');
  createMaterialLines.push('');
  if (defaultSamplerLines.length > 0) {
    createMaterialLines.push(...defaultSamplerLines);
    createMaterialLines.push('');
  }
  if (uniformFields.length > 0) {
    createMaterialLines.push(`  set${uniformInterfaceName}(material, ${shaderPrefix}UniformDefaults);`);
  }
  createMaterialLines.push('  material.setFloat(\'power2d_strokeThickness\', 1);');
  createMaterialLines.push('  material.disableDepthWrite = true;');
  createMaterialLines.push('  material.depthFunction = BABYLON.Constants.ALWAYS;');
  createMaterialLines.push('  material.backFaceCulling = false;');
  createMaterialLines.push('  material.alphaMode = BABYLON.Engine.ALPHA_COMBINE;');
  createMaterialLines.push('');
  if (textureParams.length > 0) {
    createMaterialLines.push(`  const samplerLookup = { ${samplerLookupEntries} } as const;`);
    createMaterialLines.push('');
  }
  createMaterialLines.push(`  const handles: ${materialInstanceName} = {`);
  createMaterialLines.push('    material,');
  createMaterialLines.push(`    setUniforms: (uniforms) => set${uniformInterfaceName}(material, uniforms),`);
  createMaterialLines.push('    setTexture: (name, texture) => material.setTexture(name, texture),');
  if (textureParams.length > 0) {
    createMaterialLines.push('    setTextureSampler: (name, sampler) => {');
    createMaterialLines.push('      const samplerName = (samplerLookup as Record<string, string | undefined>)[name];');
    createMaterialLines.push('      if (samplerName) {');
    createMaterialLines.push('        material.setTextureSampler(samplerName, sampler);');
    createMaterialLines.push('      }');
    createMaterialLines.push('    },');
  }
  createMaterialLines.push('    setCanvasSize: (width, height) => {');
  createMaterialLines.push('      material.setFloat(\'power2d_canvasWidth\', width);');
  createMaterialLines.push('      material.setFloat(\'power2d_canvasHeight\', height);');
  createMaterialLines.push('    },');
  createMaterialLines.push('    dispose: () => {');
  createMaterialLines.push('      material.dispose(true, false);');
  createMaterialLines.push('      delete BABYLON.ShaderStore.ShadersStoreWGSL[vertexShaderName];');
  createMaterialLines.push('      delete BABYLON.ShaderStore.ShadersStoreWGSL[fragmentShaderName];');
  createMaterialLines.push('    },');
  createMaterialLines.push('  };');
  createMaterialLines.push('');
  createMaterialLines.push('  return handles;');
  createMaterialLines.push('}');

  const materialDefLines: string[] = [];
  materialDefLines.push(`export const ${materialConstName}: ${materialInterfaceName} = {`);
  materialDefLines.push(`  uniformType: undefined as unknown as ${uniformInterfaceName},`);
  materialDefLines.push(`  textureNames: ${shaderPrefix}TextureNames,`);
  materialDefLines.push(`  vertexSource: ${shaderPrefix}StrokeVertexSource,`);
  materialDefLines.push(`  fragmentSource: ${shaderPrefix}StrokeFragmentSource,`);
  materialDefLines.push(`  uniformMeta: ${shaderPrefix}UniformMeta,`);
  materialDefLines.push(`  uniformDefaults: ${shaderPrefix}UniformDefaults,`);
  materialDefLines.push(`  createMaterial: create${shaderPrefix}StrokeMaterial,`);
  materialDefLines.push('};');

  const tsLines: string[] = [];
  tsLines.push(HEADER_COMMENT);
  tsLines.push(`import * as BABYLON from 'babylonjs';`);
  tsLines.push('');
  tsLines.push(`export const ${shaderPrefix}StrokeVertexSource = ${escapeTemplateLiteral(vertexSource)};`);
  tsLines.push(`export const ${shaderPrefix}StrokeFragmentSource = ${escapeTemplateLiteral(fragmentSource)};`);
  tsLines.push('');
  if (helperBlocks.length > 0) {
    tsLines.push(...helperBlocks);
    tsLines.push('');
  }
  tsLines.push(...uniformInterfaceLines);
  tsLines.push('');
  tsLines.push(...uniformDefaultsLines);
  tsLines.push('');
  tsLines.push(...uniformMetaLines);
  tsLines.push('');
  tsLines.push(...uniformSetterLines);
  tsLines.push('');
  tsLines.push(`export type ${shaderPrefix}TextureName = ${textureNameUnion};`);
  tsLines.push(`export const ${shaderPrefix}TextureNames = ${textureNamesLiteral};`);
  tsLines.push('');
  tsLines.push(...materialInterfaceLines);
  tsLines.push('');
  tsLines.push(...materialInstanceLines);
  tsLines.push('');
  tsLines.push(...createMaterialLines);
  tsLines.push('');
  tsLines.push(...materialDefLines);
  tsLines.push('');
  tsLines.push(`export default ${materialConstName};`);

  const typesSource = `${tsLines.join('\n')}\n`;

  const updated = await writeFileIfChanged(outputPath, typesSource);

  if (logger) {
    const relative = path.relative(projectRoot, outputPath);
    if (updated) {
      logger(`Updated ${relative}`);
    }
  }

  return {
    sourcePath: absoluteSource,
    outputPath,
    updated,
  };
}
