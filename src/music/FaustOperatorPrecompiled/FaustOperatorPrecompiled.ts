
import { FaustMonoDspGenerator, FaustMonoAudioWorkletNode, type FaustDspMeta } from "@grame/faustwasm";
import { argv, compiler, f2m, faustAudioContext, param, type MPEVoiceGraph, m2f } from "../mpeSynth";
import { dspMeta } from "./dsp-meta";
const generator = new FaustMonoDspGenerator();

/**
generated files are built by downloading from FaustIDE platform:web architecture:wasmjs.
operator.wasm is the dsp-module.wasm file from the download just renamed to operator.wasm.
operator.wasm is put in the public folder (as required by Vite) so it can be fetched via fetch().
dsp-meta.ts is the dsp-meta.json file from the download renamed and incldued as source. 
 */

let faustFactory: { module: WebAssembly.Module, json: string, soundfiles: {} } | null = null

const compilePromise = (async () => {
  // Load DSP metadata from JSON
  // const dspMeta: FaustDspMeta = await (await fetch("./dsp-meta.json")).json();

  // Compile the DSP module from WebAssembly binary data
  const wasm = await fetch("./operator.wasm")
  console.log("got wasm")
  const dspModule = await WebAssembly.compileStreaming(wasm);
  console.log("dspModule", dspModule)
  faustFactory = { module: dspModule, json: JSON.stringify(dspMeta), soundfiles: {} }
})()

export class FaustOperatorVoicePrecompiled implements MPEVoiceGraph {
  id: number

  //defensive programming - user should call MPEPolySynth.synthReady() before starting to play notes
  node: Partial<FaustMonoAudioWorkletNode> =  {setParamValue: (param: string, value: number) => {}, getParamValue: (param: string) => 0}
  
  _pressure: number
  _slide: number
  constructorPromise: Promise<void>
  constructor(id: number) {
    this.id = id
    const nodeMakeNode = async () =>{
      console.log("starting nodeMakeNode", id)
      await compilePromise
      console.log("post compile", id)
      this.node = await generator.createNode(faustAudioContext, `operator_voice_${id}`, faustFactory);
      this.node.connect(faustAudioContext.destination);
      this.node.start();
      // console.log("node params", this.node.getParams())
      console.log("node created", id)
    } 
    this.constructorPromise = nodeMakeNode() //should ideally be pre-allocated in outer MPEPolySynth constructor
  }

  ready(): Promise<void> {
    return this.constructorPromise
  }

  getAllParams() {
    const params = this.node.getParams()
    const allParams = {}
    params.forEach((param) => {
      allParams[param] = this.node.getParamValue(param)
    })
    return allParams
  }


  //todo - if you want params to vary based on velocity, need to modify noteOn func generated by script
  noteOn(note: number, velocity: number, pressure: number, slide: number): void {
    this.pitch = note
    this._pressure = pressure
    this._slide = slide
    this.node.setParamValue("/operator/VelocityAmp", velocity/127)
    this.node.setParamValue("/operator/Gate", 1)
    // console.log("operator noteOn", note, velocity, pressure, slide)
  }

  setBatchParams(params: { [key: string]: number }): void {
    for (const [key, value] of Object.entries(params)) {
      this.node.setParamValue(key, value);
    }
  }

  get polyGain(): number {
    return this.node.getParamValue("/operator/PolyGain")
  }

  set polyGain(value: number) {
    this.node.setParamValue("/operator/PolyGain", value)
  }

  get release(): number {
    return this.node.getParamValue("/operator/Release")
  }

  set release(value: number) {
    this.node.setParamValue("/operator/Release", value)
  }

  noteOff(): void {
    this.node.setParamValue("/operator/Gate", 0)

    // // Call the callback after the release time
    // setTimeout(() => {
    //   if (this.voiceFinishedCB) {
    //     this.voiceFinishedCB()
    //   }
    // }, Number(this.ampEnv.release) * 1000) 
  }

  //do you need voiceFinishedCB? might be too niche for template script
  //todo need to have "release" value available at API level for proper voice lifecycle management (eg, don't want to accidentally reuse a voice that is still in release)

  forceFinish(): void {
    //todo - need to implement forceFinish properly for voice stealing - might need a per voice global gain object to manage voice stealing?


    // if (this.voiceFinishedCB) {
    //   this.voiceFinishedCB()
    // }
  }

  dispose(): void {
    this.node.disconnect()
    this.node.destroy()
  }

  get pitch(): number {
    return f2m(this.node.getParamValue('/operator/Frequency'))
  }

  set pitch(value: number) {
    this.node.setParamValue("/operator/Frequency", m2f(value))
  }

  get slide(): number {
    return this._slide
  }

  set slide(value: number) {
    this._slide = value
  }

  get pressure(): number {
    return this._pressure
  }

  set pressure(value: number) {
    this._pressure = value
  }
}

