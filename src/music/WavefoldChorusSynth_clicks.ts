
import { FaustMonoDspGenerator, FaustMonoAudioWorkletNode } from "@grame/faustwasm";
import { argv, compiler, f2m, faustAudioContext, param, type MPEVoiceGraph, m2f } from "./mpeSynth";

const generator = new FaustMonoDspGenerator();
const name = "oscillator"
const code = `

import("stdfaust.lib");

//basic parameters all voices need to have
gate = button("Gate");
freq = hslider("Frequency", 440, 20, 2000, 1);
vAmp = hslider("VelocityAmp", 0.7, 0, 1, 0.01);
release = hslider("Release", 0.3, 0, 1, 0.01);
polyGain = hslider("PolyGain", 0.7, 0, 1, 0.01);



// Parameters
depth = hslider("c_Depth [ms]", 10, 1, 50, 0.1) * ma.SR / 1000.0; // Depth in samples
rate = hslider("c_Rate [Hz]", 0.25, 0.01, 5, 0.01);              // LFO rate
mix = hslider("c_Mix [%]", 50, 0, 100, 1) * 0.01;               // Dry/Wet mix

// LFO for modulation
lfo = os.osc(rate) * depth; // Modulating signal for delay

// Smooth delay with interpolation
chorusEffect(input) = mix * (input : de.sdelay(2 * depth, 128, depth + lfo)) 
                        + (1 - mix) * input;

detune = hslider("Detune", 1, 0, 50, 0.01);
modRelease = hslider("ModRelease", 0.3, 0, 1, 0.01);

//custom parameters for each voice
filterFreq = hslider("Filter", 3000, 20, 10000, 0.1);

echoFdbk = hslider("EchoFdbk", 0.3, 0, 1, 0.01);
echoTime = hslider("EchoTime", 0.3, 0.01, 10, 0.01);

env2 = gate : en.adsr(0.01, 0.1, 0.2, modRelease);

sawFilt = os.sawtooth(freq*1.01) : fi.lowpass(4, freq*8);
oscSig = ((os.osc(freq))  : ef.wavefold(env2 * 0.5)) + sawFilt*0.2;

env = gate : en.adsr(0.01, 0.1, 0.8, release);
filter = fi.lowpass(2, filterFreq);

sig = oscSig  * vAmp * polyGain * env : filter : chorusEffect : ef.echo(10, echoTime, echoFdbk);
process = sig, sig;

`;

//todo - need different name for each voice to avoid AudioWorkletNode name conflict?
//gives warning but still works
let isCompiled = false
let compilerPromise: Promise<FaustMonoDspGenerator>
const compile = async () => {
  if(!isCompiled) {
    isCompiled = true
    console.log("compiling")
    compilerPromise = generator.compile(compiler, name, code, argv.join(" "));
  } 
  await compilerPromise
}

export class WavefoldChorusVoice_clicks implements MPEVoiceGraph {
  id: number

  //defensive programming - user should call MPEPolySynth.synthReady() before starting to play notes
  node: Partial<FaustMonoAudioWorkletNode> =  {setParamValue: (param: string, value: number) => {}, getParamValue: (param: string) => 0}
  
  _pressure: number
  _slide: number
  constructorPromise: Promise<void>
  constructor(id: number) {
    this.id = id
    const nodeMakeNode = async () =>{
      await compile()
      this.node = await generator.createNode(faustAudioContext, name+Math.random().toString());
      this.node.connect(faustAudioContext.destination);
      this.node.start();
    } 
    this.constructorPromise = nodeMakeNode() //should ideally be pre-allocated in outer MPEPolySynth constructor
  }

  ready(): Promise<void> {
    return this.constructorPromise
  }

  getAllParams() {
    const params = this.node.getParams()
    const allParams = {}
    params.forEach((param) => {
      allParams[param] = this.node.getParamValue(param)
    })
    return allParams
  }

  //todo - if you want params to vary based on velocity, need to modify noteOn func generated by script
  noteOn(note: number, velocity: number, pressure: number, slide: number): void {
    this.pitch = note
    this._pressure = pressure
    this._slide = slide
    this.node.setParamValue("oscillator/VelocityAmp", velocity)
    this.node.setParamValue("/oscillator/Gate", 1)
  }

  get polyGain(): number {
    return this.node.getParamValue("/oscillator/PolyGain")
  }

  @param(0, 1, 0.7)
  set polyGain(value: number) {
    this.node.setParamValue("/oscillator/PolyGain", value)
  }

  get release(): number {
    return this.node.getParamValue("/oscillator/Release")
  }

  @param(0, 10, 0.05)
  set release(value: number) {
    this.node.setParamValue("/oscillator/Release", value)
  }

  get pan(): number {
    return this.node.getParamValue("/oscillator/Pan")
  }

  @param(0, 1, 0.5)
  set pan(value: number) {
    this.node.setParamValue("/oscillator/Pan", value)
  }

  noteOff(): void {
    this.node.setParamValue("/oscillator/Gate", 0)

    // // Call the callback after the release time
    // setTimeout(() => {
    //   if (this.voiceFinishedCB) {
    //     this.voiceFinishedCB()
    //   }
    // }, Number(this.ampEnv.release) * 1000) 
  }

  //do you need voiceFinishedCB? might be too niche for template script
  //todo need to have "release" value available at API level for proper voice lifecycle management (eg, don't want to accidentally reuse a voice that is still in release)

  forceFinish(): void {
    //todo - need to implement forceFinish properly for voice stealing - might need a per voice global gain object to manage voice stealing?


    // if (this.voiceFinishedCB) {
    //   this.voiceFinishedCB()
    // }
  }

  dispose(): void {
    this.node.disconnect()
    this.node.destroy()
  }

  get pitch(): number {
    return f2m(this.node.getParamValue('/oscillator/Frequency'))
  }

  set pitch(value: number) {
    this.node.setParamValue("/oscillator/Frequency", m2f(value))
  }

  get slide(): number {
    return this._slide
  }

  set slide(value: number) {
    this._slide = value
  }

  get pressure(): number {
    return this._pressure
  }

  set pressure(value: number) {
    this._pressure = value
  }

  get Filter(): number {
    return this.node.getParamValue("/oscillator/Filter");
  }

  @param(20, 10000, 3000)
  set Filter(value: number) {
    this.node.setParamValue("/oscillator/Filter", value);
  }

  get detune(): number {
    return this.node.getParamValue("/oscillator/Detune")
  }

  @param(0, 50, 1)
  set detune(value: number) {
    this.node.setParamValue("/oscillator/Detune", value)
  }

  get modRelease(): number {
    return this.node.getParamValue("/oscillator/ModRelease")
  }

  @param(0, 1, 0.3)
  set modRelease(value: number) {
    this.node.setParamValue("/oscillator/ModRelease", value)
  }

  get echoFdbk(): number {
    return this.node.getParamValue("/oscillator/EchoFdbk");
  }

  @param(0, 1, 0.3)
  set echoFdbk(value: number) {
    this.node.setParamValue("/oscillator/EchoFdbk", value);
  }

  get echoTime(): number {
    return this.node.getParamValue("/oscillator/EchoTime");
  }

  @param(0.01, 10, 0.3)
  set echoTime(value: number) {
    this.node.setParamValue("/oscillator/EchoTime", value);
  }

}

