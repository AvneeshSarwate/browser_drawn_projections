
import { FaustMonoDspGenerator, FaustMonoAudioWorkletNode } from "@grame/faustwasm";
import { argv, compiler, f2m, faustAudioContext, param, type MPEVoiceGraph, m2f } from "../mpeSynth";
import { dspMeta } from "./dsp-meta";
const generator = new FaustMonoDspGenerator();

const name = "oscillator"

let faustFactory: { module: WebAssembly.Module, json: string, soundfiles: {} } | null = null

const compilePromise = (async () => {
  // Load DSP metadata from JSON
  // const dspMeta: FaustDspMeta = await (await fetch("./dsp-meta.json")).json();

  // Compile the DSP module from WebAssembly binary data
  const wasm = await fetch("./WavefoldChorusSynth_clicks.wasm")
  console.log("got wasm")
  const dspModule = await WebAssembly.compileStreaming(wasm);
  console.log("dspModule", dspModule)
  faustFactory = { module: dspModule, json: JSON.stringify(dspMeta), soundfiles: {} }
})()


export class WavefoldChorusVoice_clicks implements MPEVoiceGraph {
  id: number

  //defensive programming - user should call MPEPolySynth.synthReady() before starting to play notes
  node: Partial<FaustMonoAudioWorkletNode> =  {setParamValue: (param: string, value: number) => {}, getParamValue: (param: string) => 0}
  
  _pressure: number
  _slide: number
  constructorPromise: Promise<void>
  constructor(id: number) {
    this.id = id
    const nodeMakeNode = async () =>{
      await compilePromise
      this.node = await generator.createNode(faustAudioContext, name+Math.random().toString(), faustFactory);
      this.node.connect(faustAudioContext.destination);
      this.node.start();
    } 
    this.constructorPromise = nodeMakeNode() //should ideally be pre-allocated in outer MPEPolySynth constructor
  }

  ready(): Promise<void> {
    return this.constructorPromise
  }

  getAllParams() {
    const params = this.node.getParams()
    const allParams = {}
    params.forEach((param) => {
      allParams[param] = this.node.getParamValue(param)
    })
    return allParams
  }

  //todo - if you want params to vary based on velocity, need to modify noteOn func generated by script
  noteOn(note: number, velocity: number, pressure: number, slide: number): void {
    this.pitch = note
    this._pressure = pressure
    this._slide = slide
    this.node.setParamValue("oscillator/VelocityAmp", velocity)
    this.node.setParamValue("/oscillator/Gate", 1)
  }

  get polyGain(): number {
    return this.node.getParamValue("/oscillator/PolyGain")
  }

  @param(0, 1, 0.7)
  set polyGain(value: number) {
    this.node.setParamValue("/oscillator/PolyGain", value)
  }

  get release(): number {
    return this.node.getParamValue("/oscillator/Release")
  }

  @param(0, 10, 0.05)
  set release(value: number) {
    this.node.setParamValue("/oscillator/Release", value)
  }

  get pan(): number {
    return this.node.getParamValue("/oscillator/Pan")
  }

  @param(0, 1, 0.5)
  set pan(value: number) {
    this.node.setParamValue("/oscillator/Pan", value)
  }

  noteOff(): void {
    this.node.setParamValue("/oscillator/Gate", 0)

    // // Call the callback after the release time
    // setTimeout(() => {
    //   if (this.voiceFinishedCB) {
    //     this.voiceFinishedCB()
    //   }
    // }, Number(this.ampEnv.release) * 1000) 
  }

  //do you need voiceFinishedCB? might be too niche for template script
  //todo need to have "release" value available at API level for proper voice lifecycle management (eg, don't want to accidentally reuse a voice that is still in release)

  forceFinish(): void {
    //todo - need to implement forceFinish properly for voice stealing - might need a per voice global gain object to manage voice stealing?


    // if (this.voiceFinishedCB) {
    //   this.voiceFinishedCB()
    // }
  }

  dispose(): void {
    this.node.disconnect()
    this.node.destroy()
  }

  get pitch(): number {
    return f2m(this.node.getParamValue('/oscillator/Frequency'))
  }

  set pitch(value: number) {
    this.node.setParamValue("/oscillator/Frequency", m2f(value))
  }

  get slide(): number {
    return this._slide
  }

  set slide(value: number) {
    this._slide = value
  }

  get pressure(): number {
    return this._pressure
  }

  set pressure(value: number) {
    this._pressure = value
  }

  get Filter(): number {
    return this.node.getParamValue("/oscillator/Filter");
  }

  @param(20, 10000, 3000)
  set Filter(value: number) {
    this.node.setParamValue("/oscillator/Filter", value);
  }

  get detune(): number {
    return this.node.getParamValue("/oscillator/Detune")
  }

  @param(0, 50, 1)
  set detune(value: number) {
    this.node.setParamValue("/oscillator/Detune", value)
  }

  get modRelease(): number {
    return this.node.getParamValue("/oscillator/ModRelease")
  }

  @param(0, 1, 0.3)
  set modRelease(value: number) {
    this.node.setParamValue("/oscillator/ModRelease", value)
  }

  get echoFdbk(): number {
    return this.node.getParamValue("/oscillator/EchoFdbk");
  }

  @param(0, 1, 0.3)
  set echoFdbk(value: number) {
    this.node.setParamValue("/oscillator/EchoFdbk", value);
  }

  get echoTime(): number {
    return this.node.getParamValue("/oscillator/EchoTime");
  }

  @param(0.01, 10, 0.3)
  set echoTime(value: number) {
    this.node.setParamValue("/oscillator/EchoTime", value);
  }

}

