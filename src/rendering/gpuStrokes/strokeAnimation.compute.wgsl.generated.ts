// Auto-generated by wgsl type generator. DO NOT EDIT.

import * as BABYLON from 'babylonjs';

import shaderSource from './strokeAnimation.compute.wgsl?raw';

export interface StrokeAnimationLaunchConfig {
  strokeAIndex: number;
  strokeBIndex: number;
  interpolationT: number;
  totalDuration: number;
  elapsedTime: number;
  startPointX: number;
  startPointY: number;
  scale: number;
  isActive: number;
  phase: number;
  colorR: number;
  colorG: number;
  colorB: number;
  colorA: number;
}

export const StrokeAnimationLaunchConfigLayout = {
  size: 56,
  align: 4,
  members: [
  { name: 'strokeAIndex', offset: 0, size: 4, slot: 1 },
  { name: 'strokeBIndex', offset: 4, size: 4, slot: 1 },
  { name: 'interpolationT', offset: 8, size: 4, slot: 1 },
  { name: 'totalDuration', offset: 12, size: 4, slot: 1 },
  { name: 'elapsedTime', offset: 16, size: 4, slot: 1 },
  { name: 'startPointX', offset: 20, size: 4, slot: 1 },
  { name: 'startPointY', offset: 24, size: 4, slot: 1 },
  { name: 'scale', offset: 28, size: 4, slot: 1 },
  { name: 'isActive', offset: 32, size: 4, slot: 1 },
  { name: 'phase', offset: 36, size: 4, slot: 1 },
  { name: 'colorR', offset: 40, size: 4, slot: 1 },
  { name: 'colorG', offset: 44, size: 4, slot: 1 },
  { name: 'colorB', offset: 48, size: 4, slot: 1 },
  { name: 'colorA', offset: 52, size: 4, slot: 1 }
  ] as const,
} as const;

export function packStrokeAnimationLaunchConfig(target: Float32Array, floatOffset: number, value: StrokeAnimationLaunchConfig): void {
  {
    const base = floatOffset + 0;
    const raw = value.strokeAIndex;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 1;
    const raw = value.strokeBIndex;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 2;
    const raw = value.interpolationT;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 3;
    const raw = value.totalDuration;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 4;
    const raw = value.elapsedTime;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 5;
    const raw = value.startPointX;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 6;
    const raw = value.startPointY;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 7;
    const raw = value.scale;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 8;
    const raw = value.isActive;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 9;
    const raw = value.phase;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 10;
    const raw = value.colorR;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 11;
    const raw = value.colorG;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 12;
    const raw = value.colorB;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 13;
    const raw = value.colorA;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
}

export interface StrokeAnimationGlobalParams {
  time: number;
  canvasWidth: number;
  canvasHeight: number;
  maxAnimations: number;
  deltaTime: number;
  textureHeight: number;
  padding1: number;
  padding2: number;
}

export const StrokeAnimationGlobalParamsLayout = {
  size: 32,
  align: 4,
  members: [
  { name: 'time', offset: 0, size: 4, slot: 1 },
  { name: 'canvasWidth', offset: 4, size: 4, slot: 1 },
  { name: 'canvasHeight', offset: 8, size: 4, slot: 1 },
  { name: 'maxAnimations', offset: 12, size: 4, slot: 1 },
  { name: 'deltaTime', offset: 16, size: 4, slot: 1 },
  { name: 'textureHeight', offset: 20, size: 4, slot: 1 },
  { name: 'padding1', offset: 24, size: 4, slot: 1 },
  { name: 'padding2', offset: 28, size: 4, slot: 1 }
  ] as const,
} as const;

export function packStrokeAnimationGlobalParams(target: Float32Array, floatOffset: number, value: StrokeAnimationGlobalParams): void {
  {
    const base = floatOffset + 0;
    const raw = value.time;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 1;
    const raw = value.canvasWidth;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 2;
    const raw = value.canvasHeight;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 3;
    const raw = value.maxAnimations;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 4;
    const raw = value.deltaTime;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 5;
    const raw = value.textureHeight;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 6;
    const raw = value.padding1;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 7;
    const raw = value.padding2;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
}

const uniformLayout_globalParams = [
  { name: 'time', slot: 1 },
  { name: 'canvasWidth', slot: 1 },
  { name: 'canvasHeight', slot: 1 },
  { name: 'maxAnimations', slot: 1 },
  { name: 'deltaTime', slot: 1 },
  { name: 'textureHeight', slot: 1 },
  { name: 'padding1', slot: 1 },
  { name: 'padding2', slot: 1 }
] as const;

export interface GlobalParamsUniforms {
  time: number;
  canvasWidth: number;
  canvasHeight: number;
  maxAnimations: number;
  deltaTime: number;
  textureHeight: number;
  padding1: number;
  padding2: number;
}

export interface GlobalParamsUniformState {
  buffer: BABYLON.UniformBuffer;
  uniforms: GlobalParamsUniforms;
}

export function createUniformBuffer_globalParams(engine: BABYLON.WebGPUEngine, initial?: Partial<GlobalParamsUniforms>): GlobalParamsUniformState {
  const buffer = new BABYLON.UniformBuffer(engine);
  const uniforms: GlobalParamsUniforms = {
    time: 0,
    canvasWidth: 0,
    canvasHeight: 0,
    maxAnimations: 0,
    deltaTime: 0,
    textureHeight: 0,
    padding1: 0,
    padding2: 0,
  };
  for (const entry of uniformLayout_globalParams) {
    buffer.addUniform(entry.name, entry.slot);
  }
  if (initial) {
    updateUniformBuffer_globalParams({ buffer, uniforms }, initial);
  } else {
    buffer.update();
  }
  return { buffer, uniforms };
}

export function updateUniformBuffer_globalParams(state: GlobalParamsUniformState, updates: Partial<GlobalParamsUniforms>): void {
  let dirty = false;
  if (updates.time !== undefined) {
    dirty = true;
    const raw = updates.time! as any;
    const numeric = raw !== undefined ? Number(raw) : 0;
    state.uniforms.time = numeric;
    const bufferView = new Float32Array(1);
    bufferView[0] = numeric;
    state.buffer.updateUniform('time', bufferView, 1);
  }
  if (updates.canvasWidth !== undefined) {
    dirty = true;
    const raw = updates.canvasWidth! as any;
    const numeric = raw !== undefined ? Number(raw) : 0;
    state.uniforms.canvasWidth = numeric;
    const bufferView = new Float32Array(1);
    bufferView[0] = numeric;
    state.buffer.updateUniform('canvasWidth', bufferView, 1);
  }
  if (updates.canvasHeight !== undefined) {
    dirty = true;
    const raw = updates.canvasHeight! as any;
    const numeric = raw !== undefined ? Number(raw) : 0;
    state.uniforms.canvasHeight = numeric;
    const bufferView = new Float32Array(1);
    bufferView[0] = numeric;
    state.buffer.updateUniform('canvasHeight', bufferView, 1);
  }
  if (updates.maxAnimations !== undefined) {
    dirty = true;
    const raw = updates.maxAnimations! as any;
    const numeric = raw !== undefined ? Number(raw) : 0;
    state.uniforms.maxAnimations = numeric;
    const bufferView = new Float32Array(1);
    bufferView[0] = numeric;
    state.buffer.updateUniform('maxAnimations', bufferView, 1);
  }
  if (updates.deltaTime !== undefined) {
    dirty = true;
    const raw = updates.deltaTime! as any;
    const numeric = raw !== undefined ? Number(raw) : 0;
    state.uniforms.deltaTime = numeric;
    const bufferView = new Float32Array(1);
    bufferView[0] = numeric;
    state.buffer.updateUniform('deltaTime', bufferView, 1);
  }
  if (updates.textureHeight !== undefined) {
    dirty = true;
    const raw = updates.textureHeight! as any;
    const numeric = raw !== undefined ? Number(raw) : 0;
    state.uniforms.textureHeight = numeric;
    const bufferView = new Float32Array(1);
    bufferView[0] = numeric;
    state.buffer.updateUniform('textureHeight', bufferView, 1);
  }
  if (updates.padding1 !== undefined) {
    dirty = true;
    const raw = updates.padding1! as any;
    const numeric = raw !== undefined ? Number(raw) : 0;
    state.uniforms.padding1 = numeric;
    const bufferView = new Float32Array(1);
    bufferView[0] = numeric;
    state.buffer.updateUniform('padding1', bufferView, 1);
  }
  if (updates.padding2 !== undefined) {
    dirty = true;
    const raw = updates.padding2! as any;
    const numeric = raw !== undefined ? Number(raw) : 0;
    state.uniforms.padding2 = numeric;
    const bufferView = new Float32Array(1);
    bufferView[0] = numeric;
    state.buffer.updateUniform('padding2', bufferView, 1);
  }
  if (dirty) {
    state.buffer.update();
  }
}

export interface InstanceMatricesStorageState {
  buffer: BABYLON.StorageBuffer;
  data: Float32Array;
  capacity: number;
  floatsPerElement: number;
}

export function createStorageBuffer_instanceMatrices(engine: BABYLON.WebGPUEngine, capacity: number, options?: { initial?: number[][]; usage?: number; }): InstanceMatricesStorageState {
  const byteStride = 16;
  const floatsPerElement = byteStride / Float32Array.BYTES_PER_ELEMENT;
  const totalFloats = floatsPerElement * capacity;
  const data = new Float32Array(totalFloats);
  const usage = options?.usage ?? (BABYLON.Constants.BUFFER_CREATIONFLAG_STORAGE | BABYLON.Constants.BUFFER_CREATIONFLAG_WRITE);
  const buffer = new BABYLON.StorageBuffer(engine, byteStride * capacity, usage);
  if (options?.initial) {
    data.set(options.initial.flat().slice(0, totalFloats));
    buffer.update(data);
  }
  return { buffer, data, capacity, floatsPerElement };
}

export function writeStorageValue_instanceMatrices(state: InstanceMatricesStorageState, index: number, value: number[]): void {
  const offset = index * state.floatsPerElement;
  for (let i = 0; i < state.floatsPerElement; i++) {
    state.data[offset + i] = value[i] ?? 0;
  }
}

export function updateStorageBuffer_instanceMatrices(state: InstanceMatricesStorageState): void {
  state.buffer.update(state.data);
}

export interface LaunchConfigsStorageState {
  buffer: BABYLON.StorageBuffer;
  data: Float32Array;
  capacity: number;
  floatsPerElement: number;
}

export function createStorageBuffer_launchConfigs(engine: BABYLON.WebGPUEngine, capacity: number, options?: { initial?: StrokeAnimationLaunchConfig[]; usage?: number; }): LaunchConfigsStorageState {
  const byteStride = 56;
  const floatsPerElement = byteStride / Float32Array.BYTES_PER_ELEMENT;
  const totalFloats = floatsPerElement * capacity;
  const data = new Float32Array(totalFloats);
  const usage = options?.usage ?? (BABYLON.Constants.BUFFER_CREATIONFLAG_STORAGE | BABYLON.Constants.BUFFER_CREATIONFLAG_WRITE);
  const buffer = new BABYLON.StorageBuffer(engine, byteStride * capacity, usage);
  if (options?.initial) {
    options.initial.slice(0, capacity).forEach((value, index) => {
      packStrokeAnimationLaunchConfig(data, index * floatsPerElement, value);
    });
    buffer.update(data);
  }
  return { buffer, data, capacity, floatsPerElement };
}

export function writeStorageValue_launchConfigs(state: LaunchConfigsStorageState, index: number, value: StrokeAnimationLaunchConfig): void {
  const offset = index * state.floatsPerElement;
  packStrokeAnimationLaunchConfig(state.data, offset, value);
}

export function updateStorageBuffer_launchConfigs(state: LaunchConfigsStorageState): void {
  state.buffer.update(state.data);
}

export interface InstanceColorsStorageState {
  buffer: BABYLON.StorageBuffer;
  data: Float32Array;
  capacity: number;
  floatsPerElement: number;
}

export function createStorageBuffer_instanceColors(engine: BABYLON.WebGPUEngine, capacity: number, options?: { initial?: number[][]; usage?: number; }): InstanceColorsStorageState {
  const byteStride = 16;
  const floatsPerElement = byteStride / Float32Array.BYTES_PER_ELEMENT;
  const totalFloats = floatsPerElement * capacity;
  const data = new Float32Array(totalFloats);
  const usage = options?.usage ?? (BABYLON.Constants.BUFFER_CREATIONFLAG_STORAGE | BABYLON.Constants.BUFFER_CREATIONFLAG_WRITE);
  const buffer = new BABYLON.StorageBuffer(engine, byteStride * capacity, usage);
  if (options?.initial) {
    data.set(options.initial.flat().slice(0, totalFloats));
    buffer.update(data);
  }
  return { buffer, data, capacity, floatsPerElement };
}

export function writeStorageValue_instanceColors(state: InstanceColorsStorageState, index: number, value: number[]): void {
  const offset = index * state.floatsPerElement;
  for (let i = 0; i < state.floatsPerElement; i++) {
    state.data[offset + i] = value[i] ?? 0;
  }
}

export function updateStorageBuffer_instanceColors(state: InstanceColorsStorageState): void {
  state.buffer.update(state.data);
}

const bindingLayout = {
    globalParams: { group: 0, binding: 2 },
    instanceMatrices: { group: 0, binding: 0 },
    launchConfigs: { group: 0, binding: 1 },
    instanceColors: { group: 0, binding: 5 },
    strokeTexture: { group: 0, binding: 3 },
    strokeSampler: { group: 0, binding: 4 }
};

export interface ShaderBindings {
    globalParams: GlobalParamsUniformState;
    instanceMatrices: BABYLON.StorageBuffer;
    launchConfigs: BABYLON.StorageBuffer;
    instanceColors: BABYLON.StorageBuffer;
    strokeTexture: BABYLON.BaseTexture;
    strokeSampler: BABYLON.TextureSampler;
}

export interface ShaderState {
  shader: BABYLON.ComputeShader;
  bindings: ShaderBindings;
}

export function createShader(engine: BABYLON.WebGPUEngine, bindings: ShaderBindings, options?: { entryPoint?: string; source?: string; name?: string; }): ShaderState {
  const shader = new BABYLON.ComputeShader(options?.name ?? 'strokeAnimation', engine, { computeSource: options?.source ?? shaderSource }, {
    entryPoint: options?.entryPoint ?? 'main',
    bindingsMapping: bindingLayout,
  });
  shader.setUniformBuffer('globalParams', bindings.globalParams.buffer);
  shader.setStorageBuffer('instanceMatrices', bindings.instanceMatrices);
  shader.setStorageBuffer('launchConfigs', bindings.launchConfigs);
  shader.setStorageBuffer('instanceColors', bindings.instanceColors);
  shader.setTexture('strokeTexture', bindings.strokeTexture, false);
  shader.setTextureSampler('strokeSampler', bindings.strokeSampler);
  return { shader, bindings };
}

export function updateBindings(state: ShaderState, updates: Partial<ShaderBindings>): void {
  if (updates.globalParams !== undefined) {
    state.bindings.globalParams = updates.globalParams!;
    state.shader.setUniformBuffer('globalParams', updates.globalParams!.buffer);
  }
  if (updates.instanceMatrices !== undefined) {
    state.bindings.instanceMatrices = updates.instanceMatrices!;
    state.shader.setStorageBuffer('instanceMatrices', updates.instanceMatrices!);
  }
  if (updates.launchConfigs !== undefined) {
    state.bindings.launchConfigs = updates.launchConfigs!;
    state.shader.setStorageBuffer('launchConfigs', updates.launchConfigs!);
  }
  if (updates.instanceColors !== undefined) {
    state.bindings.instanceColors = updates.instanceColors!;
    state.shader.setStorageBuffer('instanceColors', updates.instanceColors!);
  }
  if (updates.strokeTexture !== undefined) {
    state.bindings.strokeTexture = updates.strokeTexture!;
    state.shader.setTexture('strokeTexture', updates.strokeTexture!, false);
  }
  if (updates.strokeSampler !== undefined) {
    state.bindings.strokeSampler = updates.strokeSampler!;
    state.shader.setTextureSampler('strokeSampler', updates.strokeSampler!);
  }
}

export const createUniformBuffer = createUniformBuffer_globalParams;
export const updateUniformBuffer = updateUniformBuffer_globalParams;