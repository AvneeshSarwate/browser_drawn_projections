// Auto-generated by wgsl fragment generator. DO NOT EDIT.
import * as BABYLON from 'babylonjs';
import { CustomShaderEffect, type ShaderSource, type RenderPrecision, type ShaderUniforms, type Dynamic } from '../shaderFXBabylon';
export const BloomVertexSource = `// Auto-generated by wgsl fragment generator. DO NOT EDIT.
attribute position: vec3<f32>;
attribute uv: vec2<f32>;
varying vUV: vec2<f32>;
uniform uniforms_preBlackLevel: f32;
uniform uniforms_preGamma: f32;
uniform uniforms_preBrightness: f32;
uniform uniforms_minBloomRadius: f32;
uniform uniforms_maxBloomRadius: f32;
uniform uniforms_bloomThreshold: f32;
uniform uniforms_bloomSCurve: f32;
uniform uniforms_bloomFill: f32;
uniform uniforms_bloomIntensity: f32;
uniform uniforms_outputMode: u32;
uniform uniforms_inputImage: f32;
var src: texture_2d<f32>;
var srcSampler: sampler;
var base: texture_2d<f32>;
var baseSampler: sampler;

#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs) -> FragmentInputs {
#define CUSTOM_VERTEX_MAIN_BEGIN
  vertexOutputs.position = vec4<f32>(vertexInputs.position, 1.0);
  vertexOutputs.vUV = vertexInputs.uv;
#define CUSTOM_VERTEX_MAIN_END
}

`;
export const BloomFragmentSources = [
  `// Auto-generated by wgsl fragment generator. DO NOT EDIT.
varying vUV: vec2<f32>;
uniform uniforms_preBlackLevel: f32;
uniform uniforms_preGamma: f32;
uniform uniforms_preBrightness: f32;
uniform uniforms_minBloomRadius: f32;
uniform uniforms_maxBloomRadius: f32;
uniform uniforms_bloomThreshold: f32;
uniform uniforms_bloomSCurve: f32;
uniform uniforms_bloomFill: f32;
uniform uniforms_bloomIntensity: f32;
uniform uniforms_outputMode: u32;
uniform uniforms_inputImage: f32;
var src: texture_2d<f32>;
var srcSampler: sampler;
var base: texture_2d<f32>;
var baseSampler: sampler;

// Source fragment function
struct BloomUniforms {
  preBlackLevel: f32, // 0.05
  preGamma: f32, // 1.0
  preBrightness: f32, // 2.0
  minBloomRadius: f32, // 0.1
  maxBloomRadius: f32, // 0.6
  bloomThreshold: f32, // 0.12
  bloomSCurve: f32, // 0.35
  bloomFill: f32, // 0.25
  bloomIntensity: f32, // 1.1
  outputMode: u32, // 0
  inputImage: f32, // 1.0
};

fn saturateVec3(value: vec3f) -> vec3f {
  return clamp(value, vec3f(0.0), vec3f(1.0));
}

fn saturateScalar(value: f32) -> f32 {
  return clamp(value, 0.0, 1.0);
}

fn applyPreprocess(color: vec3f, uniforms: BloomUniforms) -> vec3f {
  var isolated = max(color - vec3f(uniforms.preBlackLevel), vec3f(0.0));
  isolated = isolated * uniforms.preBrightness;
  let gamma = max(uniforms.preGamma, 1e-6);
  let invGamma = 1.0 / gamma;
  isolated = pow(max(isolated, vec3f(0.0)), vec3f(invGamma));
  return saturateVec3(isolated);
}

fn applyThreshold(value: vec3f, threshold: f32) -> vec3f {
  return max(value - vec3f(threshold), vec3f(0.0));
}

fn applySCurve(value: vec3f, amount: f32) -> vec3f {
  let t = saturateScalar(amount);
  if (t <= 0.0) {
    return value;
  }
  let smoothVal = value * value * (3.0 - 2.0 * value);
  return mix(value, smoothVal, vec3f(t));
}

fn computeRadiusUv(radiusNorm: f32, fill: f32, texelSize: vec2f) -> vec2f {
  let safeNorm = saturateScalar(radiusNorm);
  let spread = 1.0 + fill * 6.0;
  let radiusPixels = (1.0 + safeNorm * 6.0) * spread;
  return radiusPixels * texelSize;
}

fn pass0(uv: vec2f, uniforms: BloomUniforms, src: texture_2d<f32>, srcSampler: sampler, base: texture_2d<f32>, baseSampler: sampler) -> vec4f {
  let baseColor = textureSample(src, srcSampler, uv);
  let processed = applyPreprocess(baseColor.rgb, uniforms);
  let alpha = max(max(processed.r, processed.g), processed.b);
  return vec4f(processed, alpha);
}

fn pass1(uv: vec2f, uniforms: BloomUniforms, src: texture_2d<f32>, srcSampler: sampler, base: texture_2d<f32>, baseSampler: sampler) -> vec4f {
  let baseColor = textureSample(base, baseSampler, uv);
  let preColor = textureSample(src, srcSampler, uv).rgb;

  let dims = textureDimensions(src);
  let texelSize = vec2f(
    select(1.0 / f32(dims.x), 0.0, dims.x == 0u),
    select(1.0 / f32(dims.y), 0.0, dims.y == 0u),
  );
  let minRadius = min(uniforms.minBloomRadius, uniforms.maxBloomRadius);
  let maxRadius = max(uniforms.minBloomRadius, uniforms.maxBloomRadius);
  var accum = preColor;
  var totalWeight = 1.0;
  let levelCount = 6;
  for (var level = 0; level < levelCount; level = level + 1) {
    let t = f32(level + 1) / f32(levelCount);
    let radiusNorm = mix(minRadius, maxRadius, t);
    let offsetScale = computeRadiusUv(radiusNorm, uniforms.bloomFill, texelSize);
    let weightBase = 1.0 / (1.0 + radiusNorm * 8.0 + uniforms.bloomFill * 4.0);
    for (var i = 0; i < 8; i = i + 1) {
      var direction = vec2f(1.0, 0.0);
      switch u32(i) {
        case 0u: {
          direction = vec2f(1.0, 0.0);
        }
        case 1u: {
          direction = vec2f(-1.0, 0.0);
        }
        case 2u: {
          direction = vec2f(0.0, 1.0);
        }
        case 3u: {
          direction = vec2f(0.0, -1.0);
        }
        case 4u: {
          direction = vec2f(0.7071, 0.7071);
        }
        case 5u: {
          direction = vec2f(-0.7071, 0.7071);
        }
        case 6u: {
          direction = vec2f(0.7071, -0.7071);
        }
        default: {
          direction = vec2f(-0.7071, -0.7071);
        }
      }
      let offsetUV = uv + direction * offsetScale;
      let sampleColor = textureSample(src, srcSampler, offsetUV).rgb;
      accum = accum + sampleColor * weightBase;
      totalWeight = totalWeight + weightBase;
    }
  }

  var bloom = accum / max(totalWeight, 1e-5);
  bloom = applyThreshold(bloom, uniforms.bloomThreshold);
  bloom = applySCurve(bloom, uniforms.bloomSCurve);
  bloom = bloom * uniforms.bloomIntensity;
  bloom = saturateVec3(bloom);

  let outputMode = uniforms.outputMode;
  let inputContribution = baseColor.rgb * uniforms.inputImage;

  let bloomAlpha = max(max(bloom.r, bloom.g), bloom.b);
  var finalColor = vec3f(0.0);
  var finalAlpha = baseColor.a;

  switch outputMode {
    case 1u: { // Input only
      finalColor = inputContribution;
      finalAlpha = baseColor.a;
    }
    case 2u: { // Preprocess preview
      finalColor = preColor;
      finalAlpha = 1.0;
    }
    case 3u: { // Bloom only
      finalColor = bloom;
      finalAlpha = 1.0;
    }
    case 4u: { // Bloom with alpha
      finalColor = bloom;
      finalAlpha = bloomAlpha;
    }
    default: { // Input + Bloom
      finalColor = saturateVec3(inputContribution + bloom);
      finalAlpha = baseColor.a;
    }
  }

  return vec4f(finalColor, finalAlpha);
}

fn load_BloomUniforms() -> BloomUniforms {
  return BloomUniforms(
  uniforms.uniforms_preBlackLevel,
  uniforms.uniforms_preGamma,
  uniforms.uniforms_preBrightness,
  uniforms.uniforms_minBloomRadius,
  uniforms.uniforms_maxBloomRadius,
  uniforms.uniforms_bloomThreshold,
  uniforms.uniforms_bloomSCurve,
  uniforms.uniforms_bloomFill,
  uniforms.uniforms_bloomIntensity,
  uniforms.uniforms_outputMode,
  uniforms.uniforms_inputImage
  );
}

#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs) -> FragmentOutputs {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
  let uniforms_value = load_BloomUniforms();
  let uv_local = fragmentInputs.vUV;
  let color = pass0(uv_local, uniforms_value, src, srcSampler, base, baseSampler);
  fragmentOutputs.color = color;
#define CUSTOM_FRAGMENT_MAIN_END
}

`, // pass0
  `// Auto-generated by wgsl fragment generator. DO NOT EDIT.
varying vUV: vec2<f32>;
uniform uniforms_preBlackLevel: f32;
uniform uniforms_preGamma: f32;
uniform uniforms_preBrightness: f32;
uniform uniforms_minBloomRadius: f32;
uniform uniforms_maxBloomRadius: f32;
uniform uniforms_bloomThreshold: f32;
uniform uniforms_bloomSCurve: f32;
uniform uniforms_bloomFill: f32;
uniform uniforms_bloomIntensity: f32;
uniform uniforms_outputMode: u32;
uniform uniforms_inputImage: f32;
var src: texture_2d<f32>;
var srcSampler: sampler;
var base: texture_2d<f32>;
var baseSampler: sampler;

// Source fragment function
struct BloomUniforms {
  preBlackLevel: f32, // 0.05
  preGamma: f32, // 1.0
  preBrightness: f32, // 2.0
  minBloomRadius: f32, // 0.1
  maxBloomRadius: f32, // 0.6
  bloomThreshold: f32, // 0.12
  bloomSCurve: f32, // 0.35
  bloomFill: f32, // 0.25
  bloomIntensity: f32, // 1.1
  outputMode: u32, // 0
  inputImage: f32, // 1.0
};

fn saturateVec3(value: vec3f) -> vec3f {
  return clamp(value, vec3f(0.0), vec3f(1.0));
}

fn saturateScalar(value: f32) -> f32 {
  return clamp(value, 0.0, 1.0);
}

fn applyPreprocess(color: vec3f, uniforms: BloomUniforms) -> vec3f {
  var isolated = max(color - vec3f(uniforms.preBlackLevel), vec3f(0.0));
  isolated = isolated * uniforms.preBrightness;
  let gamma = max(uniforms.preGamma, 1e-6);
  let invGamma = 1.0 / gamma;
  isolated = pow(max(isolated, vec3f(0.0)), vec3f(invGamma));
  return saturateVec3(isolated);
}

fn applyThreshold(value: vec3f, threshold: f32) -> vec3f {
  return max(value - vec3f(threshold), vec3f(0.0));
}

fn applySCurve(value: vec3f, amount: f32) -> vec3f {
  let t = saturateScalar(amount);
  if (t <= 0.0) {
    return value;
  }
  let smoothVal = value * value * (3.0 - 2.0 * value);
  return mix(value, smoothVal, vec3f(t));
}

fn computeRadiusUv(radiusNorm: f32, fill: f32, texelSize: vec2f) -> vec2f {
  let safeNorm = saturateScalar(radiusNorm);
  let spread = 1.0 + fill * 6.0;
  let radiusPixels = (1.0 + safeNorm * 6.0) * spread;
  return radiusPixels * texelSize;
}

fn pass0(uv: vec2f, uniforms: BloomUniforms, src: texture_2d<f32>, srcSampler: sampler, base: texture_2d<f32>, baseSampler: sampler) -> vec4f {
  let baseColor = textureSample(src, srcSampler, uv);
  let processed = applyPreprocess(baseColor.rgb, uniforms);
  let alpha = max(max(processed.r, processed.g), processed.b);
  return vec4f(processed, alpha);
}

fn pass1(uv: vec2f, uniforms: BloomUniforms, src: texture_2d<f32>, srcSampler: sampler, base: texture_2d<f32>, baseSampler: sampler) -> vec4f {
  let baseColor = textureSample(base, baseSampler, uv);
  let preColor = textureSample(src, srcSampler, uv).rgb;

  let dims = textureDimensions(src);
  let texelSize = vec2f(
    select(1.0 / f32(dims.x), 0.0, dims.x == 0u),
    select(1.0 / f32(dims.y), 0.0, dims.y == 0u),
  );
  let minRadius = min(uniforms.minBloomRadius, uniforms.maxBloomRadius);
  let maxRadius = max(uniforms.minBloomRadius, uniforms.maxBloomRadius);
  var accum = preColor;
  var totalWeight = 1.0;
  let levelCount = 6;
  for (var level = 0; level < levelCount; level = level + 1) {
    let t = f32(level + 1) / f32(levelCount);
    let radiusNorm = mix(minRadius, maxRadius, t);
    let offsetScale = computeRadiusUv(radiusNorm, uniforms.bloomFill, texelSize);
    let weightBase = 1.0 / (1.0 + radiusNorm * 8.0 + uniforms.bloomFill * 4.0);
    for (var i = 0; i < 8; i = i + 1) {
      var direction = vec2f(1.0, 0.0);
      switch u32(i) {
        case 0u: {
          direction = vec2f(1.0, 0.0);
        }
        case 1u: {
          direction = vec2f(-1.0, 0.0);
        }
        case 2u: {
          direction = vec2f(0.0, 1.0);
        }
        case 3u: {
          direction = vec2f(0.0, -1.0);
        }
        case 4u: {
          direction = vec2f(0.7071, 0.7071);
        }
        case 5u: {
          direction = vec2f(-0.7071, 0.7071);
        }
        case 6u: {
          direction = vec2f(0.7071, -0.7071);
        }
        default: {
          direction = vec2f(-0.7071, -0.7071);
        }
      }
      let offsetUV = uv + direction * offsetScale;
      let sampleColor = textureSample(src, srcSampler, offsetUV).rgb;
      accum = accum + sampleColor * weightBase;
      totalWeight = totalWeight + weightBase;
    }
  }

  var bloom = accum / max(totalWeight, 1e-5);
  bloom = applyThreshold(bloom, uniforms.bloomThreshold);
  bloom = applySCurve(bloom, uniforms.bloomSCurve);
  bloom = bloom * uniforms.bloomIntensity;
  bloom = saturateVec3(bloom);

  let outputMode = uniforms.outputMode;
  let inputContribution = baseColor.rgb * uniforms.inputImage;

  let bloomAlpha = max(max(bloom.r, bloom.g), bloom.b);
  var finalColor = vec3f(0.0);
  var finalAlpha = baseColor.a;

  switch outputMode {
    case 1u: { // Input only
      finalColor = inputContribution;
      finalAlpha = baseColor.a;
    }
    case 2u: { // Preprocess preview
      finalColor = preColor;
      finalAlpha = 1.0;
    }
    case 3u: { // Bloom only
      finalColor = bloom;
      finalAlpha = 1.0;
    }
    case 4u: { // Bloom with alpha
      finalColor = bloom;
      finalAlpha = bloomAlpha;
    }
    default: { // Input + Bloom
      finalColor = saturateVec3(inputContribution + bloom);
      finalAlpha = baseColor.a;
    }
  }

  return vec4f(finalColor, finalAlpha);
}

fn load_BloomUniforms() -> BloomUniforms {
  return BloomUniforms(
  uniforms.uniforms_preBlackLevel,
  uniforms.uniforms_preGamma,
  uniforms.uniforms_preBrightness,
  uniforms.uniforms_minBloomRadius,
  uniforms.uniforms_maxBloomRadius,
  uniforms.uniforms_bloomThreshold,
  uniforms.uniforms_bloomSCurve,
  uniforms.uniforms_bloomFill,
  uniforms.uniforms_bloomIntensity,
  uniforms.uniforms_outputMode,
  uniforms.uniforms_inputImage
  );
}

#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs) -> FragmentOutputs {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
  let uniforms_value = load_BloomUniforms();
  let uv_local = fragmentInputs.vUV;
  let color = pass1(uv_local, uniforms_value, src, srcSampler, base, baseSampler);
  fragmentOutputs.color = color;
#define CUSTOM_FRAGMENT_MAIN_END
}

`, // pass1
] as const;
export const BloomPassCount = 2 as const;
export const BloomPrimaryTextureName = 'src' as const;

export interface BloomUniforms {
  preBlackLevel: number;
  preGamma: number;
  preBrightness: number;
  minBloomRadius: number;
  maxBloomRadius: number;
  bloomThreshold: number;
  bloomSCurve: number;
  bloomFill: number;
  bloomIntensity: number;
  outputMode: number;
  inputImage: number;
}

export function setBloomUniforms(material: BABYLON.ShaderMaterial, uniforms: Partial<BloomUniforms>): void {
  if (!uniforms) {
    return;
  }
  if (uniforms.preBlackLevel !== undefined) {
    material.setFloat('uniforms_preBlackLevel', uniforms.preBlackLevel);
  }
  if (uniforms.preGamma !== undefined) {
    material.setFloat('uniforms_preGamma', uniforms.preGamma);
  }
  if (uniforms.preBrightness !== undefined) {
    material.setFloat('uniforms_preBrightness', uniforms.preBrightness);
  }
  if (uniforms.minBloomRadius !== undefined) {
    material.setFloat('uniforms_minBloomRadius', uniforms.minBloomRadius);
  }
  if (uniforms.maxBloomRadius !== undefined) {
    material.setFloat('uniforms_maxBloomRadius', uniforms.maxBloomRadius);
  }
  if (uniforms.bloomThreshold !== undefined) {
    material.setFloat('uniforms_bloomThreshold', uniforms.bloomThreshold);
  }
  if (uniforms.bloomSCurve !== undefined) {
    material.setFloat('uniforms_bloomSCurve', uniforms.bloomSCurve);
  }
  if (uniforms.bloomFill !== undefined) {
    material.setFloat('uniforms_bloomFill', uniforms.bloomFill);
  }
  if (uniforms.bloomIntensity !== undefined) {
    material.setFloat('uniforms_bloomIntensity', uniforms.bloomIntensity);
  }
  if (uniforms.outputMode !== undefined) {
    material.setUInt('uniforms_outputMode', uniforms.outputMode);
  }
  if (uniforms.inputImage !== undefined) {
    material.setFloat('uniforms_inputImage', uniforms.inputImage);
  }
}

export type BloomTextureName = 'src' | 'base';
export interface BloomInputs {
  src: ShaderSource;
  base: ShaderSource;
}

export interface BloomMaterialHandles {
  material: BABYLON.ShaderMaterial;
  setTexture(name: BloomTextureName, texture: BABYLON.BaseTexture): void;
  setTextureSampler(name: BloomTextureName, sampler: BABYLON.TextureSampler): void;
  setUniforms(uniforms: Partial<BloomUniforms>): void;
}

export interface BloomMaterialOptions {
  name?: string;
  passIndex?: number;
}

export function createBloomMaterial(scene: BABYLON.Scene, options: BloomMaterialOptions = {}): BloomMaterialHandles {
  const passIndex = options.passIndex ?? 0;
  if (passIndex < 0 || passIndex >= 2) {
    throw new Error(`Invalid passIndex ${passIndex} for Bloom. Expected 0 <= passIndex < 2.`);
  }
  const baseName = options.name ?? 'BloomMaterial';
  const shaderName = `${baseName}_pass${passIndex}`;
  // Register shaders in the WGSL store to enable preprocessor
  const vertexShaderName = `${shaderName}VertexShader`;
  const fragmentShaderName = `${shaderName}FragmentShader`;
  
  BABYLON.ShaderStore.ShadersStoreWGSL[vertexShaderName] = BloomVertexSource;
  BABYLON.ShaderStore.ShadersStoreWGSL[fragmentShaderName] = BloomFragmentSources[passIndex];
  
  const material = new BABYLON.ShaderMaterial(shaderName, scene, {
    vertex: shaderName,
    fragment: shaderName,
  }, {
    attributes: ['position', 'uv'],
    uniforms: ['uniforms_preBlackLevel', 'uniforms_preGamma', 'uniforms_preBrightness', 'uniforms_minBloomRadius', 'uniforms_maxBloomRadius', 'uniforms_bloomThreshold', 'uniforms_bloomSCurve', 'uniforms_bloomFill', 'uniforms_bloomIntensity', 'uniforms_outputMode', 'uniforms_inputImage'],
    samplers: ['src', 'base'],
    samplerObjects: ['srcSampler', 'baseSampler'],
    shaderLanguage: BABYLON.ShaderLanguage.WGSL,
  });

  const samplerLookup = { 'src': 'srcSampler', 'base': 'baseSampler' } as const;

  const handles: BloomMaterialHandles = {
    material,
    setTexture: (name, texture) => material.setTexture(name, texture),
    setTextureSampler: (name, sampler) => material.setTextureSampler(samplerLookup[name], sampler),
    setUniforms: (values) => setBloomUniforms(material, values),
  };

  return handles;
}

export class BloomEffect extends CustomShaderEffect<BloomUniforms, BloomInputs> {
  effectName = 'Bloom'

  constructor(engine: BABYLON.WebGPUEngine, inputs: BloomInputs, width = 1280, height = 720, sampleMode: 'nearest' | 'linear' = 'linear', precision: RenderPrecision = 'half_float') {
    super(engine, inputs, {
      factory: (sceneRef, options) => createBloomMaterial(sceneRef, options),
      textureInputKeys: ['src', 'base'],
      passCount: 2,
      primaryTextureKey: 'src',
      width,
      height,
      materialName: 'BloomMaterial',
      sampleMode,
      precision,
    })
    this.setUniforms({
      preBlackLevel: 0.05,
      preGamma: 1.0,
      preBrightness: 2.0,
      minBloomRadius: 0.1,
      maxBloomRadius: 0.6,
      bloomThreshold: 0.12,
      bloomSCurve: 0.35,
      bloomFill: 0.25,
      bloomIntensity: 1.1,
      outputMode: 0,
      inputImage: 1.0,
    });
  }

  override setSrcs(inputs: Partial<BloomInputs>): void {
    super.setSrcs(inputs);
  }

  override setUniforms(uniforms: { preBlackLevel?: Dynamic<number>, preGamma?: Dynamic<number>, preBrightness?: Dynamic<number>, minBloomRadius?: Dynamic<number>, maxBloomRadius?: Dynamic<number>, bloomThreshold?: Dynamic<number>, bloomSCurve?: Dynamic<number>, bloomFill?: Dynamic<number>, bloomIntensity?: Dynamic<number>, outputMode?: Dynamic<number>, inputImage?: Dynamic<number> }): void {
    const record: ShaderUniforms = {};
    if (uniforms.preBlackLevel !== undefined) {
      record['preBlackLevel'] = uniforms.preBlackLevel;
    }
    if (uniforms.preGamma !== undefined) {
      record['preGamma'] = uniforms.preGamma;
    }
    if (uniforms.preBrightness !== undefined) {
      record['preBrightness'] = uniforms.preBrightness;
    }
    if (uniforms.minBloomRadius !== undefined) {
      record['minBloomRadius'] = uniforms.minBloomRadius;
    }
    if (uniforms.maxBloomRadius !== undefined) {
      record['maxBloomRadius'] = uniforms.maxBloomRadius;
    }
    if (uniforms.bloomThreshold !== undefined) {
      record['bloomThreshold'] = uniforms.bloomThreshold;
    }
    if (uniforms.bloomSCurve !== undefined) {
      record['bloomSCurve'] = uniforms.bloomSCurve;
    }
    if (uniforms.bloomFill !== undefined) {
      record['bloomFill'] = uniforms.bloomFill;
    }
    if (uniforms.bloomIntensity !== undefined) {
      record['bloomIntensity'] = uniforms.bloomIntensity;
    }
    if (uniforms.outputMode !== undefined) {
      record['outputMode'] = uniforms.outputMode;
    }
    if (uniforms.inputImage !== undefined) {
      record['inputImage'] = uniforms.inputImage;
    }
    super.setUniforms(record);
  }
}

