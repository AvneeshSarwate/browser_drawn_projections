// Auto-generated by glsl fragment generator. DO NOT EDIT.
import * as BABYLON from 'babylonjs';
import { CustomShaderEffect, type ShaderSource, type RenderPrecision, type UniformDescriptor, type ShaderUniforms, type Dynamic } from '../babylonGL/shaderFXBabylon_GL';
export const BloomVertexSource = `// Auto-generated by glsl fragment generator. DO NOT EDIT.
#version 300 es
precision highp float;

in vec3 position;
in vec2 uv;
out vec2 vUV;

void main() {
  gl_Position = vec4(position, 1.0);
  vUV = uv;
}`;
export const BloomFragmentSources = [
  `// Auto-generated by glsl fragment generator. DO NOT EDIT.
#version 300 es
precision highp float;

in vec2 vUV;
out vec4 outColor;
uniform float uniforms_preBlackLevel;
uniform float uniforms_preGamma;
uniform float uniforms_preBrightness;
uniform float uniforms_minBloomRadius;
uniform float uniforms_maxBloomRadius;
uniform float uniforms_bloomThreshold;
uniform float uniforms_bloomSCurve;
uniform float uniforms_bloomFill;
uniform float uniforms_bloomIntensity;
uniform int uniforms_outputMode;
uniform float uniforms_inputImage;
uniform sampler2D src;

struct BloomUniforms {
  float preBlackLevel; // 0.05
  float preGamma; // 1.0
  float preBrightness; // 2.0
  float minBloomRadius; // 0.1
  float maxBloomRadius; // 0.6
  float bloomThreshold; // 0.12
  float bloomSCurve; // 0.35
  float bloomFill; // 0.25
  float bloomIntensity; // 1.1
  int outputMode; // 0
  float inputImage; // 1.0
};

vec3 saturateVec3(vec3 value) {
  return clamp(value, vec3(0.0), vec3(1.0));
}

float saturateScalar(float value) {
  return clamp(value, 0.0, 1.0);
}

vec3 applyPreprocess(vec3 color, BloomUniforms uniforms) {
  vec3 isolated = max(color - vec3(uniforms.preBlackLevel), vec3(0.0));
  isolated = isolated * uniforms.preBrightness;
  float gamma = max(uniforms.preGamma, 1e-6);
  float invGamma = 1.0 / gamma;
  isolated = pow(max(isolated, vec3(0.0)), vec3(invGamma));
  return saturateVec3(isolated);
}

vec3 applyThreshold(vec3 value, float threshold) {
  return max(value - vec3(threshold), vec3(0.0));
}

vec3 applySCurve(vec3 value, float amount) {
  float t = saturateScalar(amount);
  if (t <= 0.0) {
    return value;
  }
  vec3 smoothVal = value * value * (3.0 - 2.0 * value);
  return mix(value, smoothVal, vec3(t));
}

vec2 computeRadiusUv(float radiusNorm, float fill, vec2 texelSize) {
  float safeNorm = saturateScalar(radiusNorm);
  float spread = 1.0 + fill * 6.0;
  float radiusPixels = (1.0 + safeNorm * 6.0) * spread;
  return radiusPixels * texelSize;
}

vec4 pass0(vec2 uv, BloomUniforms uniforms, sampler2D src) {
  vec4 baseColor = texture(src, uv);
  vec3 processed = applyPreprocess(baseColor.rgb, uniforms);
  float alpha = max(max(processed.r, processed.g), processed.b);
  return vec4(processed, alpha);
}

vec4 pass1(vec2 uv, BloomUniforms uniforms, sampler2D src, sampler2D pass0Texture) {
  vec4 baseColor = texture(src, uv);
  vec3 preColor = texture(pass0Texture, uv).rgb;

  ivec2 dims = textureSize(pass0Texture, 0);
  vec2 texelSize = vec2(
    dims.x == 0 ? 0.0 : (1.0 / float(dims.x)),
    dims.y == 0 ? 0.0 : (1.0 / float(dims.y))
  );
  float minRadius = min(uniforms.minBloomRadius, uniforms.maxBloomRadius);
  float maxRadius = max(uniforms.minBloomRadius, uniforms.maxBloomRadius);
  vec3 accum = preColor;
  float totalWeight = 1.0;
  int levelCount = 6;
  for (int level = 0; level < levelCount; level++) {
    float t = float(level + 1) / float(levelCount);
    float radiusNorm = mix(minRadius, maxRadius, t);
    vec2 offsetScale = computeRadiusUv(radiusNorm, uniforms.bloomFill, texelSize);
    float weightBase = 1.0 / (1.0 + radiusNorm * 8.0 + uniforms.bloomFill * 4.0);
    for (int i = 0; i < 8; i++) {
      vec2 direction = vec2(1.0, 0.0);
      if (i == 1) {
        direction = vec2(-1.0, 0.0);
      } else if (i == 2) {
        direction = vec2(0.0, 1.0);
      } else if (i == 3) {
        direction = vec2(0.0, -1.0);
      } else if (i == 4) {
        direction = vec2(0.7071, 0.7071);
      } else if (i == 5) {
        direction = vec2(-0.7071, 0.7071);
      } else if (i == 6) {
        direction = vec2(0.7071, -0.7071);
      } else if (i == 7) {
        direction = vec2(-0.7071, -0.7071);
      }
      vec2 offsetUV = uv + direction * offsetScale;
      vec3 sampleColor = texture(pass0Texture, offsetUV).rgb;
      accum += sampleColor * weightBase;
      totalWeight += weightBase;
    }
  }

  vec3 bloom = accum / max(totalWeight, 1e-5);
  bloom = applyThreshold(bloom, uniforms.bloomThreshold);
  bloom = applySCurve(bloom, uniforms.bloomSCurve);
  bloom = bloom * uniforms.bloomIntensity;
  bloom = saturateVec3(bloom);

  int outputMode = uniforms.outputMode;
  vec3 inputContribution = baseColor.rgb * uniforms.inputImage;

  float bloomAlpha = max(max(bloom.r, bloom.g), bloom.b);
  vec3 finalColor = vec3(0.0);
  float finalAlpha = baseColor.a;

  if (outputMode == 1) {
    finalColor = inputContribution;
    finalAlpha = baseColor.a;
  } else if (outputMode == 2) {
    finalColor = preColor;
    finalAlpha = 1.0;
  } else if (outputMode == 3) {
    finalColor = bloom;
    finalAlpha = 1.0;
  } else if (outputMode == 4) {
    finalColor = bloom;
    finalAlpha = bloomAlpha;
  } else {
    finalColor = saturateVec3(inputContribution + bloom);
    finalAlpha = baseColor.a;
  }

  return vec4(finalColor, finalAlpha);
}

BloomUniforms load_BloomUniforms() {
  return BloomUniforms(
    uniforms_preBlackLevel,
    uniforms_preGamma,
    uniforms_preBrightness,
    uniforms_minBloomRadius,
    uniforms_maxBloomRadius,
    uniforms_bloomThreshold,
    uniforms_bloomSCurve,
    uniforms_bloomFill,
    uniforms_bloomIntensity,
    uniforms_outputMode,
    uniforms_inputImage
  );
}

void main() {
  BloomUniforms uniforms_value = load_BloomUniforms();
  vec2 uv_local = vUV;
  vec4 color = pass0(uv_local, uniforms_value, src);
  outColor = color;
}`, // pass0
  `// Auto-generated by glsl fragment generator. DO NOT EDIT.
#version 300 es
precision highp float;

in vec2 vUV;
out vec4 outColor;
uniform float uniforms_preBlackLevel;
uniform float uniforms_preGamma;
uniform float uniforms_preBrightness;
uniform float uniforms_minBloomRadius;
uniform float uniforms_maxBloomRadius;
uniform float uniforms_bloomThreshold;
uniform float uniforms_bloomSCurve;
uniform float uniforms_bloomFill;
uniform float uniforms_bloomIntensity;
uniform int uniforms_outputMode;
uniform float uniforms_inputImage;
uniform sampler2D src;
uniform sampler2D pass0Texture;

struct BloomUniforms {
  float preBlackLevel; // 0.05
  float preGamma; // 1.0
  float preBrightness; // 2.0
  float minBloomRadius; // 0.1
  float maxBloomRadius; // 0.6
  float bloomThreshold; // 0.12
  float bloomSCurve; // 0.35
  float bloomFill; // 0.25
  float bloomIntensity; // 1.1
  int outputMode; // 0
  float inputImage; // 1.0
};

vec3 saturateVec3(vec3 value) {
  return clamp(value, vec3(0.0), vec3(1.0));
}

float saturateScalar(float value) {
  return clamp(value, 0.0, 1.0);
}

vec3 applyPreprocess(vec3 color, BloomUniforms uniforms) {
  vec3 isolated = max(color - vec3(uniforms.preBlackLevel), vec3(0.0));
  isolated = isolated * uniforms.preBrightness;
  float gamma = max(uniforms.preGamma, 1e-6);
  float invGamma = 1.0 / gamma;
  isolated = pow(max(isolated, vec3(0.0)), vec3(invGamma));
  return saturateVec3(isolated);
}

vec3 applyThreshold(vec3 value, float threshold) {
  return max(value - vec3(threshold), vec3(0.0));
}

vec3 applySCurve(vec3 value, float amount) {
  float t = saturateScalar(amount);
  if (t <= 0.0) {
    return value;
  }
  vec3 smoothVal = value * value * (3.0 - 2.0 * value);
  return mix(value, smoothVal, vec3(t));
}

vec2 computeRadiusUv(float radiusNorm, float fill, vec2 texelSize) {
  float safeNorm = saturateScalar(radiusNorm);
  float spread = 1.0 + fill * 6.0;
  float radiusPixels = (1.0 + safeNorm * 6.0) * spread;
  return radiusPixels * texelSize;
}

vec4 pass0(vec2 uv, BloomUniforms uniforms, sampler2D src) {
  vec4 baseColor = texture(src, uv);
  vec3 processed = applyPreprocess(baseColor.rgb, uniforms);
  float alpha = max(max(processed.r, processed.g), processed.b);
  return vec4(processed, alpha);
}

vec4 pass1(vec2 uv, BloomUniforms uniforms, sampler2D src, sampler2D pass0Texture) {
  vec4 baseColor = texture(src, uv);
  vec3 preColor = texture(pass0Texture, uv).rgb;

  ivec2 dims = textureSize(pass0Texture, 0);
  vec2 texelSize = vec2(
    dims.x == 0 ? 0.0 : (1.0 / float(dims.x)),
    dims.y == 0 ? 0.0 : (1.0 / float(dims.y))
  );
  float minRadius = min(uniforms.minBloomRadius, uniforms.maxBloomRadius);
  float maxRadius = max(uniforms.minBloomRadius, uniforms.maxBloomRadius);
  vec3 accum = preColor;
  float totalWeight = 1.0;
  int levelCount = 6;
  for (int level = 0; level < levelCount; level++) {
    float t = float(level + 1) / float(levelCount);
    float radiusNorm = mix(minRadius, maxRadius, t);
    vec2 offsetScale = computeRadiusUv(radiusNorm, uniforms.bloomFill, texelSize);
    float weightBase = 1.0 / (1.0 + radiusNorm * 8.0 + uniforms.bloomFill * 4.0);
    for (int i = 0; i < 8; i++) {
      vec2 direction = vec2(1.0, 0.0);
      if (i == 1) {
        direction = vec2(-1.0, 0.0);
      } else if (i == 2) {
        direction = vec2(0.0, 1.0);
      } else if (i == 3) {
        direction = vec2(0.0, -1.0);
      } else if (i == 4) {
        direction = vec2(0.7071, 0.7071);
      } else if (i == 5) {
        direction = vec2(-0.7071, 0.7071);
      } else if (i == 6) {
        direction = vec2(0.7071, -0.7071);
      } else if (i == 7) {
        direction = vec2(-0.7071, -0.7071);
      }
      vec2 offsetUV = uv + direction * offsetScale;
      vec3 sampleColor = texture(pass0Texture, offsetUV).rgb;
      accum += sampleColor * weightBase;
      totalWeight += weightBase;
    }
  }

  vec3 bloom = accum / max(totalWeight, 1e-5);
  bloom = applyThreshold(bloom, uniforms.bloomThreshold);
  bloom = applySCurve(bloom, uniforms.bloomSCurve);
  bloom = bloom * uniforms.bloomIntensity;
  bloom = saturateVec3(bloom);

  int outputMode = uniforms.outputMode;
  vec3 inputContribution = baseColor.rgb * uniforms.inputImage;

  float bloomAlpha = max(max(bloom.r, bloom.g), bloom.b);
  vec3 finalColor = vec3(0.0);
  float finalAlpha = baseColor.a;

  if (outputMode == 1) {
    finalColor = inputContribution;
    finalAlpha = baseColor.a;
  } else if (outputMode == 2) {
    finalColor = preColor;
    finalAlpha = 1.0;
  } else if (outputMode == 3) {
    finalColor = bloom;
    finalAlpha = 1.0;
  } else if (outputMode == 4) {
    finalColor = bloom;
    finalAlpha = bloomAlpha;
  } else {
    finalColor = saturateVec3(inputContribution + bloom);
    finalAlpha = baseColor.a;
  }

  return vec4(finalColor, finalAlpha);
}

BloomUniforms load_BloomUniforms() {
  return BloomUniforms(
    uniforms_preBlackLevel,
    uniforms_preGamma,
    uniforms_preBrightness,
    uniforms_minBloomRadius,
    uniforms_maxBloomRadius,
    uniforms_bloomThreshold,
    uniforms_bloomSCurve,
    uniforms_bloomFill,
    uniforms_bloomIntensity,
    uniforms_outputMode,
    uniforms_inputImage
  );
}

void main() {
  BloomUniforms uniforms_value = load_BloomUniforms();
  vec2 uv_local = vUV;
  vec4 color = pass1(uv_local, uniforms_value, src, pass0Texture);
  outColor = color;
}`, // pass1
] as const;
export const BloomPassCount = 2 as const;
export const BloomPrimaryTextureName = 'src' as const;

export const BloomPassTextureSources = [
  [
    { binding: 'src', source: { kind: 'input', key: 'src' } },
  ],
  [
    { binding: 'src', source: { kind: 'input', key: 'src' } },
    { binding: 'pass0Texture', source: { kind: 'pass', passIndex: 0 } },
  ],
] as const;

export const BloomUniformMeta: UniformDescriptor[] = [
  {
    name: 'preBlackLevel',
    kind: 'f32',
    bindingName: 'uniforms_preBlackLevel',
    default: 0.05,
  },
  {
    name: 'preGamma',
    kind: 'f32',
    bindingName: 'uniforms_preGamma',
    default: 1.0,
  },
  {
    name: 'preBrightness',
    kind: 'f32',
    bindingName: 'uniforms_preBrightness',
    default: 2.0,
  },
  {
    name: 'minBloomRadius',
    kind: 'f32',
    bindingName: 'uniforms_minBloomRadius',
    default: 0.1,
  },
  {
    name: 'maxBloomRadius',
    kind: 'f32',
    bindingName: 'uniforms_maxBloomRadius',
    default: 0.6,
  },
  {
    name: 'bloomThreshold',
    kind: 'f32',
    bindingName: 'uniforms_bloomThreshold',
    default: 0.12,
  },
  {
    name: 'bloomSCurve',
    kind: 'f32',
    bindingName: 'uniforms_bloomSCurve',
    default: 0.35,
  },
  {
    name: 'bloomFill',
    kind: 'f32',
    bindingName: 'uniforms_bloomFill',
    default: 0.25,
  },
  {
    name: 'bloomIntensity',
    kind: 'f32',
    bindingName: 'uniforms_bloomIntensity',
    default: 1.1,
  },
  {
    name: 'outputMode',
    kind: 'i32',
    bindingName: 'uniforms_outputMode',
    default: 0,
  },
  {
    name: 'inputImage',
    kind: 'f32',
    bindingName: 'uniforms_inputImage',
    default: 1.0,
  },
];

export interface BloomUniforms {
  preBlackLevel: number;
  preGamma: number;
  preBrightness: number;
  minBloomRadius: number;
  maxBloomRadius: number;
  bloomThreshold: number;
  bloomSCurve: number;
  bloomFill: number;
  bloomIntensity: number;
  outputMode: number;
  inputImage: number;
}

export function setBloomUniforms(material: BABYLON.ShaderMaterial, uniforms: Partial<BloomUniforms>): void {
  if (!uniforms) {
    return;
  }
  if (uniforms.preBlackLevel !== undefined) {
    material.setFloat('uniforms_preBlackLevel', uniforms.preBlackLevel);
  }
  if (uniforms.preGamma !== undefined) {
    material.setFloat('uniforms_preGamma', uniforms.preGamma);
  }
  if (uniforms.preBrightness !== undefined) {
    material.setFloat('uniforms_preBrightness', uniforms.preBrightness);
  }
  if (uniforms.minBloomRadius !== undefined) {
    material.setFloat('uniforms_minBloomRadius', uniforms.minBloomRadius);
  }
  if (uniforms.maxBloomRadius !== undefined) {
    material.setFloat('uniforms_maxBloomRadius', uniforms.maxBloomRadius);
  }
  if (uniforms.bloomThreshold !== undefined) {
    material.setFloat('uniforms_bloomThreshold', uniforms.bloomThreshold);
  }
  if (uniforms.bloomSCurve !== undefined) {
    material.setFloat('uniforms_bloomSCurve', uniforms.bloomSCurve);
  }
  if (uniforms.bloomFill !== undefined) {
    material.setFloat('uniforms_bloomFill', uniforms.bloomFill);
  }
  if (uniforms.bloomIntensity !== undefined) {
    material.setFloat('uniforms_bloomIntensity', uniforms.bloomIntensity);
  }
  if (uniforms.outputMode !== undefined) {
    material.setInt('uniforms_outputMode', uniforms.outputMode);
  }
  if (uniforms.inputImage !== undefined) {
    material.setFloat('uniforms_inputImage', uniforms.inputImage);
  }
}

export type BloomTextureName = 'src' | 'pass0Texture';
export interface BloomInputs {
  src: ShaderSource;
}

export interface BloomMaterialHandles {
  material: BABYLON.ShaderMaterial;
  setTexture(name: BloomTextureName, texture: BABYLON.BaseTexture): void;
  setTextureSampler(name: BloomTextureName, sampler: BABYLON.TextureSampler): void;
  setUniforms(uniforms: Partial<BloomUniforms>): void;
}

export interface BloomMaterialOptions {
  name?: string;
  passIndex?: number;
}

export function createBloomMaterial(scene: BABYLON.Scene, options: BloomMaterialOptions = {}): BloomMaterialHandles {
  const passIndex = options.passIndex ?? 0;
  if (passIndex < 0 || passIndex >= 2) {
    throw new Error('Invalid passIndex ' + passIndex + ' for Bloom. Expected 0 <= passIndex < 2.');
  }
  const baseName = options.name ?? 'BloomMaterial';
  const shaderName = `${baseName}_pass${passIndex}`;
  const vertexShaderName = `${shaderName}VertexShader`;
  const fragmentShaderName = `${shaderName}FragmentShader`;

  BABYLON.ShaderStore.ShadersStore[vertexShaderName] = BloomVertexSource;
  BABYLON.ShaderStore.ShadersStore[fragmentShaderName] = BloomFragmentSources[passIndex];

  const material = new BABYLON.ShaderMaterial(shaderName, scene, {
    vertex: shaderName,
    fragment: shaderName,
  }, {
    attributes: ['position', 'uv'],
    uniforms: ['uniforms_preBlackLevel', 'uniforms_preGamma', 'uniforms_preBrightness', 'uniforms_minBloomRadius', 'uniforms_maxBloomRadius', 'uniforms_bloomThreshold', 'uniforms_bloomSCurve', 'uniforms_bloomFill', 'uniforms_bloomIntensity', 'uniforms_outputMode', 'uniforms_inputImage'],
    samplers: ['src', 'pass0Texture'],
    shaderLanguage: BABYLON.ShaderLanguage.GLSL,
  });

  const defaultSampler = new BABYLON.TextureSampler();
  defaultSampler.setParameters(
    BABYLON.Texture.CLAMP_ADDRESSMODE,
    BABYLON.Texture.CLAMP_ADDRESSMODE,
    BABYLON.Texture.CLAMP_ADDRESSMODE,
    undefined,
    BABYLON.Texture.BILINEAR_SAMPLINGMODE,
  );
  const samplerState: Record<string, BABYLON.TextureSampler> = {};
  const textureState: Partial<Record<BloomTextureName, BABYLON.BaseTexture | null>> = {};
  const applySamplerToTexture = (texture: BABYLON.BaseTexture | null, sampler: BABYLON.TextureSampler) => {
    if (!texture) return;
    const wrapU = sampler.wrapU;
    if (wrapU !== null && wrapU !== undefined) {
      texture.wrapU = wrapU;
    }
    const wrapV = sampler.wrapV;
    if (wrapV !== null && wrapV !== undefined) {
      texture.wrapV = wrapV;
    }
    const wrapR = sampler.wrapR;
    if (wrapR !== null && wrapR !== undefined) {
      texture.wrapR = wrapR;
    }
    texture.updateSamplingMode(sampler.samplingMode);
  };

  const handles: BloomMaterialHandles = {
    material,
    setTexture: (name, texture) => {
      material.setTexture(name, texture);
      textureState[name] = texture;
      const sampler = samplerState[name] ?? defaultSampler;
      applySamplerToTexture(texture, sampler);
    },
    setTextureSampler: (name, sampler) => {
      samplerState[name] = sampler;
      const texture = textureState[name] ?? null;
      applySamplerToTexture(texture, sampler);
    },
    setUniforms: (values) => setBloomUniforms(material, values),
  };

  return handles;
}

export class BloomEffect extends CustomShaderEffect<BloomUniforms, BloomInputs> {
  effectName = 'Bloom'

  constructor(engine: BABYLON.Engine, inputs: BloomInputs, width = 1280, height = 720, sampleMode: 'nearest' | 'linear' = 'linear', precision: RenderPrecision = 'half_float') {
    super(engine, inputs, {
      factory: (sceneRef, options) => createBloomMaterial(sceneRef, options),
      textureInputKeys: ['src'],
      textureBindingKeys: ['src'],
      passTextureSources: BloomPassTextureSources,
      passCount: 2,
      primaryTextureKey: 'src',
      width,
      height,
      materialName: 'BloomMaterial',
      sampleMode,
      precision,
      uniformMeta: BloomUniformMeta,
    });
    this.setUniforms({
      preBlackLevel: 0.05,
      preGamma: 1.0,
      preBrightness: 2.0,
      minBloomRadius: 0.1,
      maxBloomRadius: 0.6,
      bloomThreshold: 0.12,
      bloomSCurve: 0.35,
      bloomFill: 0.25,
      bloomIntensity: 1.1,
      outputMode: 0,
      inputImage: 1.0,
    });
  }

  override setSrcs(inputs: Partial<BloomInputs>): void {
    super.setSrcs(inputs);
  }

  override setUniforms(uniforms: { preBlackLevel?: Dynamic<number>; preGamma?: Dynamic<number>; preBrightness?: Dynamic<number>; minBloomRadius?: Dynamic<number>; maxBloomRadius?: Dynamic<number>; bloomThreshold?: Dynamic<number>; bloomSCurve?: Dynamic<number>; bloomFill?: Dynamic<number>; bloomIntensity?: Dynamic<number>; outputMode?: Dynamic<number>; inputImage?: Dynamic<number> }): void {
    const record: ShaderUniforms = {};
    if (uniforms.preBlackLevel !== undefined) {
      record['preBlackLevel'] = uniforms.preBlackLevel;
    }
    if (uniforms.preGamma !== undefined) {
      record['preGamma'] = uniforms.preGamma;
    }
    if (uniforms.preBrightness !== undefined) {
      record['preBrightness'] = uniforms.preBrightness;
    }
    if (uniforms.minBloomRadius !== undefined) {
      record['minBloomRadius'] = uniforms.minBloomRadius;
    }
    if (uniforms.maxBloomRadius !== undefined) {
      record['maxBloomRadius'] = uniforms.maxBloomRadius;
    }
    if (uniforms.bloomThreshold !== undefined) {
      record['bloomThreshold'] = uniforms.bloomThreshold;
    }
    if (uniforms.bloomSCurve !== undefined) {
      record['bloomSCurve'] = uniforms.bloomSCurve;
    }
    if (uniforms.bloomFill !== undefined) {
      record['bloomFill'] = uniforms.bloomFill;
    }
    if (uniforms.bloomIntensity !== undefined) {
      record['bloomIntensity'] = uniforms.bloomIntensity;
    }
    if (uniforms.outputMode !== undefined) {
      record['outputMode'] = uniforms.outputMode;
    }
    if (uniforms.inputImage !== undefined) {
      record['inputImage'] = uniforms.inputImage;
    }
    super.setUniforms(record);
  }
}