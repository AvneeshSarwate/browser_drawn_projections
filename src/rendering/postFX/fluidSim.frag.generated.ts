// Auto-generated by wgsl fragment generator. DO NOT EDIT.
import * as BABYLON from 'babylonjs';
import { CustomShaderEffect, type ShaderSource, type RenderPrecision, type ShaderUniforms, type Dynamic } from '../shaderFXBabylon';
export const FluidSimVertexSource = `// Auto-generated by wgsl fragment generator. DO NOT EDIT.
attribute position: vec3<f32>;
attribute uv: vec2<f32>;
varying vUV: vec2<f32>;

#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs) -> FragmentInputs {
#define CUSTOM_VERTEX_MAIN_BEGIN
  vertexOutputs.position = vec4<f32>(vertexInputs.position, 1.0);
  vertexOutputs.vUV = vertexInputs.uv;
#define CUSTOM_VERTEX_MAIN_END
}

`;
export const FluidSimFragmentSources = [
  `// Auto-generated by wgsl fragment generator. DO NOT EDIT.
varying vUV: vec2<f32>;
uniform uniforms_timeStep: f32;
uniform uniforms_velocityDissipation: f32;
uniform uniforms_densityDissipation: f32;
uniform uniforms_swirlStrength: f32;
uniform uniforms_turbulence: f32;
uniform uniforms_forceRadius: f32;
uniform uniforms_forceStrength: f32;
uniform uniforms_attraction: f32;
uniform uniforms_forcePosition: vec2f;
var state: texture_2d<f32>;
var stateSampler: sampler;
var forces: texture_2d<f32>;
var forcesSampler: sampler;

// Source fragment function
struct FluidSimUniforms {
  timeStep: f32, // 0.016
  velocityDissipation: f32, // 0.985
  densityDissipation: f32, // 0.995
  swirlStrength: f32, // 2.5
  turbulence: f32, // 0.2
  forceRadius: f32, // 0.12
  forceStrength: f32, // 18.0
  attraction: f32, // 0.35
  forcePosition: vec2f, // [0.5, 0.5]
};

fn safeSample(textureRef: texture_2d<f32>, samplerRef: sampler, uv: vec2f) -> vec4f {
  let clampedUv = clamp(uv, vec2f(0.0), vec2f(1.0));
  return textureSample(textureRef, samplerRef, clampedUv);
}

fn texelSize(textureRef: texture_2d<f32>) -> vec2f {
  let dims = textureDimensions(textureRef);
  return vec2f(
    select(1.0 / f32(dims.x), 0.0, dims.x == 0u),
    select(1.0 / f32(dims.y), 0.0, dims.y == 0u),
  );
}

fn advectUv(uv: vec2f, velocity: vec2f, delta: f32) -> vec2f {
  return clamp(uv - velocity * delta, vec2f(0.0), vec2f(1.0));
}

fn computeCurl(
  textureRef: texture_2d<f32>,
  samplerRef: sampler,
  uv: vec2f,
  texel: vec2f,
) -> f32 {
  let right = safeSample(textureRef, samplerRef, uv + vec2f(texel.x, 0.0)).xy;
  let left = safeSample(textureRef, samplerRef, uv - vec2f(texel.x, 0.0)).xy;
  let up = safeSample(textureRef, samplerRef, uv + vec2f(0.0, texel.y)).xy;
  let down = safeSample(textureRef, samplerRef, uv - vec2f(0.0, texel.y)).xy;
  let dY = right.y - left.y;
  let dX = up.x - down.x;
  return dY - dX;
}

fn applyForceField(
  uv: vec2f,
  uniforms: FluidSimUniforms,
  baseVelocity: vec2f,
  baseDensity: f32,
  forces: vec4f,
  curl: f32,
) -> vec4f {
  var velocity = baseVelocity;
  var density = baseDensity;

  let toCenter = uv - uniforms.forcePosition;
  let radius = max(uniforms.forceRadius, 1e-3);
  let dist = length(toCenter);
  let normalized = toCenter / max(dist, 1e-4);
  let radialFalloff = exp(-pow(dist / radius, 2.0));
  let swirlDir = vec2f(-normalized.y, normalized.x);
  velocity = velocity + swirlDir * uniforms.swirlStrength * radialFalloff;
  velocity = velocity - normalized * uniforms.attraction * radialFalloff;

  let turbulenceForce = vec2f(-curl, curl) * uniforms.turbulence;
  velocity = velocity + turbulenceForce;

  let a = max(forces.a, 1e-4);
  let dir01 = forces.xy / a;
  let encodedForce = dir01 * 2.0 - vec2f(1.0);
  velocity = velocity + encodedForce * uniforms.forceStrength * a;
  density = density + (forces.z / a) * (uniforms.forceStrength * 0.1) * a;

  return vec4f(velocity, density, 1.0);
}

// PASS 0: ADVECTION + FORCES + DISSIPATION
// This pass performs semi-Lagrangian advection, applies external forces,
// and computes curl for vorticity effects.
// 
// ARCHITECTURE ISSUE: This combines what should be 3-4 separate stages in Pavel's implementation:
// 1. Advection (backtracing velocity field)
// 2. Force application (adding external inputs)
// 3. Curl computation (for vorticity confinement)
// 4. Dissipation
//
// State encoding: xy = velocity, z = density, w = curl
fn pass0(
  uv: vec2f,
  uniforms: FluidSimUniforms,
  state: texture_2d<f32>,
  stateSampler: sampler,
  forces: texture_2d<f32>,
  forcesSampler: sampler,
) -> vec4f {
  let currentState = safeSample(state, stateSampler, uv);
  let texel = texelSize(state);
  
  // Semi-Lagrangian advection: trace particle backward in time
  let advectedUv = advectUv(uv, currentState.xy, uniforms.timeStep);
  let advectedState = safeSample(state, stateSampler, advectedUv);
  
  // Compute curl (rotation) of velocity field
  let curl = computeCurl(state, stateSampler, uv, texel);
  
  // Sample force texture (Y-flipped to match DOM coordinates)
  let forceSample = safeSample(forces, forcesSampler, vec2f(uv.x, 1.0 - uv.y));

  // Blend advected with current for stability (acts as implicit diffusion)
  let blendedVelocity = mix(advectedState.xy, currentState.xy, 0.25);
  let blendedDensity = mix(advectedState.z, currentState.z, 0.35);

  // Apply external forces and curl-based effects
  let forced = applyForceField(uv, uniforms, blendedVelocity, blendedDensity, forceSample, curl);

  // Apply dissipation (energy loss)
  var velocity = forced.xy * uniforms.velocityDissipation;
  var density = forced.z * uniforms.densityDissipation;

  return vec4f(velocity, density, curl);
}

// PASS 1: SPATIAL BLUR (PSEUDO-DIFFUSION)
// This pass performs a 3×3 weighted box blur on velocity and density,
// then computes a pseudo-divergence metric.
//
// CRITICAL ARCHITECTURE FLAW: This is NOT equivalent to Pavel's pressure projection!
// Pavel's implementation:
// 1. Computes true divergence: ∇·v = (vR.x - vL.x + vT.y - vB.y) * 0.5
// 2. Solves Poisson equation ∇²p = ∇·v via Jacobi iterations (20+ iterations)
// 3. Projects velocity to divergence-free: v' = v - ∇p
//
// This pass instead:
// - Uses blur as implicit diffusion
// - Computes length(current - blurred) as "divergence" (not physically meaningful)
// - Cannot enforce incompressibility without proper pressure solve
//
// Result: Fluid appears compressible, doesn't match Pavel's behavior
fn pass1(
  uv: vec2f,
  uniforms: FluidSimUniforms,
  state: texture_2d<f32>,
  stateSampler: sampler,
  forces: texture_2d<f32>,
  forcesSampler: sampler,
  pass0Texture: texture_2d<f32>,
  pass0Sampler: sampler,
) -> vec4f {
  let texel = texelSize(pass0Texture);
  
  // 3×3 weighted box blur (center weight = 2, neighbors = 1)
  var accumVelocity = vec2f(0.0);
  var accumDensity = 0.0;
  var weightSum = 0.0;
  for (var x = -1; x <= 1; x = x + 1) {
    for (var y = -1; y <= 1; y = y + 1) {
      let offset = vec2f(f32(x), f32(y));
      let weight = select(2.0, 1.0, (x == 0 && y == 0));
      weightSum = weightSum + weight;
      let neighborUv = uv + offset * texel;
      let neighbor = safeSample(pass0Texture, pass0Sampler, neighborUv);
      accumVelocity = accumVelocity + neighbor.xy * weight;
      accumDensity = accumDensity + neighbor.z * weight;
    }
  }

  let velocity = accumVelocity / max(weightSum, 1e-4);
  let density = accumDensity / max(weightSum, 1e-4);

  let current = safeSample(pass0Texture, pass0Sampler, uv);
  
  // Pseudo-divergence: magnitude of difference between current and blurred velocity
  // NOTE: This is NOT the true divergence operator!
  let divergence = length(current.xy - velocity);

  return vec4f(velocity, density, divergence);
}

// PASS 2: BLEND AND OUTPUT
// This pass blends the advected (pass0) and blurred (pass1) results,
// and computes an alpha channel for visualization.
//
// Purpose:
// - Combines advected (sharp, but potentially unstable) with blurred (stable, but diffusive)
// - Creates alpha from density + pseudo-divergence + curl magnitude
// - Outputs final state to feed back into next frame
//
// State encoding: xy = velocity, z = density, w = alpha (for visualization)
fn pass2(
  uv: vec2f,
  uniforms: FluidSimUniforms,
  state: texture_2d<f32>,
  stateSampler: sampler,
  forces: texture_2d<f32>,
  forcesSampler: sampler,
  pass0Texture: texture_2d<f32>,
  pass0Sampler: sampler,
  pass1Texture: texture_2d<f32>,
  pass1Sampler: sampler,
) -> vec4f {
  let advected = safeSample(pass0Texture, pass0Sampler, uv);
  let relaxed = safeSample(pass1Texture, pass1Sampler, uv);
  
  // Blend advected (sharp) with relaxed (blurred) for stability
  var velocity = mix(advected.xy, relaxed.xy, 0.55);
  var density = mix(advected.z, relaxed.z, 0.4);
  
  let divergence = relaxed.w;
  let curl = advected.w;
  
  // Compute alpha for visualization (higher where there's more activity)
  let alpha = clamp(density + divergence * 0.1 + abs(curl) * 0.05, 0.0, 1.0);
  
  return vec4f(velocity, density, alpha);
}

fn load_FluidSimUniforms() -> FluidSimUniforms {
  return FluidSimUniforms(
  uniforms.uniforms_timeStep,
  uniforms.uniforms_velocityDissipation,
  uniforms.uniforms_densityDissipation,
  uniforms.uniforms_swirlStrength,
  uniforms.uniforms_turbulence,
  uniforms.uniforms_forceRadius,
  uniforms.uniforms_forceStrength,
  uniforms.uniforms_attraction,
  uniforms.uniforms_forcePosition
  );
}

#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs) -> FragmentOutputs {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
  let uniforms_value = load_FluidSimUniforms();
  let uv_local = fragmentInputs.vUV;
  let color = pass0(uv_local, uniforms_value, state, stateSampler, forces, forcesSampler);
  fragmentOutputs.color = color;
#define CUSTOM_FRAGMENT_MAIN_END
}

`, // pass0
  `// Auto-generated by wgsl fragment generator. DO NOT EDIT.
varying vUV: vec2<f32>;
uniform uniforms_timeStep: f32;
uniform uniforms_velocityDissipation: f32;
uniform uniforms_densityDissipation: f32;
uniform uniforms_swirlStrength: f32;
uniform uniforms_turbulence: f32;
uniform uniforms_forceRadius: f32;
uniform uniforms_forceStrength: f32;
uniform uniforms_attraction: f32;
uniform uniforms_forcePosition: vec2f;
var state: texture_2d<f32>;
var stateSampler: sampler;
var forces: texture_2d<f32>;
var forcesSampler: sampler;
var pass0Texture: texture_2d<f32>;
var pass0Sampler: sampler;

// Source fragment function
struct FluidSimUniforms {
  timeStep: f32, // 0.016
  velocityDissipation: f32, // 0.985
  densityDissipation: f32, // 0.995
  swirlStrength: f32, // 2.5
  turbulence: f32, // 0.2
  forceRadius: f32, // 0.12
  forceStrength: f32, // 18.0
  attraction: f32, // 0.35
  forcePosition: vec2f, // [0.5, 0.5]
};

fn safeSample(textureRef: texture_2d<f32>, samplerRef: sampler, uv: vec2f) -> vec4f {
  let clampedUv = clamp(uv, vec2f(0.0), vec2f(1.0));
  return textureSample(textureRef, samplerRef, clampedUv);
}

fn texelSize(textureRef: texture_2d<f32>) -> vec2f {
  let dims = textureDimensions(textureRef);
  return vec2f(
    select(1.0 / f32(dims.x), 0.0, dims.x == 0u),
    select(1.0 / f32(dims.y), 0.0, dims.y == 0u),
  );
}

fn advectUv(uv: vec2f, velocity: vec2f, delta: f32) -> vec2f {
  return clamp(uv - velocity * delta, vec2f(0.0), vec2f(1.0));
}

fn computeCurl(
  textureRef: texture_2d<f32>,
  samplerRef: sampler,
  uv: vec2f,
  texel: vec2f,
) -> f32 {
  let right = safeSample(textureRef, samplerRef, uv + vec2f(texel.x, 0.0)).xy;
  let left = safeSample(textureRef, samplerRef, uv - vec2f(texel.x, 0.0)).xy;
  let up = safeSample(textureRef, samplerRef, uv + vec2f(0.0, texel.y)).xy;
  let down = safeSample(textureRef, samplerRef, uv - vec2f(0.0, texel.y)).xy;
  let dY = right.y - left.y;
  let dX = up.x - down.x;
  return dY - dX;
}

fn applyForceField(
  uv: vec2f,
  uniforms: FluidSimUniforms,
  baseVelocity: vec2f,
  baseDensity: f32,
  forces: vec4f,
  curl: f32,
) -> vec4f {
  var velocity = baseVelocity;
  var density = baseDensity;

  let toCenter = uv - uniforms.forcePosition;
  let radius = max(uniforms.forceRadius, 1e-3);
  let dist = length(toCenter);
  let normalized = toCenter / max(dist, 1e-4);
  let radialFalloff = exp(-pow(dist / radius, 2.0));
  let swirlDir = vec2f(-normalized.y, normalized.x);
  velocity = velocity + swirlDir * uniforms.swirlStrength * radialFalloff;
  velocity = velocity - normalized * uniforms.attraction * radialFalloff;

  let turbulenceForce = vec2f(-curl, curl) * uniforms.turbulence;
  velocity = velocity + turbulenceForce;

  let a = max(forces.a, 1e-4);
  let dir01 = forces.xy / a;
  let encodedForce = dir01 * 2.0 - vec2f(1.0);
  velocity = velocity + encodedForce * uniforms.forceStrength * a;
  density = density + (forces.z / a) * (uniforms.forceStrength * 0.1) * a;

  return vec4f(velocity, density, 1.0);
}

// PASS 0: ADVECTION + FORCES + DISSIPATION
// This pass performs semi-Lagrangian advection, applies external forces,
// and computes curl for vorticity effects.
// 
// ARCHITECTURE ISSUE: This combines what should be 3-4 separate stages in Pavel's implementation:
// 1. Advection (backtracing velocity field)
// 2. Force application (adding external inputs)
// 3. Curl computation (for vorticity confinement)
// 4. Dissipation
//
// State encoding: xy = velocity, z = density, w = curl
fn pass0(
  uv: vec2f,
  uniforms: FluidSimUniforms,
  state: texture_2d<f32>,
  stateSampler: sampler,
  forces: texture_2d<f32>,
  forcesSampler: sampler,
) -> vec4f {
  let currentState = safeSample(state, stateSampler, uv);
  let texel = texelSize(state);
  
  // Semi-Lagrangian advection: trace particle backward in time
  let advectedUv = advectUv(uv, currentState.xy, uniforms.timeStep);
  let advectedState = safeSample(state, stateSampler, advectedUv);
  
  // Compute curl (rotation) of velocity field
  let curl = computeCurl(state, stateSampler, uv, texel);
  
  // Sample force texture (Y-flipped to match DOM coordinates)
  let forceSample = safeSample(forces, forcesSampler, vec2f(uv.x, 1.0 - uv.y));

  // Blend advected with current for stability (acts as implicit diffusion)
  let blendedVelocity = mix(advectedState.xy, currentState.xy, 0.25);
  let blendedDensity = mix(advectedState.z, currentState.z, 0.35);

  // Apply external forces and curl-based effects
  let forced = applyForceField(uv, uniforms, blendedVelocity, blendedDensity, forceSample, curl);

  // Apply dissipation (energy loss)
  var velocity = forced.xy * uniforms.velocityDissipation;
  var density = forced.z * uniforms.densityDissipation;

  return vec4f(velocity, density, curl);
}

// PASS 1: SPATIAL BLUR (PSEUDO-DIFFUSION)
// This pass performs a 3×3 weighted box blur on velocity and density,
// then computes a pseudo-divergence metric.
//
// CRITICAL ARCHITECTURE FLAW: This is NOT equivalent to Pavel's pressure projection!
// Pavel's implementation:
// 1. Computes true divergence: ∇·v = (vR.x - vL.x + vT.y - vB.y) * 0.5
// 2. Solves Poisson equation ∇²p = ∇·v via Jacobi iterations (20+ iterations)
// 3. Projects velocity to divergence-free: v' = v - ∇p
//
// This pass instead:
// - Uses blur as implicit diffusion
// - Computes length(current - blurred) as "divergence" (not physically meaningful)
// - Cannot enforce incompressibility without proper pressure solve
//
// Result: Fluid appears compressible, doesn't match Pavel's behavior
fn pass1(
  uv: vec2f,
  uniforms: FluidSimUniforms,
  state: texture_2d<f32>,
  stateSampler: sampler,
  forces: texture_2d<f32>,
  forcesSampler: sampler,
  pass0Texture: texture_2d<f32>,
  pass0Sampler: sampler,
) -> vec4f {
  let texel = texelSize(pass0Texture);
  
  // 3×3 weighted box blur (center weight = 2, neighbors = 1)
  var accumVelocity = vec2f(0.0);
  var accumDensity = 0.0;
  var weightSum = 0.0;
  for (var x = -1; x <= 1; x = x + 1) {
    for (var y = -1; y <= 1; y = y + 1) {
      let offset = vec2f(f32(x), f32(y));
      let weight = select(2.0, 1.0, (x == 0 && y == 0));
      weightSum = weightSum + weight;
      let neighborUv = uv + offset * texel;
      let neighbor = safeSample(pass0Texture, pass0Sampler, neighborUv);
      accumVelocity = accumVelocity + neighbor.xy * weight;
      accumDensity = accumDensity + neighbor.z * weight;
    }
  }

  let velocity = accumVelocity / max(weightSum, 1e-4);
  let density = accumDensity / max(weightSum, 1e-4);

  let current = safeSample(pass0Texture, pass0Sampler, uv);
  
  // Pseudo-divergence: magnitude of difference between current and blurred velocity
  // NOTE: This is NOT the true divergence operator!
  let divergence = length(current.xy - velocity);

  return vec4f(velocity, density, divergence);
}

// PASS 2: BLEND AND OUTPUT
// This pass blends the advected (pass0) and blurred (pass1) results,
// and computes an alpha channel for visualization.
//
// Purpose:
// - Combines advected (sharp, but potentially unstable) with blurred (stable, but diffusive)
// - Creates alpha from density + pseudo-divergence + curl magnitude
// - Outputs final state to feed back into next frame
//
// State encoding: xy = velocity, z = density, w = alpha (for visualization)
fn pass2(
  uv: vec2f,
  uniforms: FluidSimUniforms,
  state: texture_2d<f32>,
  stateSampler: sampler,
  forces: texture_2d<f32>,
  forcesSampler: sampler,
  pass0Texture: texture_2d<f32>,
  pass0Sampler: sampler,
  pass1Texture: texture_2d<f32>,
  pass1Sampler: sampler,
) -> vec4f {
  let advected = safeSample(pass0Texture, pass0Sampler, uv);
  let relaxed = safeSample(pass1Texture, pass1Sampler, uv);
  
  // Blend advected (sharp) with relaxed (blurred) for stability
  var velocity = mix(advected.xy, relaxed.xy, 0.55);
  var density = mix(advected.z, relaxed.z, 0.4);
  
  let divergence = relaxed.w;
  let curl = advected.w;
  
  // Compute alpha for visualization (higher where there's more activity)
  let alpha = clamp(density + divergence * 0.1 + abs(curl) * 0.05, 0.0, 1.0);
  
  return vec4f(velocity, density, alpha);
}

fn load_FluidSimUniforms() -> FluidSimUniforms {
  return FluidSimUniforms(
  uniforms.uniforms_timeStep,
  uniforms.uniforms_velocityDissipation,
  uniforms.uniforms_densityDissipation,
  uniforms.uniforms_swirlStrength,
  uniforms.uniforms_turbulence,
  uniforms.uniforms_forceRadius,
  uniforms.uniforms_forceStrength,
  uniforms.uniforms_attraction,
  uniforms.uniforms_forcePosition
  );
}

#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs) -> FragmentOutputs {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
  let uniforms_value = load_FluidSimUniforms();
  let uv_local = fragmentInputs.vUV;
  let color = pass1(uv_local, uniforms_value, state, stateSampler, forces, forcesSampler, pass0Texture, pass0Sampler);
  fragmentOutputs.color = color;
#define CUSTOM_FRAGMENT_MAIN_END
}

`, // pass1
  `// Auto-generated by wgsl fragment generator. DO NOT EDIT.
varying vUV: vec2<f32>;
uniform uniforms_timeStep: f32;
uniform uniforms_velocityDissipation: f32;
uniform uniforms_densityDissipation: f32;
uniform uniforms_swirlStrength: f32;
uniform uniforms_turbulence: f32;
uniform uniforms_forceRadius: f32;
uniform uniforms_forceStrength: f32;
uniform uniforms_attraction: f32;
uniform uniforms_forcePosition: vec2f;
var state: texture_2d<f32>;
var stateSampler: sampler;
var forces: texture_2d<f32>;
var forcesSampler: sampler;
var pass0Texture: texture_2d<f32>;
var pass0Sampler: sampler;
var pass1Texture: texture_2d<f32>;
var pass1Sampler: sampler;

// Source fragment function
struct FluidSimUniforms {
  timeStep: f32, // 0.016
  velocityDissipation: f32, // 0.985
  densityDissipation: f32, // 0.995
  swirlStrength: f32, // 2.5
  turbulence: f32, // 0.2
  forceRadius: f32, // 0.12
  forceStrength: f32, // 18.0
  attraction: f32, // 0.35
  forcePosition: vec2f, // [0.5, 0.5]
};

fn safeSample(textureRef: texture_2d<f32>, samplerRef: sampler, uv: vec2f) -> vec4f {
  let clampedUv = clamp(uv, vec2f(0.0), vec2f(1.0));
  return textureSample(textureRef, samplerRef, clampedUv);
}

fn texelSize(textureRef: texture_2d<f32>) -> vec2f {
  let dims = textureDimensions(textureRef);
  return vec2f(
    select(1.0 / f32(dims.x), 0.0, dims.x == 0u),
    select(1.0 / f32(dims.y), 0.0, dims.y == 0u),
  );
}

fn advectUv(uv: vec2f, velocity: vec2f, delta: f32) -> vec2f {
  return clamp(uv - velocity * delta, vec2f(0.0), vec2f(1.0));
}

fn computeCurl(
  textureRef: texture_2d<f32>,
  samplerRef: sampler,
  uv: vec2f,
  texel: vec2f,
) -> f32 {
  let right = safeSample(textureRef, samplerRef, uv + vec2f(texel.x, 0.0)).xy;
  let left = safeSample(textureRef, samplerRef, uv - vec2f(texel.x, 0.0)).xy;
  let up = safeSample(textureRef, samplerRef, uv + vec2f(0.0, texel.y)).xy;
  let down = safeSample(textureRef, samplerRef, uv - vec2f(0.0, texel.y)).xy;
  let dY = right.y - left.y;
  let dX = up.x - down.x;
  return dY - dX;
}

fn applyForceField(
  uv: vec2f,
  uniforms: FluidSimUniforms,
  baseVelocity: vec2f,
  baseDensity: f32,
  forces: vec4f,
  curl: f32,
) -> vec4f {
  var velocity = baseVelocity;
  var density = baseDensity;

  let toCenter = uv - uniforms.forcePosition;
  let radius = max(uniforms.forceRadius, 1e-3);
  let dist = length(toCenter);
  let normalized = toCenter / max(dist, 1e-4);
  let radialFalloff = exp(-pow(dist / radius, 2.0));
  let swirlDir = vec2f(-normalized.y, normalized.x);
  velocity = velocity + swirlDir * uniforms.swirlStrength * radialFalloff;
  velocity = velocity - normalized * uniforms.attraction * radialFalloff;

  let turbulenceForce = vec2f(-curl, curl) * uniforms.turbulence;
  velocity = velocity + turbulenceForce;

  let a = max(forces.a, 1e-4);
  let dir01 = forces.xy / a;
  let encodedForce = dir01 * 2.0 - vec2f(1.0);
  velocity = velocity + encodedForce * uniforms.forceStrength * a;
  density = density + (forces.z / a) * (uniforms.forceStrength * 0.1) * a;

  return vec4f(velocity, density, 1.0);
}

// PASS 0: ADVECTION + FORCES + DISSIPATION
// This pass performs semi-Lagrangian advection, applies external forces,
// and computes curl for vorticity effects.
// 
// ARCHITECTURE ISSUE: This combines what should be 3-4 separate stages in Pavel's implementation:
// 1. Advection (backtracing velocity field)
// 2. Force application (adding external inputs)
// 3. Curl computation (for vorticity confinement)
// 4. Dissipation
//
// State encoding: xy = velocity, z = density, w = curl
fn pass0(
  uv: vec2f,
  uniforms: FluidSimUniforms,
  state: texture_2d<f32>,
  stateSampler: sampler,
  forces: texture_2d<f32>,
  forcesSampler: sampler,
) -> vec4f {
  let currentState = safeSample(state, stateSampler, uv);
  let texel = texelSize(state);
  
  // Semi-Lagrangian advection: trace particle backward in time
  let advectedUv = advectUv(uv, currentState.xy, uniforms.timeStep);
  let advectedState = safeSample(state, stateSampler, advectedUv);
  
  // Compute curl (rotation) of velocity field
  let curl = computeCurl(state, stateSampler, uv, texel);
  
  // Sample force texture (Y-flipped to match DOM coordinates)
  let forceSample = safeSample(forces, forcesSampler, vec2f(uv.x, 1.0 - uv.y));

  // Blend advected with current for stability (acts as implicit diffusion)
  let blendedVelocity = mix(advectedState.xy, currentState.xy, 0.25);
  let blendedDensity = mix(advectedState.z, currentState.z, 0.35);

  // Apply external forces and curl-based effects
  let forced = applyForceField(uv, uniforms, blendedVelocity, blendedDensity, forceSample, curl);

  // Apply dissipation (energy loss)
  var velocity = forced.xy * uniforms.velocityDissipation;
  var density = forced.z * uniforms.densityDissipation;

  return vec4f(velocity, density, curl);
}

// PASS 1: SPATIAL BLUR (PSEUDO-DIFFUSION)
// This pass performs a 3×3 weighted box blur on velocity and density,
// then computes a pseudo-divergence metric.
//
// CRITICAL ARCHITECTURE FLAW: This is NOT equivalent to Pavel's pressure projection!
// Pavel's implementation:
// 1. Computes true divergence: ∇·v = (vR.x - vL.x + vT.y - vB.y) * 0.5
// 2. Solves Poisson equation ∇²p = ∇·v via Jacobi iterations (20+ iterations)
// 3. Projects velocity to divergence-free: v' = v - ∇p
//
// This pass instead:
// - Uses blur as implicit diffusion
// - Computes length(current - blurred) as "divergence" (not physically meaningful)
// - Cannot enforce incompressibility without proper pressure solve
//
// Result: Fluid appears compressible, doesn't match Pavel's behavior
fn pass1(
  uv: vec2f,
  uniforms: FluidSimUniforms,
  state: texture_2d<f32>,
  stateSampler: sampler,
  forces: texture_2d<f32>,
  forcesSampler: sampler,
  pass0Texture: texture_2d<f32>,
  pass0Sampler: sampler,
) -> vec4f {
  let texel = texelSize(pass0Texture);
  
  // 3×3 weighted box blur (center weight = 2, neighbors = 1)
  var accumVelocity = vec2f(0.0);
  var accumDensity = 0.0;
  var weightSum = 0.0;
  for (var x = -1; x <= 1; x = x + 1) {
    for (var y = -1; y <= 1; y = y + 1) {
      let offset = vec2f(f32(x), f32(y));
      let weight = select(2.0, 1.0, (x == 0 && y == 0));
      weightSum = weightSum + weight;
      let neighborUv = uv + offset * texel;
      let neighbor = safeSample(pass0Texture, pass0Sampler, neighborUv);
      accumVelocity = accumVelocity + neighbor.xy * weight;
      accumDensity = accumDensity + neighbor.z * weight;
    }
  }

  let velocity = accumVelocity / max(weightSum, 1e-4);
  let density = accumDensity / max(weightSum, 1e-4);

  let current = safeSample(pass0Texture, pass0Sampler, uv);
  
  // Pseudo-divergence: magnitude of difference between current and blurred velocity
  // NOTE: This is NOT the true divergence operator!
  let divergence = length(current.xy - velocity);

  return vec4f(velocity, density, divergence);
}

// PASS 2: BLEND AND OUTPUT
// This pass blends the advected (pass0) and blurred (pass1) results,
// and computes an alpha channel for visualization.
//
// Purpose:
// - Combines advected (sharp, but potentially unstable) with blurred (stable, but diffusive)
// - Creates alpha from density + pseudo-divergence + curl magnitude
// - Outputs final state to feed back into next frame
//
// State encoding: xy = velocity, z = density, w = alpha (for visualization)
fn pass2(
  uv: vec2f,
  uniforms: FluidSimUniforms,
  state: texture_2d<f32>,
  stateSampler: sampler,
  forces: texture_2d<f32>,
  forcesSampler: sampler,
  pass0Texture: texture_2d<f32>,
  pass0Sampler: sampler,
  pass1Texture: texture_2d<f32>,
  pass1Sampler: sampler,
) -> vec4f {
  let advected = safeSample(pass0Texture, pass0Sampler, uv);
  let relaxed = safeSample(pass1Texture, pass1Sampler, uv);
  
  // Blend advected (sharp) with relaxed (blurred) for stability
  var velocity = mix(advected.xy, relaxed.xy, 0.55);
  var density = mix(advected.z, relaxed.z, 0.4);
  
  let divergence = relaxed.w;
  let curl = advected.w;
  
  // Compute alpha for visualization (higher where there's more activity)
  let alpha = clamp(density + divergence * 0.1 + abs(curl) * 0.05, 0.0, 1.0);
  
  return vec4f(velocity, density, alpha);
}

fn load_FluidSimUniforms() -> FluidSimUniforms {
  return FluidSimUniforms(
  uniforms.uniforms_timeStep,
  uniforms.uniforms_velocityDissipation,
  uniforms.uniforms_densityDissipation,
  uniforms.uniforms_swirlStrength,
  uniforms.uniforms_turbulence,
  uniforms.uniforms_forceRadius,
  uniforms.uniforms_forceStrength,
  uniforms.uniforms_attraction,
  uniforms.uniforms_forcePosition
  );
}

#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs) -> FragmentOutputs {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
  let uniforms_value = load_FluidSimUniforms();
  let uv_local = fragmentInputs.vUV;
  let color = pass2(uv_local, uniforms_value, state, stateSampler, forces, forcesSampler, pass0Texture, pass0Sampler, pass1Texture, pass1Sampler);
  fragmentOutputs.color = color;
#define CUSTOM_FRAGMENT_MAIN_END
}

`, // pass2
] as const;
export const FluidSimPassCount = 3 as const;
export const FluidSimPrimaryTextureName = 'state' as const;

export const FluidSimPassTextureSources = [
  [
    { binding: 'state', source: { kind: 'input', key: 'state' } },
    { binding: 'forces', source: { kind: 'input', key: 'forces' } },
  ],
  [
    { binding: 'state', source: { kind: 'input', key: 'state' } },
    { binding: 'forces', source: { kind: 'input', key: 'forces' } },
    { binding: 'pass0Texture', source: { kind: 'pass', passIndex: 0 } },
  ],
  [
    { binding: 'state', source: { kind: 'input', key: 'state' } },
    { binding: 'forces', source: { kind: 'input', key: 'forces' } },
    { binding: 'pass0Texture', source: { kind: 'pass', passIndex: 0 } },
    { binding: 'pass1Texture', source: { kind: 'pass', passIndex: 1 } },
  ],
] as const;

function ensureVector2(value: BABYLON.Vector2 | readonly [number, number]): BABYLON.Vector2 {
  return value instanceof BABYLON.Vector2 ? value : BABYLON.Vector2.FromArray(value as readonly [number, number]);
}

export interface FluidSimUniforms {
  timeStep: number;
  velocityDissipation: number;
  densityDissipation: number;
  swirlStrength: number;
  turbulence: number;
  forceRadius: number;
  forceStrength: number;
  attraction: number;
  forcePosition: BABYLON.Vector2 | readonly [number, number];
}

export function setFluidSimUniforms(material: BABYLON.ShaderMaterial, uniforms: Partial<FluidSimUniforms>): void {
  if (!uniforms) {
    return;
  }
  if (uniforms.timeStep !== undefined) {
    material.setFloat('uniforms_timeStep', uniforms.timeStep);
  }
  if (uniforms.velocityDissipation !== undefined) {
    material.setFloat('uniforms_velocityDissipation', uniforms.velocityDissipation);
  }
  if (uniforms.densityDissipation !== undefined) {
    material.setFloat('uniforms_densityDissipation', uniforms.densityDissipation);
  }
  if (uniforms.swirlStrength !== undefined) {
    material.setFloat('uniforms_swirlStrength', uniforms.swirlStrength);
  }
  if (uniforms.turbulence !== undefined) {
    material.setFloat('uniforms_turbulence', uniforms.turbulence);
  }
  if (uniforms.forceRadius !== undefined) {
    material.setFloat('uniforms_forceRadius', uniforms.forceRadius);
  }
  if (uniforms.forceStrength !== undefined) {
    material.setFloat('uniforms_forceStrength', uniforms.forceStrength);
  }
  if (uniforms.attraction !== undefined) {
    material.setFloat('uniforms_attraction', uniforms.attraction);
  }
  if (uniforms.forcePosition !== undefined) {
    material.setVector2('uniforms_forcePosition', ensureVector2(uniforms.forcePosition));
  }
}

export type FluidSimTextureName = 'state' | 'forces' | 'pass0Texture' | 'pass1Texture';
export interface FluidSimInputs {
  state: ShaderSource;
  forces: ShaderSource;
}

export interface FluidSimMaterialHandles {
  material: BABYLON.ShaderMaterial;
  setTexture(name: FluidSimTextureName, texture: BABYLON.BaseTexture): void;
  setTextureSampler(name: FluidSimTextureName, sampler: BABYLON.TextureSampler): void;
  setUniforms(uniforms: Partial<FluidSimUniforms>): void;
}

export interface FluidSimMaterialOptions {
  name?: string;
  passIndex?: number;
}

export function createFluidSimMaterial(scene: BABYLON.Scene, options: FluidSimMaterialOptions = {}): FluidSimMaterialHandles {
  const passIndex = options.passIndex ?? 0;
  if (passIndex < 0 || passIndex >= 3) {
    throw new Error(`Invalid passIndex ${passIndex} for FluidSim. Expected 0 <= passIndex < 3.`);
  }
  const baseName = options.name ?? 'FluidSimMaterial';
  const shaderName = `${baseName}_pass${passIndex}`;
  // Register shaders in the WGSL store to enable preprocessor
  const vertexShaderName = `${shaderName}VertexShader`;
  const fragmentShaderName = `${shaderName}FragmentShader`;
  
  BABYLON.ShaderStore.ShadersStoreWGSL[vertexShaderName] = FluidSimVertexSource;
  BABYLON.ShaderStore.ShadersStoreWGSL[fragmentShaderName] = FluidSimFragmentSources[passIndex];
  
  const material = new BABYLON.ShaderMaterial(shaderName, scene, {
    vertex: shaderName,
    fragment: shaderName,
  }, {
    attributes: ['position', 'uv'],
    uniforms: ['uniforms_timeStep', 'uniforms_velocityDissipation', 'uniforms_densityDissipation', 'uniforms_swirlStrength', 'uniforms_turbulence', 'uniforms_forceRadius', 'uniforms_forceStrength', 'uniforms_attraction', 'uniforms_forcePosition'],
    samplers: ['state', 'forces', 'pass0Texture', 'pass1Texture'],
    samplerObjects: ['stateSampler', 'forcesSampler', 'pass0Sampler', 'pass1Sampler'],
    shaderLanguage: BABYLON.ShaderLanguage.WGSL,
  });

  const samplerLookup = { 'state': 'stateSampler', 'forces': 'forcesSampler', 'pass0Texture': 'pass0Sampler', 'pass1Texture': 'pass1Sampler' } as const;

  const handles: FluidSimMaterialHandles = {
    material,
    setTexture: (name, texture) => material.setTexture(name, texture),
    setTextureSampler: (name, sampler) => material.setTextureSampler(samplerLookup[name], sampler),
    setUniforms: (values) => setFluidSimUniforms(material, values),
  };

  return handles;
}

export class FluidSimEffect extends CustomShaderEffect<FluidSimUniforms, FluidSimInputs> {
  effectName = 'FluidSim'

  constructor(engine: BABYLON.WebGPUEngine, inputs: FluidSimInputs, width = 1280, height = 720, sampleMode: 'nearest' | 'linear' = 'linear', precision: RenderPrecision = 'half_float') {
    super(engine, inputs, {
      factory: (sceneRef, options) => createFluidSimMaterial(sceneRef, options),
      textureInputKeys: ['state', 'forces'],
      textureBindingKeys: ['state', 'forces', 'pass0Texture', 'pass1Texture'],
      passTextureSources: FluidSimPassTextureSources,
      passCount: 3,
      primaryTextureKey: 'state',
      width,
      height,
      materialName: 'FluidSimMaterial',
      sampleMode,
      precision,
    })
    this.setUniforms({
      timeStep: 0.016,
      velocityDissipation: 0.985,
      densityDissipation: 0.995,
      swirlStrength: 2.5,
      turbulence: 0.2,
      forceRadius: 0.12,
      forceStrength: 18.0,
      attraction: 0.35,
      forcePosition: [0.5, 0.5],
    });
  }

  override setSrcs(inputs: Partial<FluidSimInputs>): void {
    super.setSrcs(inputs);
  }

  override setUniforms(uniforms: { timeStep?: Dynamic<number>, velocityDissipation?: Dynamic<number>, densityDissipation?: Dynamic<number>, swirlStrength?: Dynamic<number>, turbulence?: Dynamic<number>, forceRadius?: Dynamic<number>, forceStrength?: Dynamic<number>, attraction?: Dynamic<number>, forcePosition?: Dynamic<BABYLON.Vector2 | readonly [number, number]> }): void {
    const record: ShaderUniforms = {};
    if (uniforms.timeStep !== undefined) {
      record['timeStep'] = uniforms.timeStep;
    }
    if (uniforms.velocityDissipation !== undefined) {
      record['velocityDissipation'] = uniforms.velocityDissipation;
    }
    if (uniforms.densityDissipation !== undefined) {
      record['densityDissipation'] = uniforms.densityDissipation;
    }
    if (uniforms.swirlStrength !== undefined) {
      record['swirlStrength'] = uniforms.swirlStrength;
    }
    if (uniforms.turbulence !== undefined) {
      record['turbulence'] = uniforms.turbulence;
    }
    if (uniforms.forceRadius !== undefined) {
      record['forceRadius'] = uniforms.forceRadius;
    }
    if (uniforms.forceStrength !== undefined) {
      record['forceStrength'] = uniforms.forceStrength;
    }
    if (uniforms.attraction !== undefined) {
      record['attraction'] = uniforms.attraction;
    }
    if (uniforms.forcePosition !== undefined) {
      record['forcePosition'] = uniforms.forcePosition;
    }
    super.setUniforms(record);
  }
}

