// Auto-generated by wgsl fragment generator. DO NOT EDIT.
import * as BABYLON from 'babylonjs';
import { CustomShaderEffect, type ShaderSource, type RenderPrecision, type UniformDescriptor, type ShaderUniforms, type Dynamic } from '../shaderFXBabylon';
export const LevelVertexSource = `// Auto-generated by wgsl fragment generator. DO NOT EDIT.
attribute position: vec3<f32>;
attribute uv: vec2<f32>;
varying vUV: vec2<f32>;

#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs) -> FragmentInputs {
#define CUSTOM_VERTEX_MAIN_BEGIN
  vertexOutputs.position = vec4<f32>(vertexInputs.position, 1.0);
  vertexOutputs.vUV = vertexInputs.uv;
#define CUSTOM_VERTEX_MAIN_END
}

`;
export const LevelFragmentSources = [
  `// Auto-generated by wgsl fragment generator. DO NOT EDIT.
varying vUV: vec2<f32>;
uniform uniforms_clampInputMode: u32;
uniform uniforms_invert: u32;
uniform uniforms_blackLevel: f32;
uniform uniforms_brightness1: f32;
uniform uniforms_gamma1: f32;
uniform uniforms_contrast: f32;
uniform uniforms_inLow: f32;
uniform uniforms_inHigh: f32;
uniform uniforms_outLow: f32;
uniform uniforms_outHigh: f32;
uniform uniforms_lowRGBA: vec4f;
uniform uniforms_highRGBA: vec4f;
uniform uniforms_stepping: u32;
uniform uniforms_stepSize: f32;
uniform uniforms_stepThreshold: f32;
uniform uniforms_stepClampLow: f32;
uniform uniforms_stepClampHigh: f32;
uniform uniforms_stepSoften: f32;
uniform uniforms_gamma2: f32;
uniform uniforms_brightness2: f32;
uniform uniforms_opacity: f32;
uniform uniforms_postClamp: f32;
var src: texture_2d<f32>;
var srcSampler: sampler;

// Source fragment function
struct LevelUniforms {
  clampInputMode: u32,
  invert: u32,
  blackLevel: f32,
  brightness1: f32,
  gamma1: f32,
  contrast: f32,
  inLow: f32,
  inHigh: f32,
  outLow: f32,
  outHigh: f32,
  lowRGBA: vec4f,
  highRGBA: vec4f,
  stepping: u32,
  stepSize: f32,
  stepThreshold: f32,
  stepClampLow: f32,
  stepClampHigh: f32,
  stepSoften: f32,
  gamma2: f32,
  brightness2: f32,
  opacity: f32,
  postClamp: f32,
};

fn pass0(uv: vec2f, uniforms: LevelUniforms, src: texture_2d<f32>, srcSampler: sampler) -> vec4f {
  var color = textureSample(src, srcSampler, uv);
  var rgb = color.rgb;
  var alpha = color.a;

  if (uniforms.clampInputMode != 2u) {
    rgb = clamp(rgb, vec3f(0.0), vec3f(1.0));
    alpha = clamp(alpha, 0.0, 1.0);
  }

  if (uniforms.invert != 0u) {
    rgb = vec3f(1.0) - rgb;
  }

  rgb = max(rgb - vec3f(uniforms.blackLevel), vec3f(0.0));
  rgb = rgb + vec3f(uniforms.brightness1);
  let gammaOne = max(uniforms.gamma1, 1e-6);
  rgb = pow(max(rgb, vec3f(0.0)), vec3f(1.0 / gammaOne));
  rgb = (rgb - vec3f(0.5)) * uniforms.contrast + vec3f(0.5);

  let range = max(uniforms.inHigh - uniforms.inLow, 1e-6);
  let normalized = clamp((rgb - vec3f(uniforms.inLow)) / range, vec3f(0.0), vec3f(1.0));
  let outRange = uniforms.outHigh - uniforms.outLow;
  rgb = vec3f(uniforms.outLow) + normalized * outRange;

  let lowVec = uniforms.lowRGBA.xyz;
  let highVec = uniforms.highRGBA.xyz;
  rgb = clamp(rgb, lowVec, highVec);
  alpha = clamp(alpha, uniforms.lowRGBA.w, uniforms.highRGBA.w);

  if (uniforms.stepping != 0u && uniforms.stepSize > 1e-6) {
    let originalRgb = rgb;
    let step = uniforms.stepSize;
    let shifted = (rgb + vec3f(uniforms.stepThreshold)) / step;
    let quantized = floor(shifted) * step;
    let clamped = clamp(quantized, vec3f(uniforms.stepClampLow), vec3f(uniforms.stepClampHigh));
    let softenAmount = clamp(uniforms.stepSoften, 0.0, 1.0);
    rgb = mix(clamped, originalRgb, vec3f(softenAmount));
  }

  rgb = rgb + vec3f(uniforms.brightness2);
  let gammaTwo = max(uniforms.gamma2, 1e-6);
  rgb = pow(max(rgb, vec3f(0.0)), vec3f(1.0 / gammaTwo));

  if (uniforms.postClamp < 1e9) {
    rgb = min(rgb, vec3f(uniforms.postClamp));
  }

  alpha = clamp(alpha * uniforms.opacity, 0.0, 1.0);

  return vec4f(rgb, alpha);
}

fn load_LevelUniforms() -> LevelUniforms {
  var result: LevelUniforms;
  result.clampInputMode = uniforms.uniforms_clampInputMode;
  result.invert = uniforms.uniforms_invert;
  result.blackLevel = uniforms.uniforms_blackLevel;
  result.brightness1 = uniforms.uniforms_brightness1;
  result.gamma1 = uniforms.uniforms_gamma1;
  result.contrast = uniforms.uniforms_contrast;
  result.inLow = uniforms.uniforms_inLow;
  result.inHigh = uniforms.uniforms_inHigh;
  result.outLow = uniforms.uniforms_outLow;
  result.outHigh = uniforms.uniforms_outHigh;
  result.lowRGBA = uniforms.uniforms_lowRGBA;
  result.highRGBA = uniforms.uniforms_highRGBA;
  result.stepping = uniforms.uniforms_stepping;
  result.stepSize = uniforms.uniforms_stepSize;
  result.stepThreshold = uniforms.uniforms_stepThreshold;
  result.stepClampLow = uniforms.uniforms_stepClampLow;
  result.stepClampHigh = uniforms.uniforms_stepClampHigh;
  result.stepSoften = uniforms.uniforms_stepSoften;
  result.gamma2 = uniforms.uniforms_gamma2;
  result.brightness2 = uniforms.uniforms_brightness2;
  result.opacity = uniforms.uniforms_opacity;
  result.postClamp = uniforms.uniforms_postClamp;
  return result;
}

#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs) -> FragmentOutputs {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
  let uniforms_value = load_LevelUniforms();
  let uv_local = fragmentInputs.vUV;
  let color = pass0(uv_local, uniforms_value, src, srcSampler);
  fragmentOutputs.color = color;
#define CUSTOM_FRAGMENT_MAIN_END
}

`, // pass0
] as const;
export const LevelPassCount = 1 as const;
export const LevelPrimaryTextureName = 'src' as const;

export const LevelPassTextureSources = [
  [
    { binding: 'src', source: { kind: 'input', key: 'src' } },
  ],
] as const;

export const LevelUniformMeta: UniformDescriptor[] = [
  {
    name: 'clampInputMode',
    kind: 'u32',
    bindingName: 'uniforms_clampInputMode',
  },
  {
    name: 'invert',
    kind: 'u32',
    bindingName: 'uniforms_invert',
  },
  {
    name: 'blackLevel',
    kind: 'f32',
    bindingName: 'uniforms_blackLevel',
  },
  {
    name: 'brightness1',
    kind: 'f32',
    bindingName: 'uniforms_brightness1',
  },
  {
    name: 'gamma1',
    kind: 'f32',
    bindingName: 'uniforms_gamma1',
  },
  {
    name: 'contrast',
    kind: 'f32',
    bindingName: 'uniforms_contrast',
  },
  {
    name: 'inLow',
    kind: 'f32',
    bindingName: 'uniforms_inLow',
  },
  {
    name: 'inHigh',
    kind: 'f32',
    bindingName: 'uniforms_inHigh',
  },
  {
    name: 'outLow',
    kind: 'f32',
    bindingName: 'uniforms_outLow',
  },
  {
    name: 'outHigh',
    kind: 'f32',
    bindingName: 'uniforms_outHigh',
  },
  {
    name: 'lowRGBA',
    kind: 'vec4f',
    bindingName: 'uniforms_lowRGBA',
  },
  {
    name: 'highRGBA',
    kind: 'vec4f',
    bindingName: 'uniforms_highRGBA',
  },
  {
    name: 'stepping',
    kind: 'u32',
    bindingName: 'uniforms_stepping',
  },
  {
    name: 'stepSize',
    kind: 'f32',
    bindingName: 'uniforms_stepSize',
  },
  {
    name: 'stepThreshold',
    kind: 'f32',
    bindingName: 'uniforms_stepThreshold',
  },
  {
    name: 'stepClampLow',
    kind: 'f32',
    bindingName: 'uniforms_stepClampLow',
  },
  {
    name: 'stepClampHigh',
    kind: 'f32',
    bindingName: 'uniforms_stepClampHigh',
  },
  {
    name: 'stepSoften',
    kind: 'f32',
    bindingName: 'uniforms_stepSoften',
  },
  {
    name: 'gamma2',
    kind: 'f32',
    bindingName: 'uniforms_gamma2',
  },
  {
    name: 'brightness2',
    kind: 'f32',
    bindingName: 'uniforms_brightness2',
  },
  {
    name: 'opacity',
    kind: 'f32',
    bindingName: 'uniforms_opacity',
  },
  {
    name: 'postClamp',
    kind: 'f32',
    bindingName: 'uniforms_postClamp',
  },
];

function ensureVector4(value: BABYLON.Vector4 | readonly [number, number, number, number]): BABYLON.Vector4 {
  return value instanceof BABYLON.Vector4 ? value : BABYLON.Vector4.FromArray(value as readonly [number, number, number, number]);
}

export interface LevelUniforms {
  clampInputMode: number;
  invert: number;
  blackLevel: number;
  brightness1: number;
  gamma1: number;
  contrast: number;
  inLow: number;
  inHigh: number;
  outLow: number;
  outHigh: number;
  lowRGBA: BABYLON.Vector4 | readonly [number, number, number, number];
  highRGBA: BABYLON.Vector4 | readonly [number, number, number, number];
  stepping: number;
  stepSize: number;
  stepThreshold: number;
  stepClampLow: number;
  stepClampHigh: number;
  stepSoften: number;
  gamma2: number;
  brightness2: number;
  opacity: number;
  postClamp: number;
}

export function setLevelUniforms(material: BABYLON.ShaderMaterial, uniforms: Partial<LevelUniforms>): void {
  if (!uniforms) {
    return;
  }
  if (uniforms.clampInputMode !== undefined) {
    material.setUInt('uniforms_clampInputMode', uniforms.clampInputMode);
  }
  if (uniforms.invert !== undefined) {
    material.setUInt('uniforms_invert', uniforms.invert);
  }
  if (uniforms.blackLevel !== undefined) {
    material.setFloat('uniforms_blackLevel', uniforms.blackLevel);
  }
  if (uniforms.brightness1 !== undefined) {
    material.setFloat('uniforms_brightness1', uniforms.brightness1);
  }
  if (uniforms.gamma1 !== undefined) {
    material.setFloat('uniforms_gamma1', uniforms.gamma1);
  }
  if (uniforms.contrast !== undefined) {
    material.setFloat('uniforms_contrast', uniforms.contrast);
  }
  if (uniforms.inLow !== undefined) {
    material.setFloat('uniforms_inLow', uniforms.inLow);
  }
  if (uniforms.inHigh !== undefined) {
    material.setFloat('uniforms_inHigh', uniforms.inHigh);
  }
  if (uniforms.outLow !== undefined) {
    material.setFloat('uniforms_outLow', uniforms.outLow);
  }
  if (uniforms.outHigh !== undefined) {
    material.setFloat('uniforms_outHigh', uniforms.outHigh);
  }
  if (uniforms.lowRGBA !== undefined) {
    material.setVector4('uniforms_lowRGBA', ensureVector4(uniforms.lowRGBA));
  }
  if (uniforms.highRGBA !== undefined) {
    material.setVector4('uniforms_highRGBA', ensureVector4(uniforms.highRGBA));
  }
  if (uniforms.stepping !== undefined) {
    material.setUInt('uniforms_stepping', uniforms.stepping);
  }
  if (uniforms.stepSize !== undefined) {
    material.setFloat('uniforms_stepSize', uniforms.stepSize);
  }
  if (uniforms.stepThreshold !== undefined) {
    material.setFloat('uniforms_stepThreshold', uniforms.stepThreshold);
  }
  if (uniforms.stepClampLow !== undefined) {
    material.setFloat('uniforms_stepClampLow', uniforms.stepClampLow);
  }
  if (uniforms.stepClampHigh !== undefined) {
    material.setFloat('uniforms_stepClampHigh', uniforms.stepClampHigh);
  }
  if (uniforms.stepSoften !== undefined) {
    material.setFloat('uniforms_stepSoften', uniforms.stepSoften);
  }
  if (uniforms.gamma2 !== undefined) {
    material.setFloat('uniforms_gamma2', uniforms.gamma2);
  }
  if (uniforms.brightness2 !== undefined) {
    material.setFloat('uniforms_brightness2', uniforms.brightness2);
  }
  if (uniforms.opacity !== undefined) {
    material.setFloat('uniforms_opacity', uniforms.opacity);
  }
  if (uniforms.postClamp !== undefined) {
    material.setFloat('uniforms_postClamp', uniforms.postClamp);
  }
}

export type LevelTextureName = 'src';
export interface LevelInputs {
  src: ShaderSource;
}

export interface LevelMaterialHandles {
  material: BABYLON.ShaderMaterial;
  setTexture(name: LevelTextureName, texture: BABYLON.BaseTexture): void;
  setTextureSampler(name: LevelTextureName, sampler: BABYLON.TextureSampler): void;
  setUniforms(uniforms: Partial<LevelUniforms>): void;
}

export interface LevelMaterialOptions {
  name?: string;
  passIndex?: number;
}

export function createLevelMaterial(scene: BABYLON.Scene, options: LevelMaterialOptions = {}): LevelMaterialHandles {
  const passIndex = options.passIndex ?? 0;
  if (passIndex < 0 || passIndex >= 1) {
    throw new Error(`Invalid passIndex ${passIndex} for Level. Expected 0 <= passIndex < 1.`);
  }
  const baseName = options.name ?? 'LevelMaterial';
  const shaderName = `${baseName}_pass${passIndex}`;
  // Register shaders in the WGSL store to enable preprocessor
  const vertexShaderName = `${shaderName}VertexShader`;
  const fragmentShaderName = `${shaderName}FragmentShader`;
  
  BABYLON.ShaderStore.ShadersStoreWGSL[vertexShaderName] = LevelVertexSource;
  BABYLON.ShaderStore.ShadersStoreWGSL[fragmentShaderName] = LevelFragmentSources[passIndex];
  
  const material = new BABYLON.ShaderMaterial(shaderName, scene, {
    vertex: shaderName,
    fragment: shaderName,
  }, {
    attributes: ['position', 'uv'],
    uniforms: ['uniforms_clampInputMode', 'uniforms_invert', 'uniforms_blackLevel', 'uniforms_brightness1', 'uniforms_gamma1', 'uniforms_contrast', 'uniforms_inLow', 'uniforms_inHigh', 'uniforms_outLow', 'uniforms_outHigh', 'uniforms_lowRGBA', 'uniforms_highRGBA', 'uniforms_stepping', 'uniforms_stepSize', 'uniforms_stepThreshold', 'uniforms_stepClampLow', 'uniforms_stepClampHigh', 'uniforms_stepSoften', 'uniforms_gamma2', 'uniforms_brightness2', 'uniforms_opacity', 'uniforms_postClamp'],
    samplers: ['src'],
    samplerObjects: ['srcSampler'],
    shaderLanguage: BABYLON.ShaderLanguage.WGSL,
  });

  const samplerLookup = { 'src': 'srcSampler' } as const;

  const handles: LevelMaterialHandles = {
    material,
    setTexture: (name, texture) => material.setTexture(name, texture),
    setTextureSampler: (name, sampler) => material.setTextureSampler(samplerLookup[name], sampler),
    setUniforms: (values) => setLevelUniforms(material, values),
  };

  return handles;
}

export class LevelEffect extends CustomShaderEffect<LevelUniforms, LevelInputs> {
  effectName = 'Level'

  constructor(engine: BABYLON.WebGPUEngine, inputs: LevelInputs, width = 1280, height = 720, sampleMode: 'nearest' | 'linear' = 'linear', precision: RenderPrecision = 'half_float') {
    super(engine, inputs, {
      factory: (sceneRef, options) => createLevelMaterial(sceneRef, options),
      textureInputKeys: ['src'],
      textureBindingKeys: ['src'],
      passTextureSources: LevelPassTextureSources,
      passCount: 1,
      primaryTextureKey: 'src',
      width,
      height,
      materialName: 'LevelMaterial',
      sampleMode,
      precision,
      uniformMeta: LevelUniformMeta,
    })
  }

  override setSrcs(inputs: Partial<LevelInputs>): void {
    super.setSrcs(inputs);
  }

  override setUniforms(uniforms: { clampInputMode?: Dynamic<number>, invert?: Dynamic<number>, blackLevel?: Dynamic<number>, brightness1?: Dynamic<number>, gamma1?: Dynamic<number>, contrast?: Dynamic<number>, inLow?: Dynamic<number>, inHigh?: Dynamic<number>, outLow?: Dynamic<number>, outHigh?: Dynamic<number>, lowRGBA?: Dynamic<BABYLON.Vector4 | readonly [number, number, number, number]>, highRGBA?: Dynamic<BABYLON.Vector4 | readonly [number, number, number, number]>, stepping?: Dynamic<number>, stepSize?: Dynamic<number>, stepThreshold?: Dynamic<number>, stepClampLow?: Dynamic<number>, stepClampHigh?: Dynamic<number>, stepSoften?: Dynamic<number>, gamma2?: Dynamic<number>, brightness2?: Dynamic<number>, opacity?: Dynamic<number>, postClamp?: Dynamic<number> }): void {
    const record: ShaderUniforms = {};
    if (uniforms.clampInputMode !== undefined) {
      record['clampInputMode'] = uniforms.clampInputMode;
    }
    if (uniforms.invert !== undefined) {
      record['invert'] = uniforms.invert;
    }
    if (uniforms.blackLevel !== undefined) {
      record['blackLevel'] = uniforms.blackLevel;
    }
    if (uniforms.brightness1 !== undefined) {
      record['brightness1'] = uniforms.brightness1;
    }
    if (uniforms.gamma1 !== undefined) {
      record['gamma1'] = uniforms.gamma1;
    }
    if (uniforms.contrast !== undefined) {
      record['contrast'] = uniforms.contrast;
    }
    if (uniforms.inLow !== undefined) {
      record['inLow'] = uniforms.inLow;
    }
    if (uniforms.inHigh !== undefined) {
      record['inHigh'] = uniforms.inHigh;
    }
    if (uniforms.outLow !== undefined) {
      record['outLow'] = uniforms.outLow;
    }
    if (uniforms.outHigh !== undefined) {
      record['outHigh'] = uniforms.outHigh;
    }
    if (uniforms.lowRGBA !== undefined) {
      record['lowRGBA'] = uniforms.lowRGBA;
    }
    if (uniforms.highRGBA !== undefined) {
      record['highRGBA'] = uniforms.highRGBA;
    }
    if (uniforms.stepping !== undefined) {
      record['stepping'] = uniforms.stepping;
    }
    if (uniforms.stepSize !== undefined) {
      record['stepSize'] = uniforms.stepSize;
    }
    if (uniforms.stepThreshold !== undefined) {
      record['stepThreshold'] = uniforms.stepThreshold;
    }
    if (uniforms.stepClampLow !== undefined) {
      record['stepClampLow'] = uniforms.stepClampLow;
    }
    if (uniforms.stepClampHigh !== undefined) {
      record['stepClampHigh'] = uniforms.stepClampHigh;
    }
    if (uniforms.stepSoften !== undefined) {
      record['stepSoften'] = uniforms.stepSoften;
    }
    if (uniforms.gamma2 !== undefined) {
      record['gamma2'] = uniforms.gamma2;
    }
    if (uniforms.brightness2 !== undefined) {
      record['brightness2'] = uniforms.brightness2;
    }
    if (uniforms.opacity !== undefined) {
      record['opacity'] = uniforms.opacity;
    }
    if (uniforms.postClamp !== undefined) {
      record['postClamp'] = uniforms.postClamp;
    }
    super.setUniforms(record);
  }
}

