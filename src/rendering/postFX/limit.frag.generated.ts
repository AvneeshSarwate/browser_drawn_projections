// Auto-generated by wgsl fragment generator. DO NOT EDIT.
import * as BABYLON from 'babylonjs';
import { CustomShaderEffect, type ShaderSource, type RenderPrecision, type ShaderUniforms, type Dynamic } from '../shaderFXBabylon';
export const LimitVertexSource = `// Auto-generated by wgsl fragment generator. DO NOT EDIT.
attribute position: vec3<f32>;
attribute uv: vec2<f32>;
varying vUV: vec2<f32>;
uniform uniforms_minFunction: u32;
uniform uniforms_maxFunction: u32;
uniform uniforms_minValue: f32;
uniform uniforms_maxValue: f32;
uniform uniforms_positiveOnly: u32;
uniform uniforms_normalize: u32;
uniform uniforms_normalizeMin: f32;
uniform uniforms_normalizeMax: f32;
uniform uniforms_quantizeValueMode: u32;
uniform uniforms_valueStep: f32;
uniform uniforms_valueOffset: f32;
uniform uniforms_quantizePositionMode: u32;
uniform uniforms_positionStep: vec2f;
uniform uniforms_positionOffset: vec2f;
var src: texture_2d<f32>;
var srcSampler: sampler;

#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs) -> FragmentInputs {
#define CUSTOM_VERTEX_MAIN_BEGIN
  vertexOutputs.position = vec4<f32>(vertexInputs.position, 1.0);
  vertexOutputs.vUV = vertexInputs.uv;
#define CUSTOM_VERTEX_MAIN_END
}

`;
export const LimitFragmentSources = [
  `// Auto-generated by wgsl fragment generator. DO NOT EDIT.
varying vUV: vec2<f32>;
uniform uniforms_minFunction: u32;
uniform uniforms_maxFunction: u32;
uniform uniforms_minValue: f32;
uniform uniforms_maxValue: f32;
uniform uniforms_positiveOnly: u32;
uniform uniforms_normalize: u32;
uniform uniforms_normalizeMin: f32;
uniform uniforms_normalizeMax: f32;
uniform uniforms_quantizeValueMode: u32;
uniform uniforms_valueStep: f32;
uniform uniforms_valueOffset: f32;
uniform uniforms_quantizePositionMode: u32;
uniform uniforms_positionStep: vec2f;
uniform uniforms_positionOffset: vec2f;
var src: texture_2d<f32>;
var srcSampler: sampler;

// Source fragment function
struct LimitUniforms {
  minFunction: u32, // 0
  maxFunction: u32, // 0
  minValue: f32, // 0.0
  maxValue: f32, // 1.0
  positiveOnly: u32, // 0
  normalize: u32, // 0
  normalizeMin: f32, // 0.0
  normalizeMax: f32, // 1.0
  quantizeValueMode: u32, // 0
  valueStep: f32, // 0.1
  valueOffset: f32, // 0.0
  quantizePositionMode: u32, // 0
  positionStep: vec2f, // [0.0, 0.0]
  positionOffset: vec2f, // [0.0, 0.0]
};

fn pass0(uv: vec2f, uniforms: LimitUniforms, src: texture_2d<f32>, srcSampler: sampler) -> vec4f {
  var sampleUv = uv;
  if (uniforms.quantizePositionMode != 0u) {
    let step = uniforms.positionStep;
    let offset = uniforms.positionOffset;
    let safeStepX = max(step.x, 1e-6);
    let safeStepY = max(step.y, 1e-6);
    var xValue = uv.x;
    var yValue = uv.y;
    if (!(step.x <= 1e-6 && step.y <= 1e-6)) {
      let mode = uniforms.quantizePositionMode;
      if (step.x > 1e-6) {
        let shiftedX = (uv.x - offset.x) / safeStepX;
        if (mode == 1u) {
          xValue = ceil(shiftedX) * safeStepX + offset.x;
        } else if (mode == 2u) {
          xValue = floor(shiftedX) * safeStepX + offset.x;
        } else {
          xValue = round(shiftedX) * safeStepX + offset.x;
        }
      }
      if (step.y > 1e-6) {
        let shiftedY = (uv.y - offset.y) / safeStepY;
        if (mode == 1u) {
          yValue = ceil(shiftedY) * safeStepY + offset.y;
        } else if (mode == 2u) {
          yValue = floor(shiftedY) * safeStepY + offset.y;
        } else {
          yValue = round(shiftedY) * safeStepY + offset.y;
        }
      }
      sampleUv = clamp(vec2f(xValue, yValue), vec2f(0.0), vec2f(1.0));
    }
  }

  var color = textureSample(src, srcSampler, sampleUv);
  let range = max(uniforms.maxValue - uniforms.minValue, 1e-6);
  let doubleRange = range * 2.0;

  // Apply min/max to each channel
  var r = color.r;
  if (uniforms.minFunction != 0u && r < uniforms.minValue) {
    if (uniforms.minFunction == 1u) {
      r = uniforms.minValue;
    } else if (uniforms.minFunction == 2u) {
      let offset = r - uniforms.minValue;
      let wrapped = offset - range * floor(offset / range);
      r = uniforms.minValue + wrapped;
    } else if (uniforms.minFunction == 3u) {
      let offset = r - uniforms.minValue;
      let wrapped = offset - doubleRange * floor(offset / doubleRange);
      if (wrapped <= range) {
        r = uniforms.minValue + wrapped;
      } else {
        r = uniforms.maxValue - (wrapped - range);
      }
    }
  }
  if (uniforms.maxFunction != 0u && r > uniforms.maxValue) {
    if (uniforms.maxFunction == 1u) {
      r = uniforms.maxValue;
    } else if (uniforms.maxFunction == 2u) {
      let offset = r - uniforms.minValue;
      let wrapped = offset - range * floor(offset / range);
      r = uniforms.minValue + wrapped;
    } else if (uniforms.maxFunction == 3u) {
      let offset = r - uniforms.minValue;
      let wrapped = offset - doubleRange * floor(offset / doubleRange);
      if (wrapped <= range) {
        r = uniforms.minValue + wrapped;
      } else {
        r = uniforms.maxValue - (wrapped - range);
      }
    }
  }

  var g = color.g;
  if (uniforms.minFunction != 0u && g < uniforms.minValue) {
    if (uniforms.minFunction == 1u) {
      g = uniforms.minValue;
    } else if (uniforms.minFunction == 2u) {
      let offset = g - uniforms.minValue;
      let wrapped = offset - range * floor(offset / range);
      g = uniforms.minValue + wrapped;
    } else if (uniforms.minFunction == 3u) {
      let offset = g - uniforms.minValue;
      let wrapped = offset - doubleRange * floor(offset / doubleRange);
      if (wrapped <= range) {
        g = uniforms.minValue + wrapped;
      } else {
        g = uniforms.maxValue - (wrapped - range);
      }
    }
  }
  if (uniforms.maxFunction != 0u && g > uniforms.maxValue) {
    if (uniforms.maxFunction == 1u) {
      g = uniforms.maxValue;
    } else if (uniforms.maxFunction == 2u) {
      let offset = g - uniforms.minValue;
      let wrapped = offset - range * floor(offset / range);
      g = uniforms.minValue + wrapped;
    } else if (uniforms.maxFunction == 3u) {
      let offset = g - uniforms.minValue;
      let wrapped = offset - doubleRange * floor(offset / doubleRange);
      if (wrapped <= range) {
        g = uniforms.minValue + wrapped;
      } else {
        g = uniforms.maxValue - (wrapped - range);
      }
    }
  }

  var b = color.b;
  if (uniforms.minFunction != 0u && b < uniforms.minValue) {
    if (uniforms.minFunction == 1u) {
      b = uniforms.minValue;
    } else if (uniforms.minFunction == 2u) {
      let offset = b - uniforms.minValue;
      let wrapped = offset - range * floor(offset / range);
      b = uniforms.minValue + wrapped;
    } else if (uniforms.minFunction == 3u) {
      let offset = b - uniforms.minValue;
      let wrapped = offset - doubleRange * floor(offset / doubleRange);
      if (wrapped <= range) {
        b = uniforms.minValue + wrapped;
      } else {
        b = uniforms.maxValue - (wrapped - range);
      }
    }
  }
  if (uniforms.maxFunction != 0u && b > uniforms.maxValue) {
    if (uniforms.maxFunction == 1u) {
      b = uniforms.maxValue;
    } else if (uniforms.maxFunction == 2u) {
      let offset = b - uniforms.minValue;
      let wrapped = offset - range * floor(offset / range);
      b = uniforms.minValue + wrapped;
    } else if (uniforms.maxFunction == 3u) {
      let offset = b - uniforms.minValue;
      let wrapped = offset - doubleRange * floor(offset / doubleRange);
      if (wrapped <= range) {
        b = uniforms.minValue + wrapped;
      } else {
        b = uniforms.maxValue - (wrapped - range);
      }
    }
  }

  var a = color.a;
  if (uniforms.minFunction != 0u && a < uniforms.minValue) {
    if (uniforms.minFunction == 1u) {
      a = uniforms.minValue;
    } else if (uniforms.minFunction == 2u) {
      let offset = a - uniforms.minValue;
      let wrapped = offset - range * floor(offset / range);
      a = uniforms.minValue + wrapped;
    } else if (uniforms.minFunction == 3u) {
      let offset = a - uniforms.minValue;
      let wrapped = offset - doubleRange * floor(offset / doubleRange);
      if (wrapped <= range) {
        a = uniforms.minValue + wrapped;
      } else {
        a = uniforms.maxValue - (wrapped - range);
      }
    }
  }
  if (uniforms.maxFunction != 0u && a > uniforms.maxValue) {
    if (uniforms.maxFunction == 1u) {
      a = uniforms.maxValue;
    } else if (uniforms.maxFunction == 2u) {
      let offset = a - uniforms.minValue;
      let wrapped = offset - range * floor(offset / range);
      a = uniforms.minValue + wrapped;
    } else if (uniforms.maxFunction == 3u) {
      let offset = a - uniforms.minValue;
      let wrapped = offset - doubleRange * floor(offset / doubleRange);
      if (wrapped <= range) {
        a = uniforms.minValue + wrapped;
      } else {
        a = uniforms.maxValue - (wrapped - range);
      }
    }
  }

  var limited = vec4f(r, g, b, a);

  if (uniforms.quantizeValueMode != 0u && uniforms.valueStep > 1e-6) {
    let mode = uniforms.quantizeValueMode;
    let step = uniforms.valueStep;
    let offset = uniforms.valueOffset;
    var qr = limited.r;
    var qg = limited.g;
    var qb = limited.b;
    var qa = limited.a;
    let shiftedR = (limited.r - offset) / step;
    let shiftedG = (limited.g - offset) / step;
    let shiftedB = (limited.b - offset) / step;
    let shiftedA = (limited.a - offset) / step;
    if (mode == 1u) {
      qr = ceil(shiftedR);
      qg = ceil(shiftedG);
      qb = ceil(shiftedB);
      qa = ceil(shiftedA);
    } else if (mode == 2u) {
      qr = floor(shiftedR);
      qg = floor(shiftedG);
      qb = floor(shiftedB);
      qa = floor(shiftedA);
    } else {
      qr = round(shiftedR);
      qg = round(shiftedG);
      qb = round(shiftedB);
      qa = round(shiftedA);
    }
    limited = vec4f(qr * step + offset, qg * step + offset, qb * step + offset, qa * step + offset);
  }

  if (uniforms.positiveOnly != 0u) {
    limited = abs(limited);
  }

  if (uniforms.normalize != 0u) {
    let normalized = (limited - vec4f(uniforms.minValue, uniforms.minValue, uniforms.minValue, uniforms.minValue)) / range;
    let targetRange = uniforms.normalizeMax - uniforms.normalizeMin;
    let scaled = normalized * targetRange + uniforms.normalizeMin;
    let minClamp = vec4f(uniforms.normalizeMin, uniforms.normalizeMin, uniforms.normalizeMin, uniforms.normalizeMin);
    let maxClamp = vec4f(uniforms.normalizeMax, uniforms.normalizeMax, uniforms.normalizeMax, uniforms.normalizeMax);
    limited = clamp(scaled, minClamp, maxClamp);
  }

  return limited;
}

fn load_LimitUniforms() -> LimitUniforms {
  return LimitUniforms(
  uniforms.uniforms_minFunction,
  uniforms.uniforms_maxFunction,
  uniforms.uniforms_minValue,
  uniforms.uniforms_maxValue,
  uniforms.uniforms_positiveOnly,
  uniforms.uniforms_normalize,
  uniforms.uniforms_normalizeMin,
  uniforms.uniforms_normalizeMax,
  uniforms.uniforms_quantizeValueMode,
  uniforms.uniforms_valueStep,
  uniforms.uniforms_valueOffset,
  uniforms.uniforms_quantizePositionMode,
  uniforms.uniforms_positionStep,
  uniforms.uniforms_positionOffset
  );
}

#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs) -> FragmentOutputs {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
  let uniforms_value = load_LimitUniforms();
  let uv_local = fragmentInputs.vUV;
  let color = pass0(uv_local, uniforms_value, src, srcSampler);
  fragmentOutputs.color = color;
#define CUSTOM_FRAGMENT_MAIN_END
}

`, // pass0
] as const;
export const LimitPassCount = 1 as const;
export const LimitPrimaryTextureName = 'src' as const;

function ensureVector2(value: BABYLON.Vector2 | readonly [number, number]): BABYLON.Vector2 {
  return value instanceof BABYLON.Vector2 ? value : BABYLON.Vector2.FromArray(value as readonly [number, number]);
}

export interface LimitUniforms {
  minFunction: number;
  maxFunction: number;
  minValue: number;
  maxValue: number;
  positiveOnly: number;
  normalize: number;
  normalizeMin: number;
  normalizeMax: number;
  quantizeValueMode: number;
  valueStep: number;
  valueOffset: number;
  quantizePositionMode: number;
  positionStep: BABYLON.Vector2 | readonly [number, number];
  positionOffset: BABYLON.Vector2 | readonly [number, number];
}

export function setLimitUniforms(material: BABYLON.ShaderMaterial, uniforms: Partial<LimitUniforms>): void {
  if (!uniforms) {
    return;
  }
  if (uniforms.minFunction !== undefined) {
    material.setUInt('uniforms_minFunction', uniforms.minFunction);
  }
  if (uniforms.maxFunction !== undefined) {
    material.setUInt('uniforms_maxFunction', uniforms.maxFunction);
  }
  if (uniforms.minValue !== undefined) {
    material.setFloat('uniforms_minValue', uniforms.minValue);
  }
  if (uniforms.maxValue !== undefined) {
    material.setFloat('uniforms_maxValue', uniforms.maxValue);
  }
  if (uniforms.positiveOnly !== undefined) {
    material.setUInt('uniforms_positiveOnly', uniforms.positiveOnly);
  }
  if (uniforms.normalize !== undefined) {
    material.setUInt('uniforms_normalize', uniforms.normalize);
  }
  if (uniforms.normalizeMin !== undefined) {
    material.setFloat('uniforms_normalizeMin', uniforms.normalizeMin);
  }
  if (uniforms.normalizeMax !== undefined) {
    material.setFloat('uniforms_normalizeMax', uniforms.normalizeMax);
  }
  if (uniforms.quantizeValueMode !== undefined) {
    material.setUInt('uniforms_quantizeValueMode', uniforms.quantizeValueMode);
  }
  if (uniforms.valueStep !== undefined) {
    material.setFloat('uniforms_valueStep', uniforms.valueStep);
  }
  if (uniforms.valueOffset !== undefined) {
    material.setFloat('uniforms_valueOffset', uniforms.valueOffset);
  }
  if (uniforms.quantizePositionMode !== undefined) {
    material.setUInt('uniforms_quantizePositionMode', uniforms.quantizePositionMode);
  }
  if (uniforms.positionStep !== undefined) {
    material.setVector2('uniforms_positionStep', ensureVector2(uniforms.positionStep));
  }
  if (uniforms.positionOffset !== undefined) {
    material.setVector2('uniforms_positionOffset', ensureVector2(uniforms.positionOffset));
  }
}

export type LimitTextureName = 'src';
export interface LimitInputs {
  src: ShaderSource;
}

export interface LimitMaterialHandles {
  material: BABYLON.ShaderMaterial;
  setTexture(name: LimitTextureName, texture: BABYLON.BaseTexture): void;
  setTextureSampler(name: LimitTextureName, sampler: BABYLON.TextureSampler): void;
  setUniforms(uniforms: Partial<LimitUniforms>): void;
}

export interface LimitMaterialOptions {
  name?: string;
  passIndex?: number;
}

export function createLimitMaterial(scene: BABYLON.Scene, options: LimitMaterialOptions = {}): LimitMaterialHandles {
  const passIndex = options.passIndex ?? 0;
  if (passIndex < 0 || passIndex >= 1) {
    throw new Error(`Invalid passIndex ${passIndex} for Limit. Expected 0 <= passIndex < 1.`);
  }
  const baseName = options.name ?? 'LimitMaterial';
  const shaderName = `${baseName}_pass${passIndex}`;
  // Register shaders in the WGSL store to enable preprocessor
  const vertexShaderName = `${shaderName}VertexShader`;
  const fragmentShaderName = `${shaderName}FragmentShader`;
  
  BABYLON.ShaderStore.ShadersStoreWGSL[vertexShaderName] = LimitVertexSource;
  BABYLON.ShaderStore.ShadersStoreWGSL[fragmentShaderName] = LimitFragmentSources[passIndex];
  
  const material = new BABYLON.ShaderMaterial(shaderName, scene, {
    vertex: shaderName,
    fragment: shaderName,
  }, {
    attributes: ['position', 'uv'],
    uniforms: ['uniforms_minFunction', 'uniforms_maxFunction', 'uniforms_minValue', 'uniforms_maxValue', 'uniforms_positiveOnly', 'uniforms_normalize', 'uniforms_normalizeMin', 'uniforms_normalizeMax', 'uniforms_quantizeValueMode', 'uniforms_valueStep', 'uniforms_valueOffset', 'uniforms_quantizePositionMode', 'uniforms_positionStep', 'uniforms_positionOffset'],
    samplers: ['src'],
    samplerObjects: ['srcSampler'],
    shaderLanguage: BABYLON.ShaderLanguage.WGSL,
  });

  const samplerLookup = { 'src': 'srcSampler' } as const;

  const handles: LimitMaterialHandles = {
    material,
    setTexture: (name, texture) => material.setTexture(name, texture),
    setTextureSampler: (name, sampler) => material.setTextureSampler(samplerLookup[name], sampler),
    setUniforms: (values) => setLimitUniforms(material, values),
  };

  return handles;
}

export class LimitEffect extends CustomShaderEffect<LimitUniforms, LimitInputs> {
  effectName = 'Limit'

  constructor(engine: BABYLON.WebGPUEngine, inputs: LimitInputs, width = 1280, height = 720, sampleMode: 'nearest' | 'linear' = 'linear', precision: RenderPrecision = 'half_float') {
    super(engine, inputs, {
      factory: (sceneRef, options) => createLimitMaterial(sceneRef, options),
      textureInputKeys: ['src'],
      passCount: 1,
      primaryTextureKey: 'src',
      width,
      height,
      materialName: 'LimitMaterial',
      sampleMode,
      precision,
    })
    this.setUniforms({
      minFunction: 0,
      maxFunction: 0,
      minValue: 0.0,
      maxValue: 1.0,
      positiveOnly: 0,
      normalize: 0,
      normalizeMin: 0.0,
      normalizeMax: 1.0,
      quantizeValueMode: 0,
      valueStep: 0.1,
      valueOffset: 0.0,
      quantizePositionMode: 0,
      positionStep: [0.0, 0.0],
      positionOffset: [0.0, 0.0],
    });
  }

  override setSrcs(inputs: Partial<LimitInputs>): void {
    super.setSrcs(inputs);
  }

  override setUniforms(uniforms: { minFunction?: Dynamic<number>, maxFunction?: Dynamic<number>, minValue?: Dynamic<number>, maxValue?: Dynamic<number>, positiveOnly?: Dynamic<number>, normalize?: Dynamic<number>, normalizeMin?: Dynamic<number>, normalizeMax?: Dynamic<number>, quantizeValueMode?: Dynamic<number>, valueStep?: Dynamic<number>, valueOffset?: Dynamic<number>, quantizePositionMode?: Dynamic<number>, positionStep?: Dynamic<BABYLON.Vector2 | readonly [number, number]>, positionOffset?: Dynamic<BABYLON.Vector2 | readonly [number, number]> }): void {
    const record: ShaderUniforms = {};
    if (uniforms.minFunction !== undefined) {
      record['minFunction'] = uniforms.minFunction;
    }
    if (uniforms.maxFunction !== undefined) {
      record['maxFunction'] = uniforms.maxFunction;
    }
    if (uniforms.minValue !== undefined) {
      record['minValue'] = uniforms.minValue;
    }
    if (uniforms.maxValue !== undefined) {
      record['maxValue'] = uniforms.maxValue;
    }
    if (uniforms.positiveOnly !== undefined) {
      record['positiveOnly'] = uniforms.positiveOnly;
    }
    if (uniforms.normalize !== undefined) {
      record['normalize'] = uniforms.normalize;
    }
    if (uniforms.normalizeMin !== undefined) {
      record['normalizeMin'] = uniforms.normalizeMin;
    }
    if (uniforms.normalizeMax !== undefined) {
      record['normalizeMax'] = uniforms.normalizeMax;
    }
    if (uniforms.quantizeValueMode !== undefined) {
      record['quantizeValueMode'] = uniforms.quantizeValueMode;
    }
    if (uniforms.valueStep !== undefined) {
      record['valueStep'] = uniforms.valueStep;
    }
    if (uniforms.valueOffset !== undefined) {
      record['valueOffset'] = uniforms.valueOffset;
    }
    if (uniforms.quantizePositionMode !== undefined) {
      record['quantizePositionMode'] = uniforms.quantizePositionMode;
    }
    if (uniforms.positionStep !== undefined) {
      record['positionStep'] = uniforms.positionStep;
    }
    if (uniforms.positionOffset !== undefined) {
      record['positionOffset'] = uniforms.positionOffset;
    }
    super.setUniforms(record);
  }
}

