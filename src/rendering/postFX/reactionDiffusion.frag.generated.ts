// Auto-generated by wgsl fragment generator. DO NOT EDIT.
import * as BABYLON from 'babylonjs';
import { CustomShaderEffect, type ShaderSource, type RenderPrecision, type ShaderUniforms, type Dynamic } from '../shaderFXBabylon';
export const ReactionDiffusionVertexSource = `// Auto-generated by wgsl fragment generator. DO NOT EDIT.
attribute position: vec3<f32>;
attribute uv: vec2<f32>;
varying vUV: vec2<f32>;
uniform uniforms_feed: f32;
uniform uniforms_kill: f32;
uniform uniforms_diffRateA: f32;
uniform uniforms_diffRateB: f32;
uniform uniforms_deltaT: f32;
uniform uniforms_brushRadius: f32;
uniform uniforms_brushStrength: f32;
uniform uniforms_noiseAmount: f32;
uniform uniforms_brushPosition: vec2f;
var state: texture_2d<f32>;
var stateSampler: sampler;
var seed: texture_2d<f32>;
var seedSampler: sampler;
var pass0Texture: texture_2d<f32>;
var pass0Sampler: sampler;
var pass1Texture: texture_2d<f32>;
var pass1Sampler: sampler;

#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs) -> FragmentInputs {
#define CUSTOM_VERTEX_MAIN_BEGIN
  vertexOutputs.position = vec4<f32>(vertexInputs.position, 1.0);
  vertexOutputs.vUV = vertexInputs.uv;
#define CUSTOM_VERTEX_MAIN_END
}

`;
export const ReactionDiffusionFragmentSources = [
  `// Auto-generated by wgsl fragment generator. DO NOT EDIT.
varying vUV: vec2<f32>;
uniform uniforms_feed: f32;
uniform uniforms_kill: f32;
uniform uniforms_diffRateA: f32;
uniform uniforms_diffRateB: f32;
uniform uniforms_deltaT: f32;
uniform uniforms_brushRadius: f32;
uniform uniforms_brushStrength: f32;
uniform uniforms_noiseAmount: f32;
uniform uniforms_brushPosition: vec2f;
var state: texture_2d<f32>;
var stateSampler: sampler;
var seed: texture_2d<f32>;
var seedSampler: sampler;
var pass0Texture: texture_2d<f32>;
var pass0Sampler: sampler;
var pass1Texture: texture_2d<f32>;
var pass1Sampler: sampler;

// Source fragment function
struct ReactionDiffusionUniforms {
  feed: f32, // 0.055
  kill: f32, // 0.062
  diffRateA: f32, // 1.0
  diffRateB: f32, // 0.5
  deltaT: f32, // 1.0
  brushRadius: f32, // 0.035
  brushStrength: f32, // 0.85
  noiseAmount: f32, // 0.02
  brushPosition: vec2f, // [0.5, 0.5]
};

fn safeSample(textureRef: texture_2d<f32>, samplerRef: sampler, uv: vec2f) -> vec4f {
  let clampedUv = clamp(uv, vec2f(0.0), vec2f(1.0));
  return textureSample(textureRef, samplerRef, clampedUv);
}

fn texelSize(textureRef: texture_2d<f32>) -> vec2f {
  let dims = textureDimensions(textureRef);
  return vec2f(
    select(1.0 / f32(dims.x), 0.0, dims.x == 0u),
    select(1.0 / f32(dims.y), 0.0, dims.y == 0u),
  );
}

fn laplacian(textureRef: texture_2d<f32>, samplerRef: sampler, uv: vec2f, texel: vec2f) -> vec4f {
  let center = safeSample(textureRef, samplerRef, uv);
  var accum = vec2f(-center.xy * 1.0);
  let offsets = array<vec2f, 4>(
    vec2f(texel.x, 0.0),
    vec2f(-texel.x, 0.0),
    vec2f(0.0, texel.y),
    vec2f(0.0, -texel.y),
  );
  for (var i = 0; i < 4; i = i + 1) {
    let neighbor = safeSample(textureRef, samplerRef, uv + offsets[i]);
    accum = accum + neighbor.xy * 0.25;
  }
  return vec4f(accum, center.xy);
}

fn brushInfluence(uv: vec2f, uniforms: ReactionDiffusionUniforms) -> f32 {
  let radius = max(uniforms.brushRadius, 1e-3);
  let toCenter = uv - uniforms.brushPosition;
  let dist = length(toCenter);
  return exp(-pow(dist / radius, 2.0));
}

fn pass0(
  uv: vec2f,
  uniforms: ReactionDiffusionUniforms,
  state: texture_2d<f32>,
  stateSampler: sampler,
  seed: texture_2d<f32>,
  seedSampler: sampler,
) -> vec4f {
  let texel = texelSize(state);
  let lap = laplacian(state, stateSampler, uv, texel);
  return lap;
}

fn pass1(
  uv: vec2f,
  uniforms: ReactionDiffusionUniforms,
  state: texture_2d<f32>,
  stateSampler: sampler,
  seed: texture_2d<f32>,
  seedSampler: sampler,
  pass0Texture: texture_2d<f32>,
  pass0Sampler: sampler,
) -> vec4f {
  let lapData = safeSample(pass0Texture, pass0Sampler, uv);
  var a = lapData.z;
  var b = lapData.w;
  let lapA = lapData.x;
  let lapB = lapData.y;

  let reaction = a * b * b;
  let feedTerm = uniforms.feed * (1.0 - a);
  let killTerm = (uniforms.feed + uniforms.kill) * b;

  a = a + (uniforms.diffRateA * lapA - reaction + feedTerm) * uniforms.deltaT;
  b = b + (uniforms.diffRateB * lapB + reaction - killTerm) * uniforms.deltaT;

  let brush = brushInfluence(uv, uniforms) * uniforms.brushStrength;
  a = a - brush * 0.5;
  b = b + brush;

  let seedSample = safeSample(seed, seedSampler, uv);
  b = mix(b, max(b, seedSample.r), seedSample.a);
  a = mix(a, min(a, 1.0 - seedSample.g), seedSample.a);

  let noise = (fract(sin(dot(uv, vec2f(12.9898, 78.233))) * 43758.5453) - 0.5) * uniforms.noiseAmount;
  b = b + noise;

  a = clamp(a, 0.0, 1.0);
  b = clamp(b, 0.0, 1.0);

  return vec4f(a, b, lapA, lapB);
}

fn pass2(
  uv: vec2f,
  uniforms: ReactionDiffusionUniforms,
  state: texture_2d<f32>,
  stateSampler: sampler,
  seed: texture_2d<f32>,
  seedSampler: sampler,
  pass0Texture: texture_2d<f32>,
  pass0Sampler: sampler,
  pass1Texture: texture_2d<f32>,
  pass1Sampler: sampler,
) -> vec4f {
  let updated = safeSample(pass1Texture, pass1Sampler, uv);
  let a = updated.x;
  let b = updated.y;
  let lapA = updated.z;
  let lapB = updated.w;
  let edge = clamp(length(vec2f(lapA, lapB)) * 0.75, 0.0, 1.0);
  let pigment = clamp(b - a + edge, 0.0, 1.0);
  return vec4f(a, b, pigment, 1.0);
}

fn load_ReactionDiffusionUniforms() -> ReactionDiffusionUniforms {
  return ReactionDiffusionUniforms(
  uniforms.uniforms_feed,
  uniforms.uniforms_kill,
  uniforms.uniforms_diffRateA,
  uniforms.uniforms_diffRateB,
  uniforms.uniforms_deltaT,
  uniforms.uniforms_brushRadius,
  uniforms.uniforms_brushStrength,
  uniforms.uniforms_noiseAmount,
  uniforms.uniforms_brushPosition
  );
}

#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs) -> FragmentOutputs {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
  let uniforms_value = load_ReactionDiffusionUniforms();
  let uv_local = fragmentInputs.vUV;
  let color = pass0(uv_local, uniforms_value, state, stateSampler, seed, seedSampler);
  fragmentOutputs.color = color;
#define CUSTOM_FRAGMENT_MAIN_END
}

`, // pass0
  `// Auto-generated by wgsl fragment generator. DO NOT EDIT.
varying vUV: vec2<f32>;
uniform uniforms_feed: f32;
uniform uniforms_kill: f32;
uniform uniforms_diffRateA: f32;
uniform uniforms_diffRateB: f32;
uniform uniforms_deltaT: f32;
uniform uniforms_brushRadius: f32;
uniform uniforms_brushStrength: f32;
uniform uniforms_noiseAmount: f32;
uniform uniforms_brushPosition: vec2f;
var state: texture_2d<f32>;
var stateSampler: sampler;
var seed: texture_2d<f32>;
var seedSampler: sampler;
var pass0Texture: texture_2d<f32>;
var pass0Sampler: sampler;
var pass1Texture: texture_2d<f32>;
var pass1Sampler: sampler;

// Source fragment function
struct ReactionDiffusionUniforms {
  feed: f32, // 0.055
  kill: f32, // 0.062
  diffRateA: f32, // 1.0
  diffRateB: f32, // 0.5
  deltaT: f32, // 1.0
  brushRadius: f32, // 0.035
  brushStrength: f32, // 0.85
  noiseAmount: f32, // 0.02
  brushPosition: vec2f, // [0.5, 0.5]
};

fn safeSample(textureRef: texture_2d<f32>, samplerRef: sampler, uv: vec2f) -> vec4f {
  let clampedUv = clamp(uv, vec2f(0.0), vec2f(1.0));
  return textureSample(textureRef, samplerRef, clampedUv);
}

fn texelSize(textureRef: texture_2d<f32>) -> vec2f {
  let dims = textureDimensions(textureRef);
  return vec2f(
    select(1.0 / f32(dims.x), 0.0, dims.x == 0u),
    select(1.0 / f32(dims.y), 0.0, dims.y == 0u),
  );
}

fn laplacian(textureRef: texture_2d<f32>, samplerRef: sampler, uv: vec2f, texel: vec2f) -> vec4f {
  let center = safeSample(textureRef, samplerRef, uv);
  var accum = vec2f(-center.xy * 1.0);
  let offsets = array<vec2f, 4>(
    vec2f(texel.x, 0.0),
    vec2f(-texel.x, 0.0),
    vec2f(0.0, texel.y),
    vec2f(0.0, -texel.y),
  );
  for (var i = 0; i < 4; i = i + 1) {
    let neighbor = safeSample(textureRef, samplerRef, uv + offsets[i]);
    accum = accum + neighbor.xy * 0.25;
  }
  return vec4f(accum, center.xy);
}

fn brushInfluence(uv: vec2f, uniforms: ReactionDiffusionUniforms) -> f32 {
  let radius = max(uniforms.brushRadius, 1e-3);
  let toCenter = uv - uniforms.brushPosition;
  let dist = length(toCenter);
  return exp(-pow(dist / radius, 2.0));
}

fn pass0(
  uv: vec2f,
  uniforms: ReactionDiffusionUniforms,
  state: texture_2d<f32>,
  stateSampler: sampler,
  seed: texture_2d<f32>,
  seedSampler: sampler,
) -> vec4f {
  let texel = texelSize(state);
  let lap = laplacian(state, stateSampler, uv, texel);
  return lap;
}

fn pass1(
  uv: vec2f,
  uniforms: ReactionDiffusionUniforms,
  state: texture_2d<f32>,
  stateSampler: sampler,
  seed: texture_2d<f32>,
  seedSampler: sampler,
  pass0Texture: texture_2d<f32>,
  pass0Sampler: sampler,
) -> vec4f {
  let lapData = safeSample(pass0Texture, pass0Sampler, uv);
  var a = lapData.z;
  var b = lapData.w;
  let lapA = lapData.x;
  let lapB = lapData.y;

  let reaction = a * b * b;
  let feedTerm = uniforms.feed * (1.0 - a);
  let killTerm = (uniforms.feed + uniforms.kill) * b;

  a = a + (uniforms.diffRateA * lapA - reaction + feedTerm) * uniforms.deltaT;
  b = b + (uniforms.diffRateB * lapB + reaction - killTerm) * uniforms.deltaT;

  let brush = brushInfluence(uv, uniforms) * uniforms.brushStrength;
  a = a - brush * 0.5;
  b = b + brush;

  let seedSample = safeSample(seed, seedSampler, uv);
  b = mix(b, max(b, seedSample.r), seedSample.a);
  a = mix(a, min(a, 1.0 - seedSample.g), seedSample.a);

  let noise = (fract(sin(dot(uv, vec2f(12.9898, 78.233))) * 43758.5453) - 0.5) * uniforms.noiseAmount;
  b = b + noise;

  a = clamp(a, 0.0, 1.0);
  b = clamp(b, 0.0, 1.0);

  return vec4f(a, b, lapA, lapB);
}

fn pass2(
  uv: vec2f,
  uniforms: ReactionDiffusionUniforms,
  state: texture_2d<f32>,
  stateSampler: sampler,
  seed: texture_2d<f32>,
  seedSampler: sampler,
  pass0Texture: texture_2d<f32>,
  pass0Sampler: sampler,
  pass1Texture: texture_2d<f32>,
  pass1Sampler: sampler,
) -> vec4f {
  let updated = safeSample(pass1Texture, pass1Sampler, uv);
  let a = updated.x;
  let b = updated.y;
  let lapA = updated.z;
  let lapB = updated.w;
  let edge = clamp(length(vec2f(lapA, lapB)) * 0.75, 0.0, 1.0);
  let pigment = clamp(b - a + edge, 0.0, 1.0);
  return vec4f(a, b, pigment, 1.0);
}

fn load_ReactionDiffusionUniforms() -> ReactionDiffusionUniforms {
  return ReactionDiffusionUniforms(
  uniforms.uniforms_feed,
  uniforms.uniforms_kill,
  uniforms.uniforms_diffRateA,
  uniforms.uniforms_diffRateB,
  uniforms.uniforms_deltaT,
  uniforms.uniforms_brushRadius,
  uniforms.uniforms_brushStrength,
  uniforms.uniforms_noiseAmount,
  uniforms.uniforms_brushPosition
  );
}

#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs) -> FragmentOutputs {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
  let uniforms_value = load_ReactionDiffusionUniforms();
  let uv_local = fragmentInputs.vUV;
  let color = pass1(uv_local, uniforms_value, state, stateSampler, seed, seedSampler, pass0Texture, pass0Sampler);
  fragmentOutputs.color = color;
#define CUSTOM_FRAGMENT_MAIN_END
}

`, // pass1
  `// Auto-generated by wgsl fragment generator. DO NOT EDIT.
varying vUV: vec2<f32>;
uniform uniforms_feed: f32;
uniform uniforms_kill: f32;
uniform uniforms_diffRateA: f32;
uniform uniforms_diffRateB: f32;
uniform uniforms_deltaT: f32;
uniform uniforms_brushRadius: f32;
uniform uniforms_brushStrength: f32;
uniform uniforms_noiseAmount: f32;
uniform uniforms_brushPosition: vec2f;
var state: texture_2d<f32>;
var stateSampler: sampler;
var seed: texture_2d<f32>;
var seedSampler: sampler;
var pass0Texture: texture_2d<f32>;
var pass0Sampler: sampler;
var pass1Texture: texture_2d<f32>;
var pass1Sampler: sampler;

// Source fragment function
struct ReactionDiffusionUniforms {
  feed: f32, // 0.055
  kill: f32, // 0.062
  diffRateA: f32, // 1.0
  diffRateB: f32, // 0.5
  deltaT: f32, // 1.0
  brushRadius: f32, // 0.035
  brushStrength: f32, // 0.85
  noiseAmount: f32, // 0.02
  brushPosition: vec2f, // [0.5, 0.5]
};

fn safeSample(textureRef: texture_2d<f32>, samplerRef: sampler, uv: vec2f) -> vec4f {
  let clampedUv = clamp(uv, vec2f(0.0), vec2f(1.0));
  return textureSample(textureRef, samplerRef, clampedUv);
}

fn texelSize(textureRef: texture_2d<f32>) -> vec2f {
  let dims = textureDimensions(textureRef);
  return vec2f(
    select(1.0 / f32(dims.x), 0.0, dims.x == 0u),
    select(1.0 / f32(dims.y), 0.0, dims.y == 0u),
  );
}

fn laplacian(textureRef: texture_2d<f32>, samplerRef: sampler, uv: vec2f, texel: vec2f) -> vec4f {
  let center = safeSample(textureRef, samplerRef, uv);
  var accum = vec2f(-center.xy * 1.0);
  let offsets = array<vec2f, 4>(
    vec2f(texel.x, 0.0),
    vec2f(-texel.x, 0.0),
    vec2f(0.0, texel.y),
    vec2f(0.0, -texel.y),
  );
  for (var i = 0; i < 4; i = i + 1) {
    let neighbor = safeSample(textureRef, samplerRef, uv + offsets[i]);
    accum = accum + neighbor.xy * 0.25;
  }
  return vec4f(accum, center.xy);
}

fn brushInfluence(uv: vec2f, uniforms: ReactionDiffusionUniforms) -> f32 {
  let radius = max(uniforms.brushRadius, 1e-3);
  let toCenter = uv - uniforms.brushPosition;
  let dist = length(toCenter);
  return exp(-pow(dist / radius, 2.0));
}

fn pass0(
  uv: vec2f,
  uniforms: ReactionDiffusionUniforms,
  state: texture_2d<f32>,
  stateSampler: sampler,
  seed: texture_2d<f32>,
  seedSampler: sampler,
) -> vec4f {
  let texel = texelSize(state);
  let lap = laplacian(state, stateSampler, uv, texel);
  return lap;
}

fn pass1(
  uv: vec2f,
  uniforms: ReactionDiffusionUniforms,
  state: texture_2d<f32>,
  stateSampler: sampler,
  seed: texture_2d<f32>,
  seedSampler: sampler,
  pass0Texture: texture_2d<f32>,
  pass0Sampler: sampler,
) -> vec4f {
  let lapData = safeSample(pass0Texture, pass0Sampler, uv);
  var a = lapData.z;
  var b = lapData.w;
  let lapA = lapData.x;
  let lapB = lapData.y;

  let reaction = a * b * b;
  let feedTerm = uniforms.feed * (1.0 - a);
  let killTerm = (uniforms.feed + uniforms.kill) * b;

  a = a + (uniforms.diffRateA * lapA - reaction + feedTerm) * uniforms.deltaT;
  b = b + (uniforms.diffRateB * lapB + reaction - killTerm) * uniforms.deltaT;

  let brush = brushInfluence(uv, uniforms) * uniforms.brushStrength;
  a = a - brush * 0.5;
  b = b + brush;

  let seedSample = safeSample(seed, seedSampler, uv);
  b = mix(b, max(b, seedSample.r), seedSample.a);
  a = mix(a, min(a, 1.0 - seedSample.g), seedSample.a);

  let noise = (fract(sin(dot(uv, vec2f(12.9898, 78.233))) * 43758.5453) - 0.5) * uniforms.noiseAmount;
  b = b + noise;

  a = clamp(a, 0.0, 1.0);
  b = clamp(b, 0.0, 1.0);

  return vec4f(a, b, lapA, lapB);
}

fn pass2(
  uv: vec2f,
  uniforms: ReactionDiffusionUniforms,
  state: texture_2d<f32>,
  stateSampler: sampler,
  seed: texture_2d<f32>,
  seedSampler: sampler,
  pass0Texture: texture_2d<f32>,
  pass0Sampler: sampler,
  pass1Texture: texture_2d<f32>,
  pass1Sampler: sampler,
) -> vec4f {
  let updated = safeSample(pass1Texture, pass1Sampler, uv);
  let a = updated.x;
  let b = updated.y;
  let lapA = updated.z;
  let lapB = updated.w;
  let edge = clamp(length(vec2f(lapA, lapB)) * 0.75, 0.0, 1.0);
  let pigment = clamp(b - a + edge, 0.0, 1.0);
  return vec4f(a, b, pigment, 1.0);
}

fn load_ReactionDiffusionUniforms() -> ReactionDiffusionUniforms {
  return ReactionDiffusionUniforms(
  uniforms.uniforms_feed,
  uniforms.uniforms_kill,
  uniforms.uniforms_diffRateA,
  uniforms.uniforms_diffRateB,
  uniforms.uniforms_deltaT,
  uniforms.uniforms_brushRadius,
  uniforms.uniforms_brushStrength,
  uniforms.uniforms_noiseAmount,
  uniforms.uniforms_brushPosition
  );
}

#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs) -> FragmentOutputs {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
  let uniforms_value = load_ReactionDiffusionUniforms();
  let uv_local = fragmentInputs.vUV;
  let color = pass2(uv_local, uniforms_value, state, stateSampler, seed, seedSampler, pass0Texture, pass0Sampler, pass1Texture, pass1Sampler);
  fragmentOutputs.color = color;
#define CUSTOM_FRAGMENT_MAIN_END
}

`, // pass2
] as const;
export const ReactionDiffusionPassCount = 3 as const;
export const ReactionDiffusionPrimaryTextureName = 'state' as const;

export const ReactionDiffusionPassTextureSources = [
  [
    { binding: 'state', source: { kind: 'input', key: 'state' } },
    { binding: 'seed', source: { kind: 'input', key: 'seed' } },
  ],
  [
    { binding: 'state', source: { kind: 'input', key: 'state' } },
    { binding: 'seed', source: { kind: 'input', key: 'seed' } },
    { binding: 'pass0Texture', source: { kind: 'pass', passIndex: 0 } },
  ],
  [
    { binding: 'state', source: { kind: 'input', key: 'state' } },
    { binding: 'seed', source: { kind: 'input', key: 'seed' } },
    { binding: 'pass0Texture', source: { kind: 'pass', passIndex: 0 } },
    { binding: 'pass1Texture', source: { kind: 'pass', passIndex: 1 } },
  ],
] as const;

function ensureVector2(value: BABYLON.Vector2 | readonly [number, number]): BABYLON.Vector2 {
  return value instanceof BABYLON.Vector2 ? value : BABYLON.Vector2.FromArray(value as readonly [number, number]);
}

export interface ReactionDiffusionUniforms {
  feed: number;
  kill: number;
  diffRateA: number;
  diffRateB: number;
  deltaT: number;
  brushRadius: number;
  brushStrength: number;
  noiseAmount: number;
  brushPosition: BABYLON.Vector2 | readonly [number, number];
}

export function setReactionDiffusionUniforms(material: BABYLON.ShaderMaterial, uniforms: Partial<ReactionDiffusionUniforms>): void {
  if (!uniforms) {
    return;
  }
  if (uniforms.feed !== undefined) {
    material.setFloat('uniforms_feed', uniforms.feed);
  }
  if (uniforms.kill !== undefined) {
    material.setFloat('uniforms_kill', uniforms.kill);
  }
  if (uniforms.diffRateA !== undefined) {
    material.setFloat('uniforms_diffRateA', uniforms.diffRateA);
  }
  if (uniforms.diffRateB !== undefined) {
    material.setFloat('uniforms_diffRateB', uniforms.diffRateB);
  }
  if (uniforms.deltaT !== undefined) {
    material.setFloat('uniforms_deltaT', uniforms.deltaT);
  }
  if (uniforms.brushRadius !== undefined) {
    material.setFloat('uniforms_brushRadius', uniforms.brushRadius);
  }
  if (uniforms.brushStrength !== undefined) {
    material.setFloat('uniforms_brushStrength', uniforms.brushStrength);
  }
  if (uniforms.noiseAmount !== undefined) {
    material.setFloat('uniforms_noiseAmount', uniforms.noiseAmount);
  }
  if (uniforms.brushPosition !== undefined) {
    material.setVector2('uniforms_brushPosition', ensureVector2(uniforms.brushPosition));
  }
}

export type ReactionDiffusionTextureName = 'state' | 'seed' | 'pass0Texture' | 'pass1Texture';
export interface ReactionDiffusionInputs {
  state: ShaderSource;
  seed: ShaderSource;
}

export interface ReactionDiffusionMaterialHandles {
  material: BABYLON.ShaderMaterial;
  setTexture(name: ReactionDiffusionTextureName, texture: BABYLON.BaseTexture): void;
  setTextureSampler(name: ReactionDiffusionTextureName, sampler: BABYLON.TextureSampler): void;
  setUniforms(uniforms: Partial<ReactionDiffusionUniforms>): void;
}

export interface ReactionDiffusionMaterialOptions {
  name?: string;
  passIndex?: number;
}

export function createReactionDiffusionMaterial(scene: BABYLON.Scene, options: ReactionDiffusionMaterialOptions = {}): ReactionDiffusionMaterialHandles {
  const passIndex = options.passIndex ?? 0;
  if (passIndex < 0 || passIndex >= 3) {
    throw new Error(`Invalid passIndex ${passIndex} for ReactionDiffusion. Expected 0 <= passIndex < 3.`);
  }
  const baseName = options.name ?? 'ReactionDiffusionMaterial';
  const shaderName = `${baseName}_pass${passIndex}`;
  // Register shaders in the WGSL store to enable preprocessor
  const vertexShaderName = `${shaderName}VertexShader`;
  const fragmentShaderName = `${shaderName}FragmentShader`;
  
  BABYLON.ShaderStore.ShadersStoreWGSL[vertexShaderName] = ReactionDiffusionVertexSource;
  BABYLON.ShaderStore.ShadersStoreWGSL[fragmentShaderName] = ReactionDiffusionFragmentSources[passIndex];
  
  const material = new BABYLON.ShaderMaterial(shaderName, scene, {
    vertex: shaderName,
    fragment: shaderName,
  }, {
    attributes: ['position', 'uv'],
    uniforms: ['uniforms_feed', 'uniforms_kill', 'uniforms_diffRateA', 'uniforms_diffRateB', 'uniforms_deltaT', 'uniforms_brushRadius', 'uniforms_brushStrength', 'uniforms_noiseAmount', 'uniforms_brushPosition'],
    samplers: ['state', 'seed', 'pass0Texture', 'pass1Texture'],
    samplerObjects: ['stateSampler', 'seedSampler', 'pass0Sampler', 'pass1Sampler'],
    shaderLanguage: BABYLON.ShaderLanguage.WGSL,
  });

  const samplerLookup = { 'state': 'stateSampler', 'seed': 'seedSampler', 'pass0Texture': 'pass0Sampler', 'pass1Texture': 'pass1Sampler' } as const;

  const handles: ReactionDiffusionMaterialHandles = {
    material,
    setTexture: (name, texture) => material.setTexture(name, texture),
    setTextureSampler: (name, sampler) => material.setTextureSampler(samplerLookup[name], sampler),
    setUniforms: (values) => setReactionDiffusionUniforms(material, values),
  };

  return handles;
}

export class ReactionDiffusionEffect extends CustomShaderEffect<ReactionDiffusionUniforms, ReactionDiffusionInputs> {
  effectName = 'ReactionDiffusion'

  constructor(engine: BABYLON.WebGPUEngine, inputs: ReactionDiffusionInputs, width = 1280, height = 720, sampleMode: 'nearest' | 'linear' = 'linear', precision: RenderPrecision = 'half_float') {
    super(engine, inputs, {
      factory: (sceneRef, options) => createReactionDiffusionMaterial(sceneRef, options),
      textureInputKeys: ['state', 'seed'],
      textureBindingKeys: ['state', 'seed', 'pass0Texture', 'pass1Texture'],
      passTextureSources: ReactionDiffusionPassTextureSources,
      passCount: 3,
      primaryTextureKey: 'state',
      width,
      height,
      materialName: 'ReactionDiffusionMaterial',
      sampleMode,
      precision,
    })
    this.setUniforms({
      feed: 0.055,
      kill: 0.062,
      diffRateA: 1.0,
      diffRateB: 0.5,
      deltaT: 1.0,
      brushRadius: 0.035,
      brushStrength: 0.85,
      noiseAmount: 0.02,
      brushPosition: [0.5, 0.5],
    });
  }

  override setSrcs(inputs: Partial<ReactionDiffusionInputs>): void {
    super.setSrcs(inputs);
  }

  override setUniforms(uniforms: { feed?: Dynamic<number>, kill?: Dynamic<number>, diffRateA?: Dynamic<number>, diffRateB?: Dynamic<number>, deltaT?: Dynamic<number>, brushRadius?: Dynamic<number>, brushStrength?: Dynamic<number>, noiseAmount?: Dynamic<number>, brushPosition?: Dynamic<BABYLON.Vector2 | readonly [number, number]> }): void {
    const record: ShaderUniforms = {};
    if (uniforms.feed !== undefined) {
      record['feed'] = uniforms.feed;
    }
    if (uniforms.kill !== undefined) {
      record['kill'] = uniforms.kill;
    }
    if (uniforms.diffRateA !== undefined) {
      record['diffRateA'] = uniforms.diffRateA;
    }
    if (uniforms.diffRateB !== undefined) {
      record['diffRateB'] = uniforms.diffRateB;
    }
    if (uniforms.deltaT !== undefined) {
      record['deltaT'] = uniforms.deltaT;
    }
    if (uniforms.brushRadius !== undefined) {
      record['brushRadius'] = uniforms.brushRadius;
    }
    if (uniforms.brushStrength !== undefined) {
      record['brushStrength'] = uniforms.brushStrength;
    }
    if (uniforms.noiseAmount !== undefined) {
      record['noiseAmount'] = uniforms.noiseAmount;
    }
    if (uniforms.brushPosition !== undefined) {
      record['brushPosition'] = uniforms.brushPosition;
    }
    super.setUniforms(record);
  }
}

