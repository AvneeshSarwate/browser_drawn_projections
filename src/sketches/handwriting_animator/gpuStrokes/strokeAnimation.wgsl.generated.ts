// Auto-generated by wgsl type generator. DO NOT EDIT.

import * as BABYLON from 'babylonjs';

import shaderSource from './strokeAnimation.wgsl?raw';

export interface StrokeAnimationLaunchConfig {
  strokeAIndex: number;
  strokeBIndex: number;
  interpolationT: number;
  totalDuration: number;
  elapsedTime: number;
  startPointX: number;
  startPointY: number;
  scale: number;
  isActive: number;
  phase: number;
  reserved1: number;
  reserved2: number;
}

export const StrokeAnimationLaunchConfigLayout = {
  size: 48,
  align: 4,
  members: [
  { name: 'strokeAIndex', offset: 0, size: 4, slot: 1 },
  { name: 'strokeBIndex', offset: 4, size: 4, slot: 1 },
  { name: 'interpolationT', offset: 8, size: 4, slot: 1 },
  { name: 'totalDuration', offset: 12, size: 4, slot: 1 },
  { name: 'elapsedTime', offset: 16, size: 4, slot: 1 },
  { name: 'startPointX', offset: 20, size: 4, slot: 1 },
  { name: 'startPointY', offset: 24, size: 4, slot: 1 },
  { name: 'scale', offset: 28, size: 4, slot: 1 },
  { name: 'isActive', offset: 32, size: 4, slot: 1 },
  { name: 'phase', offset: 36, size: 4, slot: 1 },
  { name: 'reserved1', offset: 40, size: 4, slot: 1 },
  { name: 'reserved2', offset: 44, size: 4, slot: 1 }
  ] as const,
} as const;

export function packStrokeAnimationLaunchConfig(target: Float32Array, floatOffset: number, value: StrokeAnimationLaunchConfig): void {
  let offset = floatOffset;
  offset = floatOffset + 0;
  target[offset] = value.strokeAIndex as number;
  offset = floatOffset + 1;
  target[offset] = value.strokeBIndex as number;
  offset = floatOffset + 2;
  target[offset] = value.interpolationT as number;
  offset = floatOffset + 3;
  target[offset] = value.totalDuration as number;
  offset = floatOffset + 4;
  target[offset] = value.elapsedTime as number;
  offset = floatOffset + 5;
  target[offset] = value.startPointX as number;
  offset = floatOffset + 6;
  target[offset] = value.startPointY as number;
  offset = floatOffset + 7;
  target[offset] = value.scale as number;
  offset = floatOffset + 8;
  target[offset] = value.isActive as number;
  offset = floatOffset + 9;
  target[offset] = value.phase as number;
  offset = floatOffset + 10;
  target[offset] = value.reserved1 as number;
  offset = floatOffset + 11;
  target[offset] = value.reserved2 as number;
}

export interface StrokeAnimationGlobalParams {
  time: number;
  canvasWidth: number;
  canvasHeight: number;
  maxAnimations: number;
  deltaTime: number;
  textureHeight: number;
  padding1: number;
  padding2: number;
}

export const StrokeAnimationGlobalParamsLayout = {
  size: 32,
  align: 4,
  members: [
  { name: 'time', offset: 0, size: 4, slot: 1 },
  { name: 'canvasWidth', offset: 4, size: 4, slot: 1 },
  { name: 'canvasHeight', offset: 8, size: 4, slot: 1 },
  { name: 'maxAnimations', offset: 12, size: 4, slot: 1 },
  { name: 'deltaTime', offset: 16, size: 4, slot: 1 },
  { name: 'textureHeight', offset: 20, size: 4, slot: 1 },
  { name: 'padding1', offset: 24, size: 4, slot: 1 },
  { name: 'padding2', offset: 28, size: 4, slot: 1 }
  ] as const,
} as const;

export function packStrokeAnimationGlobalParams(target: Float32Array, floatOffset: number, value: StrokeAnimationGlobalParams): void {
  let offset = floatOffset;
  offset = floatOffset + 0;
  target[offset] = value.time as number;
  offset = floatOffset + 1;
  target[offset] = value.canvasWidth as number;
  offset = floatOffset + 2;
  target[offset] = value.canvasHeight as number;
  offset = floatOffset + 3;
  target[offset] = value.maxAnimations as number;
  offset = floatOffset + 4;
  target[offset] = value.deltaTime as number;
  offset = floatOffset + 5;
  target[offset] = value.textureHeight as number;
  offset = floatOffset + 6;
  target[offset] = value.padding1 as number;
  offset = floatOffset + 7;
  target[offset] = value.padding2 as number;
}

const uniformLayout_globalParams = [
  { name: 'time', slot: 1 },
  { name: 'canvasWidth', slot: 1 },
  { name: 'canvasHeight', slot: 1 },
  { name: 'maxAnimations', slot: 1 },
  { name: 'deltaTime', slot: 1 },
  { name: 'textureHeight', slot: 1 },
  { name: 'padding1', slot: 1 },
  { name: 'padding2', slot: 1 }
] as const;

export interface GlobalParamsUniforms {
  time: number;
  canvasWidth: number;
  canvasHeight: number;
  maxAnimations: number;
  deltaTime: number;
  textureHeight: number;
  padding1: number;
  padding2: number;
}

export interface GlobalParamsUniformState {
  buffer: BABYLON.UniformBuffer;
  uniforms: GlobalParamsUniforms;
}

export function createUniformBuffer_globalParams(engine: BABYLON.WebGPUEngine, initial?: Partial<GlobalParamsUniforms>): GlobalParamsUniformState {
  const buffer = new BABYLON.UniformBuffer(engine);
  const uniforms: GlobalParamsUniforms = {
    time: 0,
    canvasWidth: 0,
    canvasHeight: 0,
    maxAnimations: 0,
    deltaTime: 0,
    textureHeight: 0,
    padding1: 0,
    padding2: 0,
  };
  for (const entry of uniformLayout_globalParams) {
    buffer.addUniform(entry.name, entry.slot);
  }
  if (initial) {
    updateUniformBuffer_globalParams({ buffer, uniforms }, initial);
  } else {
    buffer.update();
  }
  return { buffer, uniforms };
}

export function updateUniformBuffer_globalParams(state: GlobalParamsUniformState, updates: Partial<GlobalParamsUniforms>): void {
  let dirty = false;
  for (const entry of uniformLayout_globalParams) {
    const key = entry.name as keyof GlobalParamsUniforms;
    if (updates[key] === undefined) {
      continue;
    }
    dirty = true;
    const raw = updates[key]! as unknown;
    if (entry.slot > 1) {
      let arrayValue: Float32Array;
      if (raw instanceof Float32Array) {
        arrayValue = raw;
      } else if (Array.isArray(raw)) {
        arrayValue = new Float32Array(raw as number[]);
      } else if (typeof raw === "number") {
        arrayValue = new Float32Array(entry.slot);
        arrayValue[0] = raw;
      } else {
        arrayValue = new Float32Array(entry.slot);
      }
      state.uniforms[key] = arrayValue as any;
      state.buffer.updateUniform(entry.name, arrayValue, entry.slot);
    } else if (typeof raw === "boolean") {
      const numeric = raw ? 1 : 0;
      state.uniforms[key] = raw as any;
      state.buffer.updateUniform(entry.name, [numeric], entry.slot);
    } else {
      const numeric = typeof raw === "number" ? raw : 0;
      state.uniforms[key] = numeric as any;
      state.buffer.updateUniform(entry.name, [numeric], entry.slot);
    }
  }
  if (dirty) {
    state.buffer.update();
  }
}

export interface InstanceMatricesStorageState {
  buffer: BABYLON.StorageBuffer;
  data: Float32Array;
  capacity: number;
  floatsPerElement: number;
}

export function createStorageBuffer_instanceMatrices(engine: BABYLON.WebGPUEngine, capacity: number, options?: { initial?: number[][]; usage?: number; }): InstanceMatricesStorageState {
  const byteStride = 16;
  const floatsPerElement = byteStride / Float32Array.BYTES_PER_ELEMENT;
  const totalFloats = floatsPerElement * capacity;
  const data = new Float32Array(totalFloats);
  const usage = options?.usage ?? (BABYLON.Constants.BUFFER_CREATIONFLAG_STORAGE | BABYLON.Constants.BUFFER_CREATIONFLAG_WRITE);
  const buffer = new BABYLON.StorageBuffer(engine, byteStride * capacity, usage);
  if (options?.initial) {
    data.set(options.initial.flat().slice(0, totalFloats));
    buffer.update(data);
  }
  return { buffer, data, capacity, floatsPerElement };
}

export function writeStorageValue_instanceMatrices(state: InstanceMatricesStorageState, index: number, value: number[]): void {
  const offset = index * state.floatsPerElement;
  for (let i = 0; i < state.floatsPerElement; i++) {
    state.data[offset + i] = value[i] ?? 0;
  }
}

export function updateStorageBuffer_instanceMatrices(state: InstanceMatricesStorageState): void {
  state.buffer.update(state.data);
}

export interface LaunchConfigsStorageState {
  buffer: BABYLON.StorageBuffer;
  data: Float32Array;
  capacity: number;
  floatsPerElement: number;
}

export function createStorageBuffer_launchConfigs(engine: BABYLON.WebGPUEngine, capacity: number, options?: { initial?: StrokeAnimationLaunchConfig[]; usage?: number; }): LaunchConfigsStorageState {
  const byteStride = 48;
  const floatsPerElement = byteStride / Float32Array.BYTES_PER_ELEMENT;
  const totalFloats = floatsPerElement * capacity;
  const data = new Float32Array(totalFloats);
  const usage = options?.usage ?? (BABYLON.Constants.BUFFER_CREATIONFLAG_STORAGE | BABYLON.Constants.BUFFER_CREATIONFLAG_WRITE);
  const buffer = new BABYLON.StorageBuffer(engine, byteStride * capacity, usage);
  if (options?.initial) {
    options.initial.slice(0, capacity).forEach((value, index) => {
      packStrokeAnimationLaunchConfig(data, index * floatsPerElement, value);
    });
    buffer.update(data);
  }
  return { buffer, data, capacity, floatsPerElement };
}

export function writeStorageValue_launchConfigs(state: LaunchConfigsStorageState, index: number, value: StrokeAnimationLaunchConfig): void {
  const offset = index * state.floatsPerElement;
  packStrokeAnimationLaunchConfig(state.data, offset, value);
}

export function updateStorageBuffer_launchConfigs(state: LaunchConfigsStorageState): void {
  state.buffer.update(state.data);
}

const bindingLayout = {
    globalParams: { group: 0, binding: 2 },
    instanceMatrices: { group: 0, binding: 0 },
    launchConfigs: { group: 0, binding: 1 },
    strokeTexture: { group: 0, binding: 3 },
    strokeSampler: { group: 0, binding: 4 }
};

export interface ShaderBindings {
    globalParams: GlobalParamsUniformState;
    instanceMatrices: BABYLON.StorageBuffer;
    launchConfigs: BABYLON.StorageBuffer;
    strokeTexture: BABYLON.BaseTexture;
    strokeSampler: BABYLON.TextureSampler;
}

export interface ShaderState {
  shader: BABYLON.ComputeShader;
  bindings: ShaderBindings;
}

export function createShader(engine: BABYLON.WebGPUEngine, bindings: ShaderBindings, options?: { entryPoint?: string; source?: string; name?: string; }): ShaderState {
  const shader = new BABYLON.ComputeShader(options?.name ?? 'strokeAnimation', engine, { computeSource: options?.source ?? shaderSource }, {
    entryPoint: options?.entryPoint ?? 'main',
    bindingsMapping: bindingLayout,
  });
  shader.setUniformBuffer('globalParams', bindings.globalParams.buffer);
  shader.setStorageBuffer('instanceMatrices', bindings.instanceMatrices);
  shader.setStorageBuffer('launchConfigs', bindings.launchConfigs);
  shader.setTexture('strokeTexture', bindings.strokeTexture, false);
  shader.setTextureSampler('strokeSampler', bindings.strokeSampler);
  return { shader, bindings };
}

export function updateBindings(state: ShaderState, updates: Partial<ShaderBindings>): void {
  if (updates.globalParams !== undefined) {
    state.bindings.globalParams = updates.globalParams!;
    state.shader.setUniformBuffer('globalParams', updates.globalParams!.buffer);
  }
  if (updates.instanceMatrices !== undefined) {
    state.bindings.instanceMatrices = updates.instanceMatrices!;
    state.shader.setStorageBuffer('instanceMatrices', updates.instanceMatrices!);
  }
  if (updates.launchConfigs !== undefined) {
    state.bindings.launchConfigs = updates.launchConfigs!;
    state.shader.setStorageBuffer('launchConfigs', updates.launchConfigs!);
  }
  if (updates.strokeTexture !== undefined) {
    state.bindings.strokeTexture = updates.strokeTexture!;
    state.shader.setTexture('strokeTexture', updates.strokeTexture!, false);
  }
  if (updates.strokeSampler !== undefined) {
    state.bindings.strokeSampler = updates.strokeSampler!;
    state.shader.setTextureSampler('strokeSampler', updates.strokeSampler!);
  }
}

export const createUniformBuffer = createUniformBuffer_globalParams;
export const updateUniformBuffer = updateUniformBuffer_globalParams;