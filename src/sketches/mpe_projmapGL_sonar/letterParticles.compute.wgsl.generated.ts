// Auto-generated by wgsl type generator. DO NOT EDIT.

import * as BABYLON from 'babylonjs';

import shaderSource from './letterParticles.compute.wgsl?raw';

export interface LetterParticlesParticle {
  uv: Float32Array | readonly number[];
  pad: Float32Array | readonly number[];
  color: Float32Array | readonly number[];
}

export const LetterParticlesParticleLayout = {
  size: 32,
  align: 16,
  members: [
  { name: 'uv', offset: 0, size: 8, slot: 2 },
  { name: 'pad', offset: 8, size: 8, slot: 2 },
  { name: 'color', offset: 16, size: 16, slot: 4 }
  ] as const,
} as const;

export function packLetterParticlesParticle(target: Float32Array, floatOffset: number, value: LetterParticlesParticle): void {
  {
    const base = floatOffset + 0;
    const uvSource = value.uv as any;
    for (let i = 0; i < 2; i++) {
      const component = uvSource?.[i];
      target[base + i] = component !== undefined ? Number(component) : 0;
    }
  }
  {
    const base = floatOffset + 2;
    const padSource = value.pad as any;
    for (let i = 0; i < 2; i++) {
      const component = padSource?.[i];
      target[base + i] = component !== undefined ? Number(component) : 0;
    }
  }
  {
    const base = floatOffset + 4;
    const colorSource = value.color as any;
    for (let i = 0; i < 4; i++) {
      const component = colorSource?.[i];
      target[base + i] = component !== undefined ? Number(component) : 0;
    }
  }
}

export interface LetterParticlesCounter {
  value: number;
}

export const LetterParticlesCounterLayout = {
  size: 4,
  align: 4,
  members: [
  { name: 'value', offset: 0, size: 4, slot: 1 }
  ] as const,
} as const;

export function packLetterParticlesCounter(target: Float32Array, floatOffset: number, value: LetterParticlesCounter): void {
  const uintView = new Uint32Array(target.buffer);
  {
    const base = floatOffset + 0;
    const raw = value.value;
    uintView[base] = raw !== undefined ? Math.trunc(raw as number) >>> 0 : 0;
  }
}

export interface LetterParticlesCompactionSettings {
  alphaThreshold: number;
  maxParticles: number;
  texWidth: number;
  texHeight: number;
}

export const LetterParticlesCompactionSettingsLayout = {
  size: 16,
  align: 4,
  members: [
  { name: 'alphaThreshold', offset: 0, size: 4, slot: 1 },
  { name: 'maxParticles', offset: 4, size: 4, slot: 1 },
  { name: 'texWidth', offset: 8, size: 4, slot: 1 },
  { name: 'texHeight', offset: 12, size: 4, slot: 1 }
  ] as const,
} as const;

export function packLetterParticlesCompactionSettings(target: Float32Array, floatOffset: number, value: LetterParticlesCompactionSettings): void {
  const uintView = new Uint32Array(target.buffer);
  {
    const base = floatOffset + 0;
    const raw = value.alphaThreshold;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 1;
    const raw = value.maxParticles;
    uintView[base] = raw !== undefined ? Math.trunc(raw as number) >>> 0 : 0;
  }
  {
    const base = floatOffset + 2;
    const raw = value.texWidth;
    uintView[base] = raw !== undefined ? Math.trunc(raw as number) >>> 0 : 0;
  }
  {
    const base = floatOffset + 3;
    const raw = value.texHeight;
    uintView[base] = raw !== undefined ? Math.trunc(raw as number) >>> 0 : 0;
  }
}

const uniformLayout_settings = [
  { name: 'alphaThreshold', slot: 1 },
  { name: 'maxParticles', slot: 1 },
  { name: 'texWidth', slot: 1 },
  { name: 'texHeight', slot: 1 }
] as const;

export interface SettingsUniforms {
  alphaThreshold: number;
  maxParticles: number;
  texWidth: number;
  texHeight: number;
}

export interface SettingsUniformState {
  buffer: BABYLON.UniformBuffer;
  uniforms: SettingsUniforms;
}

export function createUniformBuffer_settings(engine: BABYLON.WebGPUEngine, initial?: Partial<SettingsUniforms>): SettingsUniformState {
  const buffer = new BABYLON.UniformBuffer(engine);
  const uniforms: SettingsUniforms = {
    alphaThreshold: 0,
    maxParticles: 0,
    texWidth: 0,
    texHeight: 0,
  };
  for (const entry of uniformLayout_settings) {
    buffer.addUniform(entry.name, entry.slot);
  }
  if (initial) {
    updateUniformBuffer_settings({ buffer, uniforms }, initial);
  } else {
    buffer.update();
  }
  return { buffer, uniforms };
}

export function updateUniformBuffer_settings(state: SettingsUniformState, updates: Partial<SettingsUniforms>): void {
  let dirty = false;
  if (updates.alphaThreshold !== undefined) {
    dirty = true;
    const raw = updates.alphaThreshold! as any;
    const numeric = raw !== undefined ? Number(raw) : 0;
    state.uniforms.alphaThreshold = numeric;
    const bufferView = new Float32Array(1);
    bufferView[0] = numeric;
    state.buffer.updateUniform('alphaThreshold', bufferView, 1);
  }
  if (updates.maxParticles !== undefined) {
    dirty = true;
    const raw = updates.maxParticles! as any;
    const numeric = raw !== undefined ? Math.trunc(raw as number) >>> 0 : 0;
    const scratch = new ArrayBuffer(4);
    new Uint32Array(scratch)[0] = numeric;
    state.uniforms.maxParticles = numeric;
    state.buffer.updateUniform('maxParticles', new Float32Array(scratch), 1);
  }
  if (updates.texWidth !== undefined) {
    dirty = true;
    const raw = updates.texWidth! as any;
    const numeric = raw !== undefined ? Math.trunc(raw as number) >>> 0 : 0;
    const scratch = new ArrayBuffer(4);
    new Uint32Array(scratch)[0] = numeric;
    state.uniforms.texWidth = numeric;
    state.buffer.updateUniform('texWidth', new Float32Array(scratch), 1);
  }
  if (updates.texHeight !== undefined) {
    dirty = true;
    const raw = updates.texHeight! as any;
    const numeric = raw !== undefined ? Math.trunc(raw as number) >>> 0 : 0;
    const scratch = new ArrayBuffer(4);
    new Uint32Array(scratch)[0] = numeric;
    state.uniforms.texHeight = numeric;
    state.buffer.updateUniform('texHeight', new Float32Array(scratch), 1);
  }
  if (dirty) {
    state.buffer.update();
  }
}

export interface ParticlesStorageState {
  buffer: BABYLON.StorageBuffer;
  data: Float32Array;
  capacity: number;
  floatsPerElement: number;
}

export function createStorageBuffer_particles(engine: BABYLON.WebGPUEngine, capacity: number, options?: { initial?: LetterParticlesParticle[]; usage?: number; }): ParticlesStorageState {
  const byteStride = 32;
  const floatsPerElement = byteStride / Float32Array.BYTES_PER_ELEMENT;
  const totalFloats = floatsPerElement * capacity;
  const data = new Float32Array(totalFloats);
  const usage = options?.usage ?? (BABYLON.Constants.BUFFER_CREATIONFLAG_STORAGE | BABYLON.Constants.BUFFER_CREATIONFLAG_WRITE);
  const buffer = new BABYLON.StorageBuffer(engine, byteStride * capacity, usage);
  if (options?.initial) {
    options.initial.slice(0, capacity).forEach((value, index) => {
      packLetterParticlesParticle(data, index * floatsPerElement, value);
    });
    buffer.update(data);
  }
  return { buffer, data, capacity, floatsPerElement };
}

export function writeStorageValue_particles(state: ParticlesStorageState, index: number, value: LetterParticlesParticle): void {
  const offset = index * state.floatsPerElement;
  packLetterParticlesParticle(state.data, offset, value);
}

export function updateStorageBuffer_particles(state: ParticlesStorageState): void {
  state.buffer.update(state.data);
}

export interface CounterStorageState {
  buffer: BABYLON.StorageBuffer;
  data: Float32Array;
  capacity: number;
  floatsPerElement: number;
}

export function createStorageBuffer_counter(engine: BABYLON.WebGPUEngine, capacity: number, options?: { initial?: number[][]; usage?: number; }): CounterStorageState {
  const byteStride = 4;
  const floatsPerElement = byteStride / Float32Array.BYTES_PER_ELEMENT;
  const totalFloats = floatsPerElement * capacity;
  const data = new Float32Array(totalFloats);
  const usage = options?.usage ?? (BABYLON.Constants.BUFFER_CREATIONFLAG_STORAGE | BABYLON.Constants.BUFFER_CREATIONFLAG_WRITE);
  const buffer = new BABYLON.StorageBuffer(engine, byteStride * capacity, usage);
  if (options?.initial) {
    data.set(options.initial.flat().slice(0, totalFloats));
    buffer.update(data);
  }
  return { buffer, data, capacity, floatsPerElement };
}

export function writeStorageValue_counter(state: CounterStorageState, index: number, value: number[]): void {
  const offset = index * state.floatsPerElement;
  for (let i = 0; i < state.floatsPerElement; i++) {
    state.data[offset + i] = value[i] ?? 0;
  }
}

export function updateStorageBuffer_counter(state: CounterStorageState): void {
  state.buffer.update(state.data);
}

const bindingLayout = {
    settings: { group: 0, binding: 3 },
    particles: { group: 0, binding: 1 },
    counter: { group: 0, binding: 2 },
    inputTex: { group: 0, binding: 0 }
};

export interface ShaderBindings {
    settings: SettingsUniformState;
    particles: BABYLON.StorageBuffer;
    counter: BABYLON.StorageBuffer;
    inputTex: BABYLON.BaseTexture;
}

export interface ShaderState {
  shader: BABYLON.ComputeShader;
  bindings: ShaderBindings;
}

export function createShader(engine: BABYLON.WebGPUEngine, bindings: ShaderBindings, options?: { entryPoint?: string; source?: string; name?: string; }): ShaderState {
  const shader = new BABYLON.ComputeShader(options?.name ?? 'letterParticles', engine, { computeSource: options?.source ?? shaderSource }, {
    entryPoint: options?.entryPoint ?? 'main',
    bindingsMapping: bindingLayout,
  });
  shader.setUniformBuffer('settings', bindings.settings.buffer);
  shader.setStorageBuffer('particles', bindings.particles);
  shader.setStorageBuffer('counter', bindings.counter);
  shader.setTexture('inputTex', bindings.inputTex, false);
  return { shader, bindings };
}

export function updateBindings(state: ShaderState, updates: Partial<ShaderBindings>): void {
  if (updates.settings !== undefined) {
    state.bindings.settings = updates.settings!;
    state.shader.setUniformBuffer('settings', updates.settings!.buffer);
  }
  if (updates.particles !== undefined) {
    state.bindings.particles = updates.particles!;
    state.shader.setStorageBuffer('particles', updates.particles!);
  }
  if (updates.counter !== undefined) {
    state.bindings.counter = updates.counter!;
    state.shader.setStorageBuffer('counter', updates.counter!);
  }
  if (updates.inputTex !== undefined) {
    state.bindings.inputTex = updates.inputTex!;
    state.shader.setTexture('inputTex', updates.inputTex!, false);
  }
}

export const createUniformBuffer = createUniformBuffer_settings;
export const updateUniformBuffer = updateUniformBuffer_settings;