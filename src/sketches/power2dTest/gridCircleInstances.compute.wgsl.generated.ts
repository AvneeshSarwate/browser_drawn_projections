// Auto-generated by wgsl type generator. DO NOT EDIT.

import * as BABYLON from 'babylonjs';

import shaderSource from './gridCircleInstances.compute.wgsl?raw';

export interface GridCircleInstancesGridCircleSettings {
  time: number;
  speed: number;
  centerX: number;
  centerY: number;
  gridExtent: number;
  circleRadius: number;
  quadScale: number;
  gridSize: number;
  instanceCount: number;
}

export const GridCircleInstancesGridCircleSettingsLayout = {
  size: 36,
  align: 4,
  members: [
  { name: 'time', offset: 0, size: 4, slot: 1 },
  { name: 'speed', offset: 4, size: 4, slot: 1 },
  { name: 'centerX', offset: 8, size: 4, slot: 1 },
  { name: 'centerY', offset: 12, size: 4, slot: 1 },
  { name: 'gridExtent', offset: 16, size: 4, slot: 1 },
  { name: 'circleRadius', offset: 20, size: 4, slot: 1 },
  { name: 'quadScale', offset: 24, size: 4, slot: 1 },
  { name: 'gridSize', offset: 28, size: 4, slot: 1 },
  { name: 'instanceCount', offset: 32, size: 4, slot: 1 }
  ] as const,
} as const;

export function packGridCircleInstancesGridCircleSettings(target: Float32Array, floatOffset: number, value: GridCircleInstancesGridCircleSettings): void {
  const uintView = new Uint32Array(target.buffer);
  {
    const base = floatOffset + 0;
    const raw = value.time;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 1;
    const raw = value.speed;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 2;
    const raw = value.centerX;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 3;
    const raw = value.centerY;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 4;
    const raw = value.gridExtent;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 5;
    const raw = value.circleRadius;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 6;
    const raw = value.quadScale;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 7;
    const raw = value.gridSize;
    uintView[base] = raw !== undefined ? Math.trunc(raw as number) >>> 0 : 0;
  }
  {
    const base = floatOffset + 8;
    const raw = value.instanceCount;
    uintView[base] = raw !== undefined ? Math.trunc(raw as number) >>> 0 : 0;
  }
}

const uniformLayout_settings = [
  { name: 'time', slot: 1 },
  { name: 'speed', slot: 1 },
  { name: 'centerX', slot: 1 },
  { name: 'centerY', slot: 1 },
  { name: 'gridExtent', slot: 1 },
  { name: 'circleRadius', slot: 1 },
  { name: 'quadScale', slot: 1 },
  { name: 'gridSize', slot: 1 },
  { name: 'instanceCount', slot: 1 }
] as const;

export interface SettingsUniforms {
  time: number;
  speed: number;
  centerX: number;
  centerY: number;
  gridExtent: number;
  circleRadius: number;
  quadScale: number;
  gridSize: number;
  instanceCount: number;
}

export interface SettingsUniformState {
  buffer: BABYLON.UniformBuffer;
  uniforms: SettingsUniforms;
}

export function createUniformBuffer_settings(engine: BABYLON.WebGPUEngine, initial?: Partial<SettingsUniforms>): SettingsUniformState {
  const buffer = new BABYLON.UniformBuffer(engine);
  const uniforms: SettingsUniforms = {
    time: 0,
    speed: 0,
    centerX: 0,
    centerY: 0,
    gridExtent: 0,
    circleRadius: 0,
    quadScale: 0,
    gridSize: 0,
    instanceCount: 0,
  };
  for (const entry of uniformLayout_settings) {
    buffer.addUniform(entry.name, entry.slot);
  }
  if (initial) {
    updateUniformBuffer_settings({ buffer, uniforms }, initial);
  } else {
    buffer.update();
  }
  return { buffer, uniforms };
}

export function updateUniformBuffer_settings(state: SettingsUniformState, updates: Partial<SettingsUniforms>): void {
  let dirty = false;
  if (updates.time !== undefined) {
    dirty = true;
    const raw = updates.time! as any;
    const numeric = raw !== undefined ? Number(raw) : 0;
    state.uniforms.time = numeric;
    const bufferView = new Float32Array(1);
    bufferView[0] = numeric;
    state.buffer.updateUniform('time', bufferView, 1);
  }
  if (updates.speed !== undefined) {
    dirty = true;
    const raw = updates.speed! as any;
    const numeric = raw !== undefined ? Number(raw) : 0;
    state.uniforms.speed = numeric;
    const bufferView = new Float32Array(1);
    bufferView[0] = numeric;
    state.buffer.updateUniform('speed', bufferView, 1);
  }
  if (updates.centerX !== undefined) {
    dirty = true;
    const raw = updates.centerX! as any;
    const numeric = raw !== undefined ? Number(raw) : 0;
    state.uniforms.centerX = numeric;
    const bufferView = new Float32Array(1);
    bufferView[0] = numeric;
    state.buffer.updateUniform('centerX', bufferView, 1);
  }
  if (updates.centerY !== undefined) {
    dirty = true;
    const raw = updates.centerY! as any;
    const numeric = raw !== undefined ? Number(raw) : 0;
    state.uniforms.centerY = numeric;
    const bufferView = new Float32Array(1);
    bufferView[0] = numeric;
    state.buffer.updateUniform('centerY', bufferView, 1);
  }
  if (updates.gridExtent !== undefined) {
    dirty = true;
    const raw = updates.gridExtent! as any;
    const numeric = raw !== undefined ? Number(raw) : 0;
    state.uniforms.gridExtent = numeric;
    const bufferView = new Float32Array(1);
    bufferView[0] = numeric;
    state.buffer.updateUniform('gridExtent', bufferView, 1);
  }
  if (updates.circleRadius !== undefined) {
    dirty = true;
    const raw = updates.circleRadius! as any;
    const numeric = raw !== undefined ? Number(raw) : 0;
    state.uniforms.circleRadius = numeric;
    const bufferView = new Float32Array(1);
    bufferView[0] = numeric;
    state.buffer.updateUniform('circleRadius', bufferView, 1);
  }
  if (updates.quadScale !== undefined) {
    dirty = true;
    const raw = updates.quadScale! as any;
    const numeric = raw !== undefined ? Number(raw) : 0;
    state.uniforms.quadScale = numeric;
    const bufferView = new Float32Array(1);
    bufferView[0] = numeric;
    state.buffer.updateUniform('quadScale', bufferView, 1);
  }
  if (updates.gridSize !== undefined) {
    dirty = true;
    const raw = updates.gridSize! as any;
    const numeric = raw !== undefined ? Math.trunc(raw as number) >>> 0 : 0;
    const scratch = new ArrayBuffer(4);
    new Uint32Array(scratch)[0] = numeric;
    state.uniforms.gridSize = numeric;
    state.buffer.updateUniform('gridSize', new Float32Array(scratch), 1);
  }
  if (updates.instanceCount !== undefined) {
    dirty = true;
    const raw = updates.instanceCount! as any;
    const numeric = raw !== undefined ? Math.trunc(raw as number) >>> 0 : 0;
    const scratch = new ArrayBuffer(4);
    new Uint32Array(scratch)[0] = numeric;
    state.uniforms.instanceCount = numeric;
    state.buffer.updateUniform('instanceCount', new Float32Array(scratch), 1);
  }
  if (dirty) {
    state.buffer.update();
  }
}

export interface InstanceDataStorageState {
  buffer: BABYLON.StorageBuffer;
  data: Float32Array;
  capacity: number;
  floatsPerElement: number;
}

export function createStorageBuffer_instanceData(engine: BABYLON.WebGPUEngine, capacity: number, options?: { initial?: number[][]; usage?: number; }): InstanceDataStorageState {
  const byteStride = 4;
  const floatsPerElement = byteStride / Float32Array.BYTES_PER_ELEMENT;
  const totalFloats = floatsPerElement * capacity;
  const data = new Float32Array(totalFloats);
  const usage = options?.usage ?? (BABYLON.Constants.BUFFER_CREATIONFLAG_STORAGE | BABYLON.Constants.BUFFER_CREATIONFLAG_WRITE);
  const buffer = new BABYLON.StorageBuffer(engine, byteStride * capacity, usage);
  if (options?.initial) {
    data.set(options.initial.flat().slice(0, totalFloats));
    buffer.update(data);
  }
  return { buffer, data, capacity, floatsPerElement };
}

export function writeStorageValue_instanceData(state: InstanceDataStorageState, index: number, value: number[]): void {
  const offset = index * state.floatsPerElement;
  for (let i = 0; i < state.floatsPerElement; i++) {
    state.data[offset + i] = value[i] ?? 0;
  }
}

export function updateStorageBuffer_instanceData(state: InstanceDataStorageState): void {
  state.buffer.update(state.data);
}

const bindingLayout = {
    settings: { group: 0, binding: 0 },
    instanceData: { group: 0, binding: 1 }
};

export interface ShaderBindings {
    settings: SettingsUniformState;
    instanceData: BABYLON.StorageBuffer;
}

export interface ShaderState {
  shader: BABYLON.ComputeShader;
  bindings: ShaderBindings;
}

export function createShader(engine: BABYLON.WebGPUEngine, bindings: ShaderBindings, options?: { entryPoint?: string; source?: string; name?: string; }): ShaderState {
  const shader = new BABYLON.ComputeShader(options?.name ?? 'gridCircleInstances', engine, { computeSource: options?.source ?? shaderSource }, {
    entryPoint: options?.entryPoint ?? 'main',
    bindingsMapping: bindingLayout,
  });
  shader.setUniformBuffer('settings', bindings.settings.buffer);
  shader.setStorageBuffer('instanceData', bindings.instanceData);
  return { shader, bindings };
}

export function updateBindings(state: ShaderState, updates: Partial<ShaderBindings>): void {
  if (updates.settings !== undefined) {
    state.bindings.settings = updates.settings!;
    state.shader.setUniformBuffer('settings', updates.settings!.buffer);
  }
  if (updates.instanceData !== undefined) {
    state.bindings.instanceData = updates.instanceData!;
    state.shader.setStorageBuffer('instanceData', updates.instanceData!);
  }
}

export const createUniformBuffer = createUniformBuffer_settings;
export const updateUniformBuffer = updateUniformBuffer_settings;