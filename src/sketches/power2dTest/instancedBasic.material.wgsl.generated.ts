// Auto-generated by power2d material generator. DO NOT EDIT.
import * as BABYLON from 'babylonjs';

export const InstancedBasicVertexSource = `// Auto-generated by power2d material generator. DO NOT EDIT.
attribute position: vec3<f32>;
attribute uv: vec2<f32>;
attribute inst_offset: vec2<f32>;
attribute inst_scale: f32;
attribute inst_rotation: f32;
attribute inst_tint: vec3<f32>;
attribute inst_instanceIndex: f32;
varying vUV: vec2<f32>;
varying vInst_offset: vec2<f32>;
varying vInst_scale: f32;
varying vInst_rotation: f32;
varying vInst_tint: vec3<f32>;
varying vInst_instanceIndex: f32;
uniform uniforms_time: f32;
uniform uniforms_color: vec3f;
uniform power2d_canvasWidth: f32;
uniform power2d_canvasHeight: f32;

struct InstancedBasicUniforms {
  time: f32,
  color: vec3f,
};

struct InstancedBasicInstance {
  offset: vec2f,
  scale: f32,
  rotation: f32,
  tint: vec3f,
  instanceIndex: f32,
};

fn vertShader(
  position: vec2f,
  uv: vec2f,
  uniforms: InstancedBasicUniforms,
  inst: InstancedBasicInstance,
) -> vec2f {
  let c = cos(inst.rotation);
  let s = sin(inst.rotation);
  let rotated = vec2f(
    position.x * c - position.y * s,
    position.x * s + position.y * c
  );
  return inst.offset + rotated * inst.scale;
}

fn fragShader(
  uv: vec2f,
  uniforms: InstancedBasicUniforms,
  inst: InstancedBasicInstance,
) -> vec4f {
  let pulse = 0.5 + 0.5 * sin(uniforms.time * 2.0 + uv.x * 3.14159 + inst.instanceIndex * 0.001);
  let color = uniforms.color * inst.tint * pulse;
  return vec4f(color, 1.0);
}

fn load_InstancedBasicUniforms() -> InstancedBasicUniforms {
  return InstancedBasicUniforms(
  uniforms.uniforms_time,
  uniforms.uniforms_color
  );
}

fn load_InstancedBasicInstance_vertex() -> InstancedBasicInstance {
  return InstancedBasicInstance(
  vertexInputs.inst_offset,
  vertexInputs.inst_scale,
  vertexInputs.inst_rotation,
  vertexInputs.inst_tint,
  vertexInputs.inst_instanceIndex
  );
}

fn power2d_pixelToNDC(pixel: vec2f) -> vec4f {
  let ndcX = (pixel.x / uniforms.power2d_canvasWidth) * 2.0 - 1.0;
  let ndcY = -((pixel.y / uniforms.power2d_canvasHeight) * 2.0 - 1.0);
  return vec4f(ndcX, ndcY, 0.0, 1.0);
}

#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs) -> FragmentInputs {
#define CUSTOM_VERTEX_MAIN_BEGIN
  let uniformsValue = load_InstancedBasicUniforms();
  let instValue = load_InstancedBasicInstance_vertex();
  let pixelPos = vec2f(vertexInputs.position.x, vertexInputs.position.y);
  let uv = vertexInputs.uv;
  let adjustedPixelPos = vertShader(pixelPos, uv, uniformsValue, instValue);
  vertexOutputs.position = power2d_pixelToNDC(adjustedPixelPos);
  vertexOutputs.vUV = uv;
  vertexOutputs.vInst_offset = vertexInputs.inst_offset;
  vertexOutputs.vInst_scale = vertexInputs.inst_scale;
  vertexOutputs.vInst_rotation = vertexInputs.inst_rotation;
  vertexOutputs.vInst_tint = vertexInputs.inst_tint;
  vertexOutputs.vInst_instanceIndex = vertexInputs.inst_instanceIndex;
#define CUSTOM_VERTEX_MAIN_END
}

`;
export const InstancedBasicFragmentSource = `// Auto-generated by power2d material generator. DO NOT EDIT.
varying vUV: vec2<f32>;
varying vInst_offset: vec2<f32>;
varying vInst_scale: f32;
varying vInst_rotation: f32;
varying vInst_tint: vec3<f32>;
varying vInst_instanceIndex: f32;
uniform uniforms_time: f32;
uniform uniforms_color: vec3f;
uniform power2d_canvasWidth: f32;
uniform power2d_canvasHeight: f32;

struct InstancedBasicUniforms {
  time: f32,
  color: vec3f,
};

struct InstancedBasicInstance {
  offset: vec2f,
  scale: f32,
  rotation: f32,
  tint: vec3f,
  instanceIndex: f32,
};

fn vertShader(
  position: vec2f,
  uv: vec2f,
  uniforms: InstancedBasicUniforms,
  inst: InstancedBasicInstance,
) -> vec2f {
  let c = cos(inst.rotation);
  let s = sin(inst.rotation);
  let rotated = vec2f(
    position.x * c - position.y * s,
    position.x * s + position.y * c
  );
  return inst.offset + rotated * inst.scale;
}

fn fragShader(
  uv: vec2f,
  uniforms: InstancedBasicUniforms,
  inst: InstancedBasicInstance,
) -> vec4f {
  let pulse = 0.5 + 0.5 * sin(uniforms.time * 2.0 + uv.x * 3.14159 + inst.instanceIndex * 0.001);
  let color = uniforms.color * inst.tint * pulse;
  return vec4f(color, 1.0);
}

fn load_InstancedBasicUniforms() -> InstancedBasicUniforms {
  return InstancedBasicUniforms(
  uniforms.uniforms_time,
  uniforms.uniforms_color
  );
}

fn load_InstancedBasicInstance_fragment() -> InstancedBasicInstance {
  return InstancedBasicInstance(
  fragmentInputs.vInst_offset,
  fragmentInputs.vInst_scale,
  fragmentInputs.vInst_rotation,
  fragmentInputs.vInst_tint,
  fragmentInputs.vInst_instanceIndex
  );
}

#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs) -> FragmentOutputs {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
  let uv = fragmentInputs.vUV;
  let uniformsValue = load_InstancedBasicUniforms();
  let instValue = load_InstancedBasicInstance_fragment();
  let color = fragShader(uv, uniformsValue, instValue);
  fragmentOutputs.color = color;
#define CUSTOM_FRAGMENT_MAIN_END
}

`;

function ensureVector3(value: BABYLON.Vector3 | readonly [number, number, number]): BABYLON.Vector3 {
  return value instanceof BABYLON.Vector3 ? value : BABYLON.Vector3.FromArray(value as readonly [number, number, number]);
}

export interface InstancedBasicUniforms {
  time: number;
  color: BABYLON.Vector3 | readonly [number, number, number];
}

export const InstancedBasicUniformDefaults: InstancedBasicUniforms = {
  time: 0,
  color: [0, 0, 0],
};

export const InstancedBasicUniformMeta = [
  {
    name: 'time',
    kind: 'f32',
    bindingName: 'uniforms_time',
  },
  {
    name: 'color',
    kind: 'vec3f',
    bindingName: 'uniforms_color',
  },
] as const;

export function setInstancedBasicUniforms(material: BABYLON.ShaderMaterial, uniforms: Partial<InstancedBasicUniforms>): void {
  if (!uniforms) {
    return;
  }
  if (uniforms.time !== undefined) {
    material.setFloat('uniforms_time', uniforms.time);
  }
  if (uniforms.color !== undefined) {
    material.setVector3('uniforms_color', ensureVector3(uniforms.color));
  }
}

export type InstancedBasicTextureName = never;
export const InstancedBasicTextureNames = [] as const;

export interface InstancedBasicInstance {
  offset: readonly [number, number];
  scale: number;
  rotation: number;
  tint: readonly [number, number, number];
  instanceIndex: number;
}

export interface InstanceAttrLayout<I> {
  size: number;
  members: Array<{
    name: keyof I;
    offset: number;
    floatCount: number;
  }>;
}

export const InstancedBasicInstanceAttrLayout: InstanceAttrLayout<InstancedBasicInstance> = {
  size: 8,
  members: [
    { name: 'offset', offset: 0, floatCount: 2 },
    { name: 'scale', offset: 2, floatCount: 1 },
    { name: 'rotation', offset: 3, floatCount: 1 },
    { name: 'tint', offset: 4, floatCount: 3 },
    { name: 'instanceIndex', offset: 7, floatCount: 1 },
  ],
};

export interface InstancedBasicMaterialDef {
  readonly uniformType: InstancedBasicUniforms;
  readonly textureNames: readonly never[];
  readonly vertexSource: string;
  readonly fragmentSource: string;
  readonly uniformMeta: typeof InstancedBasicUniformMeta;
  readonly uniformDefaults: InstancedBasicUniforms;
  readonly instanceAttrLayout: InstanceAttrLayout<InstancedBasicInstance>;
  readonly createMaterial: (scene: BABYLON.Scene, name?: string) => InstancedBasicMaterialInstance;
}

export interface InstancedBasicMaterialInstance {
  material: BABYLON.ShaderMaterial;
  setUniforms(uniforms: Partial<InstancedBasicUniforms>): void;
  setTexture(name: InstancedBasicTextureName, texture: BABYLON.BaseTexture): void;
  setCanvasSize(width: number, height: number): void;
  dispose(): void;
}

export function createInstancedBasicMaterial(scene: BABYLON.Scene, name: string = 'InstancedBasicMaterial'): InstancedBasicMaterialInstance {
  const vertexShaderName = `${name}VertexShader`;
  const fragmentShaderName = `${name}FragmentShader`;

  BABYLON.ShaderStore.ShadersStoreWGSL[vertexShaderName] = InstancedBasicVertexSource;
  BABYLON.ShaderStore.ShadersStoreWGSL[fragmentShaderName] = InstancedBasicFragmentSource;

  const material = new BABYLON.ShaderMaterial(name, scene, {
    vertex: name,
    fragment: name,
  }, {
    attributes: ['position', 'uv', 'inst_offset', 'inst_scale', 'inst_rotation', 'inst_tint', 'inst_instanceIndex'],
    uniforms: ['uniforms_time', 'uniforms_color', 'power2d_canvasWidth', 'power2d_canvasHeight'],
    samplers: [],
    samplerObjects: [],
    shaderLanguage: BABYLON.ShaderLanguage.WGSL,
  });

  setInstancedBasicUniforms(material, InstancedBasicUniformDefaults);
  material.disableDepthWrite = true;
  material.depthFunction = BABYLON.Constants.ALWAYS;
  material.backFaceCulling = false;
  material.alphaMode = BABYLON.Engine.ALPHA_COMBINE;

  const handles: InstancedBasicMaterialInstance = {
    material,
    setUniforms: (uniforms) => setInstancedBasicUniforms(material, uniforms),
    setTexture: (name, texture) => material.setTexture(name, texture),
    setCanvasSize: (width, height) => {
      material.setFloat('power2d_canvasWidth', width);
      material.setFloat('power2d_canvasHeight', height);
    },
    dispose: () => {
      material.dispose(true, false);
      delete BABYLON.ShaderStore.ShadersStoreWGSL[vertexShaderName];
      delete BABYLON.ShaderStore.ShadersStoreWGSL[fragmentShaderName];
    },
  };

  return handles;
}

export const InstancedBasicMaterial: InstancedBasicMaterialDef = {
  uniformType: undefined as unknown as InstancedBasicUniforms,
  textureNames: InstancedBasicTextureNames,
  vertexSource: InstancedBasicVertexSource,
  fragmentSource: InstancedBasicFragmentSource,
  uniformMeta: InstancedBasicUniformMeta,
  uniformDefaults: InstancedBasicUniformDefaults,
  instanceAttrLayout: InstancedBasicInstanceAttrLayout,
  createMaterial: createInstancedBasicMaterial,
};

export default InstancedBasicMaterial;
