// Auto-generated by power2d stroke material generator. DO NOT EDIT.
import * as BABYLON from 'babylonjs';

export const RunnerStrokeVertexSource = `// Auto-generated by power2d stroke material generator. DO NOT EDIT.
attribute position: vec3<f32>;
attribute uv: vec2<f32>;
attribute strokeNormal: vec2<f32>;
attribute strokeSide: f32;
attribute strokeArcLength: f32;
attribute strokeNormalizedArc: f32;
attribute strokeMiterFactor: f32;
varying vUV: vec2<f32>;
varying vArcLength: f32;
varying vNormalizedArc: f32;
uniform uniforms_time: f32;
uniform uniforms_speed: f32;
uniform uniforms_segmentLength: f32;
uniform uniforms_feather: f32;
uniform power2d_canvasWidth: f32;
uniform power2d_canvasHeight: f32;
uniform power2d_strokeThickness: f32;

struct RunnerStrokeUniforms {
  time: f32,
  speed: f32,
  segmentLength: f32,
  feather: f32,
};

fn strokeVertShader(
  centerPos: vec2f,
  normal: vec2f,
  side: f32,
  arcLength: f32,
  normalizedArc: f32,
  miterFactor: f32,
  thickness: f32,
  uniforms: RunnerStrokeUniforms,
) -> vec2f {
  return centerPos + normal * side * (thickness * 0.5) * miterFactor;
}

fn strokeFragShader(
  uv: vec2f,
  arcLength: f32,
  normalizedArc: f32,
  uniforms: RunnerStrokeUniforms,
) -> vec4f {
  let head = fract(uniforms.time * uniforms.speed);
  let dist = abs(normalizedArc - head);
  let wrappedDist = min(dist, 1.0 - dist);
  let seg = max(uniforms.segmentLength, 0.001);
  let feather = max(uniforms.feather, 0.0001);
  let edge0 = max(seg - feather, 0.0);
  let falloff = smoothstep(edge0, seg, wrappedDist);
  let alpha = 1.0 - falloff;
  // Premultiplied alpha avoids MSAA fringe because RGB goes to 0 as coverage fades.
  return vec4f(1.0, 1.0, 1.0, 1.0) * alpha;
}

fn load_RunnerStrokeUniforms() -> RunnerStrokeUniforms {
  return RunnerStrokeUniforms(
  uniforms.uniforms_time,
  uniforms.uniforms_speed,
  uniforms.uniforms_segmentLength,
  uniforms.uniforms_feather
  );
}

fn power2d_pixelToNDC(pixel: vec2f) -> vec4f {
  let ndcX = (pixel.x / uniforms.power2d_canvasWidth) * 2.0 - 1.0;
  let ndcY = -((pixel.y / uniforms.power2d_canvasHeight) * 2.0 - 1.0);
  return vec4f(ndcX, ndcY, 0.0, 1.0);
}

#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs) -> FragmentInputs {
#define CUSTOM_VERTEX_MAIN_BEGIN
  let uniformsValue = load_RunnerStrokeUniforms();
  let centerPos = vec2f(vertexInputs.position.x, vertexInputs.position.y);
  let normal = vertexInputs.strokeNormal;
  let side = vertexInputs.strokeSide;
  let arcLength = vertexInputs.strokeArcLength;
  let normalizedArc = vertexInputs.strokeNormalizedArc;
  let miterFactor = vertexInputs.strokeMiterFactor;
  let thickness = uniforms.power2d_strokeThickness;
  let uv = vertexInputs.uv;
  let adjustedPixelPos = strokeVertShader(centerPos, normal, side, arcLength, normalizedArc, miterFactor, thickness, uniformsValue);
  vertexOutputs.position = power2d_pixelToNDC(adjustedPixelPos);
  vertexOutputs.vUV = uv;
  vertexOutputs.vArcLength = arcLength;
  vertexOutputs.vNormalizedArc = normalizedArc;
#define CUSTOM_VERTEX_MAIN_END
}

`;
export const RunnerStrokeFragmentSource = `// Auto-generated by power2d stroke material generator. DO NOT EDIT.
varying vUV: vec2<f32>;
varying vArcLength: f32;
varying vNormalizedArc: f32;
uniform uniforms_time: f32;
uniform uniforms_speed: f32;
uniform uniforms_segmentLength: f32;
uniform uniforms_feather: f32;
uniform power2d_canvasWidth: f32;
uniform power2d_canvasHeight: f32;
uniform power2d_strokeThickness: f32;

struct RunnerStrokeUniforms {
  time: f32,
  speed: f32,
  segmentLength: f32,
  feather: f32,
};

fn strokeVertShader(
  centerPos: vec2f,
  normal: vec2f,
  side: f32,
  arcLength: f32,
  normalizedArc: f32,
  miterFactor: f32,
  thickness: f32,
  uniforms: RunnerStrokeUniforms,
) -> vec2f {
  return centerPos + normal * side * (thickness * 0.5) * miterFactor;
}

fn strokeFragShader(
  uv: vec2f,
  arcLength: f32,
  normalizedArc: f32,
  uniforms: RunnerStrokeUniforms,
) -> vec4f {
  let head = fract(uniforms.time * uniforms.speed);
  let dist = abs(normalizedArc - head);
  let wrappedDist = min(dist, 1.0 - dist);
  let seg = max(uniforms.segmentLength, 0.001);
  let feather = max(uniforms.feather, 0.0001);
  let edge0 = max(seg - feather, 0.0);
  let falloff = smoothstep(edge0, seg, wrappedDist);
  let alpha = 1.0 - falloff;
  // Premultiplied alpha avoids MSAA fringe because RGB goes to 0 as coverage fades.
  return vec4f(1.0, 1.0, 1.0, 1.0) * alpha;
}

fn load_RunnerStrokeUniforms() -> RunnerStrokeUniforms {
  return RunnerStrokeUniforms(
  uniforms.uniforms_time,
  uniforms.uniforms_speed,
  uniforms.uniforms_segmentLength,
  uniforms.uniforms_feather
  );
}

#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs) -> FragmentOutputs {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
  let uniformsValue = load_RunnerStrokeUniforms();
  let uv = fragmentInputs.vUV;
  let arcLength = fragmentInputs.vArcLength;
  let normalizedArc = fragmentInputs.vNormalizedArc;
  let color = strokeFragShader(uv, arcLength, normalizedArc, uniformsValue);
  fragmentOutputs.color = color;
#define CUSTOM_FRAGMENT_MAIN_END
}

`;

export interface RunnerStrokeUniforms {
  time: number;
  speed: number;
  segmentLength: number;
  feather: number;
}

export const RunnerUniformDefaults: RunnerStrokeUniforms = {
  time: 0,
  speed: 0,
  segmentLength: 0,
  feather: 0,
};

export const RunnerUniformMeta = [
  {
    name: 'time',
    kind: 'f32',
    bindingName: 'uniforms_time',
  },
  {
    name: 'speed',
    kind: 'f32',
    bindingName: 'uniforms_speed',
  },
  {
    name: 'segmentLength',
    kind: 'f32',
    bindingName: 'uniforms_segmentLength',
  },
  {
    name: 'feather',
    kind: 'f32',
    bindingName: 'uniforms_feather',
  },
] as const;

export function setRunnerStrokeUniforms(material: BABYLON.ShaderMaterial, uniforms: Partial<RunnerStrokeUniforms>): void {
  if (!uniforms) {
    return;
  }
  if (uniforms.time !== undefined) {
    material.setFloat('uniforms_time', uniforms.time);
  }
  if (uniforms.speed !== undefined) {
    material.setFloat('uniforms_speed', uniforms.speed);
  }
  if (uniforms.segmentLength !== undefined) {
    material.setFloat('uniforms_segmentLength', uniforms.segmentLength);
  }
  if (uniforms.feather !== undefined) {
    material.setFloat('uniforms_feather', uniforms.feather);
  }
}

export type RunnerTextureName = never;
export const RunnerTextureNames = [] as const;

export interface RunnerStrokeMaterialDef {
  readonly uniformType: RunnerStrokeUniforms;
  readonly textureNames: readonly never[];
  readonly vertexSource: string;
  readonly fragmentSource: string;
  readonly uniformMeta: typeof RunnerUniformMeta;
  readonly uniformDefaults: RunnerStrokeUniforms;
  readonly createMaterial: (scene: BABYLON.Scene, name?: string) => RunnerStrokeMaterialInstance;
}

export interface RunnerStrokeMaterialInstance {
  material: BABYLON.ShaderMaterial;
  setUniforms(uniforms: Partial<RunnerStrokeUniforms>): void;
  setTexture(name: RunnerTextureName, texture: BABYLON.BaseTexture): void;
  setCanvasSize(width: number, height: number): void;
  dispose(): void;
}

export function createRunnerStrokeMaterial(scene: BABYLON.Scene, name: string = 'RunnerStrokeMaterial'): RunnerStrokeMaterialInstance {
  const vertexShaderName = `${name}VertexShader`;
  const fragmentShaderName = `${name}FragmentShader`;

  BABYLON.ShaderStore.ShadersStoreWGSL[vertexShaderName] = RunnerStrokeVertexSource;
  BABYLON.ShaderStore.ShadersStoreWGSL[fragmentShaderName] = RunnerStrokeFragmentSource;

  const material = new BABYLON.ShaderMaterial(name, scene, {
    vertex: name,
    fragment: name,
  }, {
    attributes: ['position', 'uv', 'strokeNormal', 'strokeSide', 'strokeArcLength', 'strokeNormalizedArc', 'strokeMiterFactor'],
    uniforms: ['uniforms_time', 'uniforms_speed', 'uniforms_segmentLength', 'uniforms_feather', 'power2d_canvasWidth', 'power2d_canvasHeight', 'power2d_strokeThickness'],
    samplers: [],
    samplerObjects: [],
    shaderLanguage: BABYLON.ShaderLanguage.WGSL,
  });

  setRunnerStrokeUniforms(material, RunnerUniformDefaults);
  material.setFloat('power2d_strokeThickness', 1);
  material.disableDepthWrite = true;
  material.depthFunction = BABYLON.Constants.ALWAYS;
  material.backFaceCulling = false;
  material.alphaMode = BABYLON.Engine.ALPHA_COMBINE;

  const handles: RunnerStrokeMaterialInstance = {
    material,
    setUniforms: (uniforms) => setRunnerStrokeUniforms(material, uniforms),
    setTexture: (name, texture) => material.setTexture(name, texture),
    setCanvasSize: (width, height) => {
      material.setFloat('power2d_canvasWidth', width);
      material.setFloat('power2d_canvasHeight', height);
    },
    dispose: () => {
      material.dispose(true, false);
      delete BABYLON.ShaderStore.ShadersStoreWGSL[vertexShaderName];
      delete BABYLON.ShaderStore.ShadersStoreWGSL[fragmentShaderName];
    },
  };

  return handles;
}

export const RunnerStrokeMaterial: RunnerStrokeMaterialDef = {
  uniformType: undefined as unknown as RunnerStrokeUniforms,
  textureNames: RunnerTextureNames,
  vertexSource: RunnerStrokeVertexSource,
  fragmentSource: RunnerStrokeFragmentSource,
  uniformMeta: RunnerUniformMeta,
  uniformDefaults: RunnerUniformDefaults,
  createMaterial: createRunnerStrokeMaterial,
};

export default RunnerStrokeMaterial;
