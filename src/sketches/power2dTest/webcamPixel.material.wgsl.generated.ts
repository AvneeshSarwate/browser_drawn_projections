// Auto-generated by power2d material generator. DO NOT EDIT.
import * as BABYLON from 'babylonjs';

export const WebcamPixelVertexSource = `// Auto-generated by power2d material generator. DO NOT EDIT.
attribute position: vec3<f32>;
attribute uv: vec2<f32>;
varying vUV: vec2<f32>;
uniform uniforms_pixelSize: f32;
uniform uniforms_tint: vec3f;
uniform uniforms_opacity: f32;
uniform power2d_shapeTranslate: vec2f;
uniform power2d_shapeRotation: f32;
uniform power2d_shapeScale: vec2f;
uniform power2d_canvasWidth: f32;
uniform power2d_canvasHeight: f32;

struct WebcamPixelUniforms {
  pixelSize: f32,
  tint: vec3f,
  opacity: f32,
};

fn vertShader(position: vec2f, uv: vec2f, uniforms: WebcamPixelUniforms) -> vec2f {
  return position;
}

fn fragShader(
  uv: vec2f,
  uniforms: WebcamPixelUniforms,
  webcamTex: texture_2d<f32>,
  webcamTexSampler: sampler,
) -> vec4f {
  let pixelSize = max(uniforms.pixelSize, 1.0);
  let texSize = vec2f(textureDimensions(webcamTex));
  let step = vec2f(pixelSize, pixelSize) / texSize;
  let uvClamped = clamp(uv, vec2f(0.0, 0.0), vec2f(1.0, 1.0));
  let quantUV = (floor(uvClamped / step) + vec2f(0.5, 0.5)) * step;
  let pix = textureSample(webcamTex, webcamTexSampler, quantUV);
  let colorPassthru = textureSample(webcamTex, webcamTexSampler, uv);
  let color = select(colorPassthru, pix, uv.x > 0.5);
  return vec4f(color.rgb * uniforms.tint, color.a * uniforms.opacity);
}

fn load_WebcamPixelUniforms() -> WebcamPixelUniforms {
  return WebcamPixelUniforms(
  uniforms.uniforms_pixelSize,
  uniforms.uniforms_tint,
  uniforms.uniforms_opacity
  );
}

fn power2d_applyShapeTransform(pixel: vec2f) -> vec2f {
  let scaled = pixel * uniforms.power2d_shapeScale;
  let s = sin(uniforms.power2d_shapeRotation);
  let c = cos(uniforms.power2d_shapeRotation);
  let rotated = vec2f(
    scaled.x * c - scaled.y * s,
    scaled.x * s + scaled.y * c,
  );
  return rotated + uniforms.power2d_shapeTranslate;
}

fn power2d_pixelToNDC(pixel: vec2f) -> vec4f {
  let ndcX = (pixel.x / uniforms.power2d_canvasWidth) * 2.0 - 1.0;
  let ndcY = -((pixel.y / uniforms.power2d_canvasHeight) * 2.0 - 1.0);
  return vec4f(ndcX, ndcY, 0.0, 1.0);
}

#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs) -> FragmentInputs {
#define CUSTOM_VERTEX_MAIN_BEGIN
  let uniformsValue = load_WebcamPixelUniforms();
  let pixelPos = vec2f(vertexInputs.position.x, vertexInputs.position.y);
  let uv = vertexInputs.uv;
  let adjustedPixelPos = vertShader(pixelPos, uv, uniformsValue);
  let transformedPixelPos = power2d_applyShapeTransform(adjustedPixelPos);
  vertexOutputs.position = power2d_pixelToNDC(transformedPixelPos);
  vertexOutputs.vUV = uv;
#define CUSTOM_VERTEX_MAIN_END
}

`;
export const WebcamPixelFragmentSource = `// Auto-generated by power2d material generator. DO NOT EDIT.
varying vUV: vec2<f32>;
uniform uniforms_pixelSize: f32;
uniform uniforms_tint: vec3f;
uniform uniforms_opacity: f32;
uniform power2d_shapeTranslate: vec2f;
uniform power2d_shapeRotation: f32;
uniform power2d_shapeScale: vec2f;
uniform power2d_canvasWidth: f32;
uniform power2d_canvasHeight: f32;
var webcamTex: texture_2d<f32>;
var webcamTexSampler: sampler;

struct WebcamPixelUniforms {
  pixelSize: f32,
  tint: vec3f,
  opacity: f32,
};

fn vertShader(position: vec2f, uv: vec2f, uniforms: WebcamPixelUniforms) -> vec2f {
  return position;
}

fn fragShader(
  uv: vec2f,
  uniforms: WebcamPixelUniforms,
  webcamTex: texture_2d<f32>,
  webcamTexSampler: sampler,
) -> vec4f {
  let pixelSize = max(uniforms.pixelSize, 1.0);
  let texSize = vec2f(textureDimensions(webcamTex));
  let step = vec2f(pixelSize, pixelSize) / texSize;
  let uvClamped = clamp(uv, vec2f(0.0, 0.0), vec2f(1.0, 1.0));
  let quantUV = (floor(uvClamped / step) + vec2f(0.5, 0.5)) * step;
  let pix = textureSample(webcamTex, webcamTexSampler, quantUV);
  let colorPassthru = textureSample(webcamTex, webcamTexSampler, uv);
  let color = select(colorPassthru, pix, uv.x > 0.5);
  return vec4f(color.rgb * uniforms.tint, color.a * uniforms.opacity);
}

fn load_WebcamPixelUniforms() -> WebcamPixelUniforms {
  return WebcamPixelUniforms(
  uniforms.uniforms_pixelSize,
  uniforms.uniforms_tint,
  uniforms.uniforms_opacity
  );
}

#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs) -> FragmentOutputs {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
  let uv = fragmentInputs.vUV;
  let uniformsValue = load_WebcamPixelUniforms();
  let color = fragShader(uv, uniformsValue, webcamTex, webcamTexSampler);
  fragmentOutputs.color = color;
#define CUSTOM_FRAGMENT_MAIN_END
}

`;

function ensureVector3(value: BABYLON.Vector3 | readonly [number, number, number]): BABYLON.Vector3 {
  return value instanceof BABYLON.Vector3 ? value : BABYLON.Vector3.FromArray(value as readonly [number, number, number]);
}

export interface WebcamPixelUniforms {
  pixelSize: number;
  tint: BABYLON.Vector3 | readonly [number, number, number];
  opacity: number;
}

export const WebcamPixelUniformDefaults: WebcamPixelUniforms = {
  pixelSize: 0,
  tint: [0, 0, 0],
  opacity: 0,
};

export const WebcamPixelUniformMeta = [
  {
    name: 'pixelSize',
    kind: 'f32',
    bindingName: 'uniforms_pixelSize',
  },
  {
    name: 'tint',
    kind: 'vec3f',
    bindingName: 'uniforms_tint',
  },
  {
    name: 'opacity',
    kind: 'f32',
    bindingName: 'uniforms_opacity',
  },
] as const;

export function setWebcamPixelUniforms(material: BABYLON.ShaderMaterial, uniforms: Partial<WebcamPixelUniforms>): void {
  if (!uniforms) {
    return;
  }
  if (uniforms.pixelSize !== undefined) {
    material.setFloat('uniforms_pixelSize', uniforms.pixelSize);
  }
  if (uniforms.tint !== undefined) {
    material.setVector3('uniforms_tint', ensureVector3(uniforms.tint));
  }
  if (uniforms.opacity !== undefined) {
    material.setFloat('uniforms_opacity', uniforms.opacity);
  }
}

export type WebcamPixelTextureName = 'webcamTex';
export const WebcamPixelTextureNames = ['webcamTex'] as const;

export interface WebcamPixelMaterialDef {
  readonly uniformType: WebcamPixelUniforms;
  readonly textureNames: readonly 'webcamTex'[];
  readonly vertexSource: string;
  readonly fragmentSource: string;
  readonly uniformMeta: typeof WebcamPixelUniformMeta;
  readonly uniformDefaults: WebcamPixelUniforms;
  readonly createMaterial: (scene: BABYLON.Scene, name?: string) => WebcamPixelMaterialInstance;
}

export interface WebcamPixelMaterialInstance {
  material: BABYLON.ShaderMaterial;
  setUniforms(uniforms: Partial<WebcamPixelUniforms>): void;
  setTexture(name: WebcamPixelTextureName, texture: BABYLON.BaseTexture): void;
  setTextureSampler(name: WebcamPixelTextureName, sampler: BABYLON.TextureSampler): void;
  setCanvasSize(width: number, height: number): void;
  dispose(): void;
}

export function createWebcamPixelMaterial(scene: BABYLON.Scene, name: string = 'WebcamPixelMaterial'): WebcamPixelMaterialInstance {
  const vertexShaderName = `${name}VertexShader`;
  const fragmentShaderName = `${name}FragmentShader`;

  BABYLON.ShaderStore.ShadersStoreWGSL[vertexShaderName] = WebcamPixelVertexSource;
  BABYLON.ShaderStore.ShadersStoreWGSL[fragmentShaderName] = WebcamPixelFragmentSource;

  const material = new BABYLON.ShaderMaterial(name, scene, {
    vertex: name,
    fragment: name,
  }, {
    attributes: ['position', 'uv'],
    uniforms: ['uniforms_pixelSize', 'uniforms_tint', 'uniforms_opacity', 'power2d_shapeTranslate', 'power2d_shapeRotation', 'power2d_shapeScale', 'power2d_canvasWidth', 'power2d_canvasHeight'],
    samplers: ['webcamTex'],
    samplerObjects: ['webcamTexSampler'],
    shaderLanguage: BABYLON.ShaderLanguage.WGSL,
  });

  const defaultSampler = new BABYLON.TextureSampler();
  defaultSampler.setParameters(
    BABYLON.Texture.CLAMP_ADDRESSMODE,
    BABYLON.Texture.CLAMP_ADDRESSMODE,
    BABYLON.Texture.CLAMP_ADDRESSMODE,
    undefined,
    BABYLON.Texture.BILINEAR_SAMPLINGMODE,
  );
  material.setTextureSampler('webcamTexSampler', defaultSampler);

  setWebcamPixelUniforms(material, WebcamPixelUniformDefaults);
  material.setVector2('power2d_shapeTranslate', new BABYLON.Vector2(0, 0));
  material.setFloat('power2d_shapeRotation', 0);
  material.setVector2('power2d_shapeScale', new BABYLON.Vector2(1, 1));
  material.disableDepthWrite = true;
  material.depthFunction = BABYLON.Constants.ALWAYS;
  material.backFaceCulling = false;
  material.alphaMode = BABYLON.Engine.ALPHA_COMBINE;

  const samplerLookup = { 'webcamTex': 'webcamTexSampler' } as const;

  const handles: WebcamPixelMaterialInstance = {
    material,
    setUniforms: (uniforms) => setWebcamPixelUniforms(material, uniforms),
    setTexture: (name, texture) => material.setTexture(name, texture),
    setTextureSampler: (name, sampler) => {
      const samplerName = (samplerLookup as Record<string, string | undefined>)[name];
      if (samplerName) {
        material.setTextureSampler(samplerName, sampler);
      }
    },
    setCanvasSize: (width, height) => {
      material.setFloat('power2d_canvasWidth', width);
      material.setFloat('power2d_canvasHeight', height);
    },
    dispose: () => {
      material.dispose(true, false);
      delete BABYLON.ShaderStore.ShadersStoreWGSL[vertexShaderName];
      delete BABYLON.ShaderStore.ShadersStoreWGSL[fragmentShaderName];
    },
  };

  return handles;
}

export const WebcamPixelMaterial: WebcamPixelMaterialDef = {
  uniformType: undefined as unknown as WebcamPixelUniforms,
  textureNames: WebcamPixelTextureNames,
  vertexSource: WebcamPixelVertexSource,
  fragmentSource: WebcamPixelFragmentSource,
  uniformMeta: WebcamPixelUniformMeta,
  uniformDefaults: WebcamPixelUniformDefaults,
  createMaterial: createWebcamPixelMaterial,
};

export default WebcamPixelMaterial;
