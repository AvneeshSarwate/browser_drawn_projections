// Auto-generated by power2d glsl stroke material generator. DO NOT EDIT.
import * as BABYLON from 'babylonjs';

export const RunnerVertexSource = `// Auto-generated by power2d glsl stroke material generator. DO NOT EDIT.
#version 300 es
precision highp float;

in vec3 position;
in vec2 uv;
in vec2 strokeNormal;
in float strokeSide;
in float strokeArcLength;
in float strokeNormalizedArc;
in float strokeMiterFactor;
out vec2 vUV;
out float vArcLength;
out float vNormalizedArc;
uniform float uniforms_time;
uniform float uniforms_speed;
uniform float uniforms_segmentLength;
uniform float uniforms_feather;
uniform vec2 power2d_shapeTranslate;
uniform float power2d_shapeRotation;
uniform vec2 power2d_shapeScale;
uniform float power2d_canvasWidth;
uniform float power2d_canvasHeight;
uniform float power2d_strokeThickness;

struct RunnerStrokeUniforms {
  float time;
  float speed;
  float segmentLength;
  float feather;
};

vec2 strokeVertShader(
  vec2 centerPos,
  vec2 normal,
  float side,
  float arcLength,
  float normalizedArc,
  float miterFactor,
  float thickness,
  RunnerStrokeUniforms uniforms
) {
  return centerPos + normal * side * (thickness * 0.5) * miterFactor;
}

vec4 strokeFragShader(
  vec2 uv,
  float arcLength,
  float normalizedArc,
  RunnerStrokeUniforms uniforms
) {
  float head = fract(uniforms.time * uniforms.speed);
  float dist = abs(normalizedArc - head);
  float wrappedDist = min(dist, 1.0 - dist);
  float seg = max(uniforms.segmentLength, 0.001);
  float feather = max(uniforms.feather, 0.0001);
  float edge0 = max(seg - feather, 0.0);
  float falloff = smoothstep(edge0, seg, wrappedDist);
  float alpha = 1.0 - falloff;
  return vec4(1.0, 1.0, 1.0, 1.0) * alpha;
}


RunnerStrokeUniforms load_RunnerStrokeUniforms() {
  return RunnerStrokeUniforms(
    uniforms_time,
    uniforms_speed,
    uniforms_segmentLength,
    uniforms_feather
  );
}

vec2 power2d_applyShapeTransform(vec2 pixel) {
  vec2 scaled = pixel * power2d_shapeScale;
  float s = sin(power2d_shapeRotation);
  float c = cos(power2d_shapeRotation);
  vec2 rotated = vec2(
    scaled.x * c - scaled.y * s,
    scaled.x * s + scaled.y * c
  );
  return rotated + power2d_shapeTranslate;
}

vec4 power2d_pixelToNDC(vec2 pixel) {
  float ndcX = (pixel.x / power2d_canvasWidth) * 2.0 - 1.0;
  float ndcY = -((pixel.y / power2d_canvasHeight) * 2.0 - 1.0);
  return vec4(ndcX, ndcY, 0.0, 1.0);
}

void main() {
  RunnerStrokeUniforms uniformsValue = load_RunnerStrokeUniforms();
  vec2 centerPos = vec2(position.x, position.y);
  vec2 normal = strokeNormal;
  float side = strokeSide;
  float arcLength = strokeArcLength;
  float normalizedArc = strokeNormalizedArc;
  float miterFactor = strokeMiterFactor;
  float thickness = power2d_strokeThickness;
  vec2 uvLocal = uv;
  vec2 adjustedPixelPos = strokeVertShader(centerPos, normal, side, arcLength, normalizedArc, miterFactor, thickness, uniformsValue);
  vec2 transformedPixelPos = power2d_applyShapeTransform(adjustedPixelPos);
  gl_Position = power2d_pixelToNDC(transformedPixelPos);
  vUV = uvLocal;
  vArcLength = arcLength;
  vNormalizedArc = normalizedArc;
}`;
export const RunnerFragmentSource = `// Auto-generated by power2d glsl stroke material generator. DO NOT EDIT.
#version 300 es
precision highp float;

in vec2 vUV;
in float vArcLength;
in float vNormalizedArc;
out vec4 outColor;
uniform float uniforms_time;
uniform float uniforms_speed;
uniform float uniforms_segmentLength;
uniform float uniforms_feather;
uniform vec2 power2d_shapeTranslate;
uniform float power2d_shapeRotation;
uniform vec2 power2d_shapeScale;
uniform float power2d_canvasWidth;
uniform float power2d_canvasHeight;
uniform float power2d_strokeThickness;

struct RunnerStrokeUniforms {
  float time;
  float speed;
  float segmentLength;
  float feather;
};

vec2 strokeVertShader(
  vec2 centerPos,
  vec2 normal,
  float side,
  float arcLength,
  float normalizedArc,
  float miterFactor,
  float thickness,
  RunnerStrokeUniforms uniforms
) {
  return centerPos + normal * side * (thickness * 0.5) * miterFactor;
}

vec4 strokeFragShader(
  vec2 uv,
  float arcLength,
  float normalizedArc,
  RunnerStrokeUniforms uniforms
) {
  float head = fract(uniforms.time * uniforms.speed);
  float dist = abs(normalizedArc - head);
  float wrappedDist = min(dist, 1.0 - dist);
  float seg = max(uniforms.segmentLength, 0.001);
  float feather = max(uniforms.feather, 0.0001);
  float edge0 = max(seg - feather, 0.0);
  float falloff = smoothstep(edge0, seg, wrappedDist);
  float alpha = 1.0 - falloff;
  return vec4(1.0, 1.0, 1.0, 1.0) * alpha;
}


RunnerStrokeUniforms load_RunnerStrokeUniforms() {
  return RunnerStrokeUniforms(
    uniforms_time,
    uniforms_speed,
    uniforms_segmentLength,
    uniforms_feather
  );
}

void main() {
  RunnerStrokeUniforms uniformsValue = load_RunnerStrokeUniforms();
  vec2 uvLocal = vUV;
  float arcLength = vArcLength;
  float normalizedArc = vNormalizedArc;
  vec4 color = strokeFragShader(uvLocal, arcLength, normalizedArc, uniformsValue);
  outColor = color;
}`;

export interface RunnerUniforms {
  time: number;
  speed: number;
  segmentLength: number;
  feather: number;
}

export const RunnerUniformDefaults: RunnerUniforms = {
  time: 0,
  speed: 0,
  segmentLength: 0,
  feather: 0,
};

export const RunnerUniformMeta = [
  {
    name: 'time',
    kind: 'f32',
    bindingName: 'uniforms_time',
  },
  {
    name: 'speed',
    kind: 'f32',
    bindingName: 'uniforms_speed',
  },
  {
    name: 'segmentLength',
    kind: 'f32',
    bindingName: 'uniforms_segmentLength',
  },
  {
    name: 'feather',
    kind: 'f32',
    bindingName: 'uniforms_feather',
  },
] as const;

export function setRunnerUniforms(material: BABYLON.ShaderMaterial, uniforms: Partial<RunnerUniforms>): void {
  if (!uniforms) {
    return;
  }
  if (uniforms.time !== undefined) {
    material.setFloat('uniforms_time', uniforms.time);
  }
  if (uniforms.speed !== undefined) {
    material.setFloat('uniforms_speed', uniforms.speed);
  }
  if (uniforms.segmentLength !== undefined) {
    material.setFloat('uniforms_segmentLength', uniforms.segmentLength);
  }
  if (uniforms.feather !== undefined) {
    material.setFloat('uniforms_feather', uniforms.feather);
  }
}

export type RunnerTextureName = never;
export const RunnerTextureNames = [] as const;

export interface RunnerStrokeMaterialDef {
  readonly uniformType: RunnerUniforms;
  readonly textureNames: readonly RunnerTextureName[];
  readonly vertexSource: string;
  readonly fragmentSource: string;
  readonly uniformMeta: typeof RunnerUniformMeta;
  readonly uniformDefaults: RunnerUniforms;
  readonly createMaterial: (scene: BABYLON.Scene, name?: string) => RunnerStrokeMaterialInstance;
}

export interface RunnerStrokeMaterialInstance {
  material: BABYLON.ShaderMaterial;
  setUniforms(uniforms: Partial<RunnerUniforms>): void;
  setTexture(name: RunnerTextureName, texture: BABYLON.BaseTexture): void;
  setCanvasSize(width: number, height: number): void;
  dispose(): void;
}

export function createRunnerStrokeMaterial(scene: BABYLON.Scene, name: string = 'RunnerStrokeMaterial'): RunnerStrokeMaterialInstance {
  const vertexShaderName = `${name}VertexShader`;
  const fragmentShaderName = `${name}FragmentShader`;

  BABYLON.ShaderStore.ShadersStore[vertexShaderName] = RunnerVertexSource;
  BABYLON.ShaderStore.ShadersStore[fragmentShaderName] = RunnerFragmentSource;

  const material = new BABYLON.ShaderMaterial(name, scene, {
    vertex: name,
    fragment: name,
  }, {
    attributes: ["position","uv","strokeNormal","strokeSide","strokeArcLength","strokeNormalizedArc","strokeMiterFactor"],
    uniforms: ["uniforms_time","uniforms_speed","uniforms_segmentLength","uniforms_feather","power2d_shapeTranslate","power2d_shapeRotation","power2d_shapeScale","power2d_canvasWidth","power2d_canvasHeight","power2d_strokeThickness"],
    samplers: [],
    shaderLanguage: BABYLON.ShaderLanguage.GLSL,
  });

  setRunnerUniforms(material, RunnerUniformDefaults);
  material.setVector2('power2d_shapeTranslate', new BABYLON.Vector2(0, 0));
  material.setFloat('power2d_shapeRotation', 0);
  material.setVector2('power2d_shapeScale', new BABYLON.Vector2(1, 1));
  material.setFloat('power2d_strokeThickness', 1);
  material.disableDepthWrite = true;
  material.depthFunction = BABYLON.Constants.ALWAYS;
  material.backFaceCulling = false;
  material.alphaMode = BABYLON.Engine.ALPHA_COMBINE;

  const handles: RunnerStrokeMaterialInstance = {
    material,
    setUniforms: (uniforms) => setRunnerUniforms(material, uniforms),
    setTexture: (name, texture) => material.setTexture(name, texture),
    setCanvasSize: (width, height) => {
      material.setFloat('power2d_canvasWidth', width);
      material.setFloat('power2d_canvasHeight', height);
    },
    dispose: () => {
      material.dispose(true, false);
      delete BABYLON.ShaderStore.ShadersStore[vertexShaderName];
      delete BABYLON.ShaderStore.ShadersStore[fragmentShaderName];
    },
  };

  return handles;
}

export const RunnerStrokeMaterial: RunnerStrokeMaterialDef = {
  uniformType: undefined as unknown as RunnerUniforms,
  textureNames: RunnerTextureNames,
  vertexSource: RunnerVertexSource,
  fragmentSource: RunnerFragmentSource,
  uniformMeta: RunnerUniformMeta,
  uniformDefaults: RunnerUniformDefaults,
  createMaterial: createRunnerStrokeMaterial,
};

export const RunnerMaterial: RunnerStrokeMaterialDef = RunnerStrokeMaterial;

export default RunnerStrokeMaterial;