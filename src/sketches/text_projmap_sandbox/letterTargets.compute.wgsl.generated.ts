// Auto-generated by wgsl type generator. DO NOT EDIT.

import * as BABYLON from 'babylonjs';

import shaderSource from './letterTargets.compute.wgsl?raw';

export interface LetterTargetsParticle {
  uv: Float32Array | readonly number[];
  pad: Float32Array | readonly number[];
  color: Float32Array | readonly number[];
}

export const LetterTargetsParticleLayout = {
  size: 32,
  align: 16,
  members: [
  { name: 'uv', offset: 0, size: 8, slot: 2 },
  { name: 'pad', offset: 8, size: 8, slot: 2 },
  { name: 'color', offset: 16, size: 16, slot: 4 }
  ] as const,
} as const;

export function packLetterTargetsParticle(target: Float32Array, floatOffset: number, value: LetterTargetsParticle): void {
  {
    const base = floatOffset + 0;
    const uvSource = value.uv as any;
    for (let i = 0; i < 2; i++) {
      const component = uvSource?.[i];
      target[base + i] = component !== undefined ? Number(component) : 0;
    }
  }
  {
    const base = floatOffset + 2;
    const padSource = value.pad as any;
    for (let i = 0; i < 2; i++) {
      const component = padSource?.[i];
      target[base + i] = component !== undefined ? Number(component) : 0;
    }
  }
  {
    const base = floatOffset + 4;
    const colorSource = value.color as any;
    for (let i = 0; i < 4; i++) {
      const component = colorSource?.[i];
      target[base + i] = component !== undefined ? Number(component) : 0;
    }
  }
}

export interface LetterTargetsPlacementSettings {
  lerpT: number;
  bboxOriginX: number;
  bboxOriginY: number;
  bboxWidth: number;
  bboxHeight: number;
  canvasWidth: number;
  canvasHeight: number;
  targetRadius: number;
  circleRadius: number;
  maxParticles: number;
  liveCount: number;
  targetLayout: number;
  seed: number;
  bboxCenterNdcX: number;
  bboxCenterNdcY: number;
  padding: number;
}

export const LetterTargetsPlacementSettingsLayout = {
  size: 64,
  align: 4,
  members: [
  { name: 'lerpT', offset: 0, size: 4, slot: 1 },
  { name: 'bboxOriginX', offset: 4, size: 4, slot: 1 },
  { name: 'bboxOriginY', offset: 8, size: 4, slot: 1 },
  { name: 'bboxWidth', offset: 12, size: 4, slot: 1 },
  { name: 'bboxHeight', offset: 16, size: 4, slot: 1 },
  { name: 'canvasWidth', offset: 20, size: 4, slot: 1 },
  { name: 'canvasHeight', offset: 24, size: 4, slot: 1 },
  { name: 'targetRadius', offset: 28, size: 4, slot: 1 },
  { name: 'circleRadius', offset: 32, size: 4, slot: 1 },
  { name: 'maxParticles', offset: 36, size: 4, slot: 1 },
  { name: 'liveCount', offset: 40, size: 4, slot: 1 },
  { name: 'targetLayout', offset: 44, size: 4, slot: 1 },
  { name: 'seed', offset: 48, size: 4, slot: 1 },
  { name: 'bboxCenterNdcX', offset: 52, size: 4, slot: 1 },
  { name: 'bboxCenterNdcY', offset: 56, size: 4, slot: 1 },
  { name: 'padding', offset: 60, size: 4, slot: 1 }
  ] as const,
} as const;

export function packLetterTargetsPlacementSettings(target: Float32Array, floatOffset: number, value: LetterTargetsPlacementSettings): void {
  const uintView = new Uint32Array(target.buffer);
  {
    const base = floatOffset + 0;
    const raw = value.lerpT;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 1;
    const raw = value.bboxOriginX;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 2;
    const raw = value.bboxOriginY;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 3;
    const raw = value.bboxWidth;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 4;
    const raw = value.bboxHeight;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 5;
    const raw = value.canvasWidth;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 6;
    const raw = value.canvasHeight;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 7;
    const raw = value.targetRadius;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 8;
    const raw = value.circleRadius;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 9;
    const raw = value.maxParticles;
    uintView[base] = raw !== undefined ? Math.trunc(raw as number) >>> 0 : 0;
  }
  {
    const base = floatOffset + 10;
    const raw = value.liveCount;
    uintView[base] = raw !== undefined ? Math.trunc(raw as number) >>> 0 : 0;
  }
  {
    const base = floatOffset + 11;
    const raw = value.targetLayout;
    uintView[base] = raw !== undefined ? Math.trunc(raw as number) >>> 0 : 0;
  }
  {
    const base = floatOffset + 12;
    const raw = value.seed;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 13;
    const raw = value.bboxCenterNdcX;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 14;
    const raw = value.bboxCenterNdcY;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 15;
    const raw = value.padding;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
}

const uniformLayout_settings = [
  { name: 'lerpT', slot: 1 },
  { name: 'bboxOriginX', slot: 1 },
  { name: 'bboxOriginY', slot: 1 },
  { name: 'bboxWidth', slot: 1 },
  { name: 'bboxHeight', slot: 1 },
  { name: 'canvasWidth', slot: 1 },
  { name: 'canvasHeight', slot: 1 },
  { name: 'targetRadius', slot: 1 },
  { name: 'circleRadius', slot: 1 },
  { name: 'maxParticles', slot: 1 },
  { name: 'liveCount', slot: 1 },
  { name: 'targetLayout', slot: 1 },
  { name: 'seed', slot: 1 },
  { name: 'bboxCenterNdcX', slot: 1 },
  { name: 'bboxCenterNdcY', slot: 1 },
  { name: 'padding', slot: 1 }
] as const;

export interface SettingsUniforms {
  lerpT: number;
  bboxOriginX: number;
  bboxOriginY: number;
  bboxWidth: number;
  bboxHeight: number;
  canvasWidth: number;
  canvasHeight: number;
  targetRadius: number;
  circleRadius: number;
  maxParticles: number;
  liveCount: number;
  targetLayout: number;
  seed: number;
  bboxCenterNdcX: number;
  bboxCenterNdcY: number;
  padding: number;
}

export interface SettingsUniformState {
  buffer: BABYLON.UniformBuffer;
  uniforms: SettingsUniforms;
}

export function createUniformBuffer_settings(engine: BABYLON.WebGPUEngine, initial?: Partial<SettingsUniforms>): SettingsUniformState {
  const buffer = new BABYLON.UniformBuffer(engine);
  const uniforms: SettingsUniforms = {
    lerpT: 0,
    bboxOriginX: 0,
    bboxOriginY: 0,
    bboxWidth: 0,
    bboxHeight: 0,
    canvasWidth: 0,
    canvasHeight: 0,
    targetRadius: 0,
    circleRadius: 0,
    maxParticles: 0,
    liveCount: 0,
    targetLayout: 0,
    seed: 0,
    bboxCenterNdcX: 0,
    bboxCenterNdcY: 0,
    padding: 0,
  };
  for (const entry of uniformLayout_settings) {
    buffer.addUniform(entry.name, entry.slot);
  }
  if (initial) {
    updateUniformBuffer_settings({ buffer, uniforms }, initial);
  } else {
    buffer.update();
  }
  return { buffer, uniforms };
}

export function updateUniformBuffer_settings(state: SettingsUniformState, updates: Partial<SettingsUniforms>): void {
  let dirty = false;
  if (updates.lerpT !== undefined) {
    dirty = true;
    const raw = updates.lerpT! as any;
    const numeric = raw !== undefined ? Number(raw) : 0;
    state.uniforms.lerpT = numeric;
    const bufferView = new Float32Array(1);
    bufferView[0] = numeric;
    state.buffer.updateUniform('lerpT', bufferView, 1);
  }
  if (updates.bboxOriginX !== undefined) {
    dirty = true;
    const raw = updates.bboxOriginX! as any;
    const numeric = raw !== undefined ? Number(raw) : 0;
    state.uniforms.bboxOriginX = numeric;
    const bufferView = new Float32Array(1);
    bufferView[0] = numeric;
    state.buffer.updateUniform('bboxOriginX', bufferView, 1);
  }
  if (updates.bboxOriginY !== undefined) {
    dirty = true;
    const raw = updates.bboxOriginY! as any;
    const numeric = raw !== undefined ? Number(raw) : 0;
    state.uniforms.bboxOriginY = numeric;
    const bufferView = new Float32Array(1);
    bufferView[0] = numeric;
    state.buffer.updateUniform('bboxOriginY', bufferView, 1);
  }
  if (updates.bboxWidth !== undefined) {
    dirty = true;
    const raw = updates.bboxWidth! as any;
    const numeric = raw !== undefined ? Number(raw) : 0;
    state.uniforms.bboxWidth = numeric;
    const bufferView = new Float32Array(1);
    bufferView[0] = numeric;
    state.buffer.updateUniform('bboxWidth', bufferView, 1);
  }
  if (updates.bboxHeight !== undefined) {
    dirty = true;
    const raw = updates.bboxHeight! as any;
    const numeric = raw !== undefined ? Number(raw) : 0;
    state.uniforms.bboxHeight = numeric;
    const bufferView = new Float32Array(1);
    bufferView[0] = numeric;
    state.buffer.updateUniform('bboxHeight', bufferView, 1);
  }
  if (updates.canvasWidth !== undefined) {
    dirty = true;
    const raw = updates.canvasWidth! as any;
    const numeric = raw !== undefined ? Number(raw) : 0;
    state.uniforms.canvasWidth = numeric;
    const bufferView = new Float32Array(1);
    bufferView[0] = numeric;
    state.buffer.updateUniform('canvasWidth', bufferView, 1);
  }
  if (updates.canvasHeight !== undefined) {
    dirty = true;
    const raw = updates.canvasHeight! as any;
    const numeric = raw !== undefined ? Number(raw) : 0;
    state.uniforms.canvasHeight = numeric;
    const bufferView = new Float32Array(1);
    bufferView[0] = numeric;
    state.buffer.updateUniform('canvasHeight', bufferView, 1);
  }
  if (updates.targetRadius !== undefined) {
    dirty = true;
    const raw = updates.targetRadius! as any;
    const numeric = raw !== undefined ? Number(raw) : 0;
    state.uniforms.targetRadius = numeric;
    const bufferView = new Float32Array(1);
    bufferView[0] = numeric;
    state.buffer.updateUniform('targetRadius', bufferView, 1);
  }
  if (updates.circleRadius !== undefined) {
    dirty = true;
    const raw = updates.circleRadius! as any;
    const numeric = raw !== undefined ? Number(raw) : 0;
    state.uniforms.circleRadius = numeric;
    const bufferView = new Float32Array(1);
    bufferView[0] = numeric;
    state.buffer.updateUniform('circleRadius', bufferView, 1);
  }
  if (updates.maxParticles !== undefined) {
    dirty = true;
    const raw = updates.maxParticles! as any;
    const numeric = raw !== undefined ? Math.trunc(raw as number) >>> 0 : 0;
    const scratch = new ArrayBuffer(4);
    new Uint32Array(scratch)[0] = numeric;
    state.uniforms.maxParticles = numeric;
    state.buffer.updateUniform('maxParticles', new Float32Array(scratch), 1);
  }
  if (updates.liveCount !== undefined) {
    dirty = true;
    const raw = updates.liveCount! as any;
    const numeric = raw !== undefined ? Math.trunc(raw as number) >>> 0 : 0;
    const scratch = new ArrayBuffer(4);
    new Uint32Array(scratch)[0] = numeric;
    state.uniforms.liveCount = numeric;
    state.buffer.updateUniform('liveCount', new Float32Array(scratch), 1);
  }
  if (updates.targetLayout !== undefined) {
    dirty = true;
    const raw = updates.targetLayout! as any;
    const numeric = raw !== undefined ? Math.trunc(raw as number) >>> 0 : 0;
    const scratch = new ArrayBuffer(4);
    new Uint32Array(scratch)[0] = numeric;
    state.uniforms.targetLayout = numeric;
    state.buffer.updateUniform('targetLayout', new Float32Array(scratch), 1);
  }
  if (updates.seed !== undefined) {
    dirty = true;
    const raw = updates.seed! as any;
    const numeric = raw !== undefined ? Number(raw) : 0;
    state.uniforms.seed = numeric;
    const bufferView = new Float32Array(1);
    bufferView[0] = numeric;
    state.buffer.updateUniform('seed', bufferView, 1);
  }
  if (updates.bboxCenterNdcX !== undefined) {
    dirty = true;
    const raw = updates.bboxCenterNdcX! as any;
    const numeric = raw !== undefined ? Number(raw) : 0;
    state.uniforms.bboxCenterNdcX = numeric;
    const bufferView = new Float32Array(1);
    bufferView[0] = numeric;
    state.buffer.updateUniform('bboxCenterNdcX', bufferView, 1);
  }
  if (updates.bboxCenterNdcY !== undefined) {
    dirty = true;
    const raw = updates.bboxCenterNdcY! as any;
    const numeric = raw !== undefined ? Number(raw) : 0;
    state.uniforms.bboxCenterNdcY = numeric;
    const bufferView = new Float32Array(1);
    bufferView[0] = numeric;
    state.buffer.updateUniform('bboxCenterNdcY', bufferView, 1);
  }
  if (updates.padding !== undefined) {
    dirty = true;
    const raw = updates.padding! as any;
    const numeric = raw !== undefined ? Number(raw) : 0;
    state.uniforms.padding = numeric;
    const bufferView = new Float32Array(1);
    bufferView[0] = numeric;
    state.buffer.updateUniform('padding', bufferView, 1);
  }
  if (dirty) {
    state.buffer.update();
  }
}

export interface ParticlesStorageState {
  buffer: BABYLON.StorageBuffer;
  data: Float32Array;
  capacity: number;
  floatsPerElement: number;
}

export function createStorageBuffer_particles(engine: BABYLON.WebGPUEngine, capacity: number, options?: { initial?: LetterTargetsParticle[]; usage?: number; }): ParticlesStorageState {
  const byteStride = 32;
  const floatsPerElement = byteStride / Float32Array.BYTES_PER_ELEMENT;
  const totalFloats = floatsPerElement * capacity;
  const data = new Float32Array(totalFloats);
  const usage = options?.usage ?? (BABYLON.Constants.BUFFER_CREATIONFLAG_STORAGE | BABYLON.Constants.BUFFER_CREATIONFLAG_WRITE);
  const buffer = new BABYLON.StorageBuffer(engine, byteStride * capacity, usage);
  if (options?.initial) {
    options.initial.slice(0, capacity).forEach((value, index) => {
      packLetterTargetsParticle(data, index * floatsPerElement, value);
    });
    buffer.update(data);
  }
  return { buffer, data, capacity, floatsPerElement };
}

export function writeStorageValue_particles(state: ParticlesStorageState, index: number, value: LetterTargetsParticle): void {
  const offset = index * state.floatsPerElement;
  packLetterTargetsParticle(state.data, offset, value);
}

export function updateStorageBuffer_particles(state: ParticlesStorageState): void {
  state.buffer.update(state.data);
}

export interface InstanceMatricesStorageState {
  buffer: BABYLON.StorageBuffer;
  data: Float32Array;
  capacity: number;
  floatsPerElement: number;
}

export function createStorageBuffer_instanceMatrices(engine: BABYLON.WebGPUEngine, capacity: number, options?: { initial?: number[][]; usage?: number; }): InstanceMatricesStorageState {
  const byteStride = 16;
  const floatsPerElement = byteStride / Float32Array.BYTES_PER_ELEMENT;
  const totalFloats = floatsPerElement * capacity;
  const data = new Float32Array(totalFloats);
  const usage = options?.usage ?? (BABYLON.Constants.BUFFER_CREATIONFLAG_STORAGE | BABYLON.Constants.BUFFER_CREATIONFLAG_WRITE);
  const buffer = new BABYLON.StorageBuffer(engine, byteStride * capacity, usage);
  if (options?.initial) {
    data.set(options.initial.flat().slice(0, totalFloats));
    buffer.update(data);
  }
  return { buffer, data, capacity, floatsPerElement };
}

export function writeStorageValue_instanceMatrices(state: InstanceMatricesStorageState, index: number, value: number[]): void {
  const offset = index * state.floatsPerElement;
  for (let i = 0; i < state.floatsPerElement; i++) {
    state.data[offset + i] = value[i] ?? 0;
  }
}

export function updateStorageBuffer_instanceMatrices(state: InstanceMatricesStorageState): void {
  state.buffer.update(state.data);
}

export interface InstanceColorsStorageState {
  buffer: BABYLON.StorageBuffer;
  data: Float32Array;
  capacity: number;
  floatsPerElement: number;
}

export function createStorageBuffer_instanceColors(engine: BABYLON.WebGPUEngine, capacity: number, options?: { initial?: number[][]; usage?: number; }): InstanceColorsStorageState {
  const byteStride = 16;
  const floatsPerElement = byteStride / Float32Array.BYTES_PER_ELEMENT;
  const totalFloats = floatsPerElement * capacity;
  const data = new Float32Array(totalFloats);
  const usage = options?.usage ?? (BABYLON.Constants.BUFFER_CREATIONFLAG_STORAGE | BABYLON.Constants.BUFFER_CREATIONFLAG_WRITE);
  const buffer = new BABYLON.StorageBuffer(engine, byteStride * capacity, usage);
  if (options?.initial) {
    data.set(options.initial.flat().slice(0, totalFloats));
    buffer.update(data);
  }
  return { buffer, data, capacity, floatsPerElement };
}

export function writeStorageValue_instanceColors(state: InstanceColorsStorageState, index: number, value: number[]): void {
  const offset = index * state.floatsPerElement;
  for (let i = 0; i < state.floatsPerElement; i++) {
    state.data[offset + i] = value[i] ?? 0;
  }
}

export function updateStorageBuffer_instanceColors(state: InstanceColorsStorageState): void {
  state.buffer.update(state.data);
}

const bindingLayout = {
    settings: { group: 0, binding: 1 },
    particles: { group: 0, binding: 0 },
    instanceMatrices: { group: 0, binding: 2 },
    instanceColors: { group: 0, binding: 3 }
};

export interface ShaderBindings {
    settings: SettingsUniformState;
    particles: BABYLON.StorageBuffer;
    instanceMatrices: BABYLON.StorageBuffer;
    instanceColors: BABYLON.StorageBuffer;
}

export interface ShaderState {
  shader: BABYLON.ComputeShader;
  bindings: ShaderBindings;
}

export function createShader(engine: BABYLON.WebGPUEngine, bindings: ShaderBindings, options?: { entryPoint?: string; source?: string; name?: string; }): ShaderState {
  const shader = new BABYLON.ComputeShader(options?.name ?? 'letterTargets', engine, { computeSource: options?.source ?? shaderSource }, {
    entryPoint: options?.entryPoint ?? 'main',
    bindingsMapping: bindingLayout,
  });
  shader.setUniformBuffer('settings', bindings.settings.buffer);
  shader.setStorageBuffer('particles', bindings.particles);
  shader.setStorageBuffer('instanceMatrices', bindings.instanceMatrices);
  shader.setStorageBuffer('instanceColors', bindings.instanceColors);
  return { shader, bindings };
}

export function updateBindings(state: ShaderState, updates: Partial<ShaderBindings>): void {
  if (updates.settings !== undefined) {
    state.bindings.settings = updates.settings!;
    state.shader.setUniformBuffer('settings', updates.settings!.buffer);
  }
  if (updates.particles !== undefined) {
    state.bindings.particles = updates.particles!;
    state.shader.setStorageBuffer('particles', updates.particles!);
  }
  if (updates.instanceMatrices !== undefined) {
    state.bindings.instanceMatrices = updates.instanceMatrices!;
    state.shader.setStorageBuffer('instanceMatrices', updates.instanceMatrices!);
  }
  if (updates.instanceColors !== undefined) {
    state.bindings.instanceColors = updates.instanceColors!;
    state.shader.setStorageBuffer('instanceColors', updates.instanceColors!);
  }
}

export const createUniformBuffer = createUniformBuffer_settings;
export const updateUniformBuffer = updateUniformBuffer_settings;